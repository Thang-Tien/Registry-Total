"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/clone";
exports.ids = ["vendor-chunks/clone"];
exports.modules = {

/***/ "(ssr)/./node_modules/clone/clone.js":
/*!*************************************!*\
  !*** ./node_modules/clone/clone.js ***!
  \*************************************/
/***/ ((module) => {

eval("\nvar clone = function() {\n    \"use strict\";\n    function _instanceof(obj, type) {\n        return type != null && obj instanceof type;\n    }\n    var nativeMap;\n    try {\n        nativeMap = Map;\n    } catch (_) {\n        // maybe a reference error because no `Map`. Give it a dummy value that no\n        // value will ever be an instanceof.\n        nativeMap = function() {};\n    }\n    var nativeSet;\n    try {\n        nativeSet = Set;\n    } catch (_) {\n        nativeSet = function() {};\n    }\n    var nativePromise;\n    try {\n        nativePromise = Promise;\n    } catch (_) {\n        nativePromise = function() {};\n    }\n    /**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/ function clone(parent, circular, depth, prototype, includeNonEnumerable) {\n        if (typeof circular === \"object\") {\n            depth = circular.depth;\n            prototype = circular.prototype;\n            includeNonEnumerable = circular.includeNonEnumerable;\n            circular = circular.circular;\n        }\n        // maintain two arrays for circular references, where corresponding parents\n        // and children have the same index\n        var allParents = [];\n        var allChildren = [];\n        var useBuffer = typeof Buffer != \"undefined\";\n        if (typeof circular == \"undefined\") circular = true;\n        if (typeof depth == \"undefined\") depth = Infinity;\n        // recurse this function so we don't reset allParents and allChildren\n        function _clone(parent, depth) {\n            // cloning null always returns null\n            if (parent === null) return null;\n            if (depth === 0) return parent;\n            var child;\n            var proto;\n            if (typeof parent != \"object\") {\n                return parent;\n            }\n            if (_instanceof(parent, nativeMap)) {\n                child = new nativeMap();\n            } else if (_instanceof(parent, nativeSet)) {\n                child = new nativeSet();\n            } else if (_instanceof(parent, nativePromise)) {\n                child = new nativePromise(function(resolve, reject) {\n                    parent.then(function(value) {\n                        resolve(_clone(value, depth - 1));\n                    }, function(err) {\n                        reject(_clone(err, depth - 1));\n                    });\n                });\n            } else if (clone.__isArray(parent)) {\n                child = [];\n            } else if (clone.__isRegExp(parent)) {\n                child = new RegExp(parent.source, __getRegExpFlags(parent));\n                if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n            } else if (clone.__isDate(parent)) {\n                child = new Date(parent.getTime());\n            } else if (useBuffer && Buffer.isBuffer(parent)) {\n                if (Buffer.allocUnsafe) {\n                    // Node.js >= 4.5.0\n                    child = Buffer.allocUnsafe(parent.length);\n                } else {\n                    // Older Node.js versions\n                    child = new Buffer(parent.length);\n                }\n                parent.copy(child);\n                return child;\n            } else if (_instanceof(parent, Error)) {\n                child = Object.create(parent);\n            } else {\n                if (typeof prototype == \"undefined\") {\n                    proto = Object.getPrototypeOf(parent);\n                    child = Object.create(proto);\n                } else {\n                    child = Object.create(prototype);\n                    proto = prototype;\n                }\n            }\n            if (circular) {\n                var index = allParents.indexOf(parent);\n                if (index != -1) {\n                    return allChildren[index];\n                }\n                allParents.push(parent);\n                allChildren.push(child);\n            }\n            if (_instanceof(parent, nativeMap)) {\n                parent.forEach(function(value, key) {\n                    var keyChild = _clone(key, depth - 1);\n                    var valueChild = _clone(value, depth - 1);\n                    child.set(keyChild, valueChild);\n                });\n            }\n            if (_instanceof(parent, nativeSet)) {\n                parent.forEach(function(value) {\n                    var entryChild = _clone(value, depth - 1);\n                    child.add(entryChild);\n                });\n            }\n            for(var i in parent){\n                var attrs;\n                if (proto) {\n                    attrs = Object.getOwnPropertyDescriptor(proto, i);\n                }\n                if (attrs && attrs.set == null) {\n                    continue;\n                }\n                child[i] = _clone(parent[i], depth - 1);\n            }\n            if (Object.getOwnPropertySymbols) {\n                var symbols = Object.getOwnPropertySymbols(parent);\n                for(var i = 0; i < symbols.length; i++){\n                    // Don't need to worry about cloning a symbol because it is a primitive,\n                    // like a number or string.\n                    var symbol = symbols[i];\n                    var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n                        continue;\n                    }\n                    child[symbol] = _clone(parent[symbol], depth - 1);\n                    if (!descriptor.enumerable) {\n                        Object.defineProperty(child, symbol, {\n                            enumerable: false\n                        });\n                    }\n                }\n            }\n            if (includeNonEnumerable) {\n                var allPropertyNames = Object.getOwnPropertyNames(parent);\n                for(var i = 0; i < allPropertyNames.length; i++){\n                    var propertyName = allPropertyNames[i];\n                    var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n                    if (descriptor && descriptor.enumerable) {\n                        continue;\n                    }\n                    child[propertyName] = _clone(parent[propertyName], depth - 1);\n                    Object.defineProperty(child, propertyName, {\n                        enumerable: false\n                    });\n                }\n            }\n            return child;\n        }\n        return _clone(parent, depth);\n    }\n    /**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */ clone.clonePrototype = function clonePrototype(parent) {\n        if (parent === null) return null;\n        var c = function() {};\n        c.prototype = parent;\n        return new c();\n    };\n    // private utility functions\n    function __objToStr(o) {\n        return Object.prototype.toString.call(o);\n    }\n    clone.__objToStr = __objToStr;\n    function __isDate(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object Date]\";\n    }\n    clone.__isDate = __isDate;\n    function __isArray(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object Array]\";\n    }\n    clone.__isArray = __isArray;\n    function __isRegExp(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object RegExp]\";\n    }\n    clone.__isRegExp = __isRegExp;\n    function __getRegExpFlags(re) {\n        var flags = \"\";\n        if (re.global) flags += \"g\";\n        if (re.ignoreCase) flags += \"i\";\n        if (re.multiline) flags += \"m\";\n        return flags;\n    }\n    clone.__getRegExpFlags = __getRegExpFlags;\n    return clone;\n}();\nif ( true && module.exports) {\n    module.exports = clone;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0JBQWdCLEdBQUdBO0lBRXpCLE9BQU9qQztBQUNQO0FBRUEsSUFBSSxLQUFrQixJQUFZK0UsT0FBT0MsT0FBTyxFQUFFO0lBQ2hERCxPQUFPQyxPQUFPLEdBQUdoRjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbG9uZS9jbG9uZS5qcz8xZGM5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjbG9uZSA9IChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luc3RhbmNlb2Yob2JqLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgdHlwZTtcbn1cblxudmFyIG5hdGl2ZU1hcDtcbnRyeSB7XG4gIG5hdGl2ZU1hcCA9IE1hcDtcbn0gY2F0Y2goXykge1xuICAvLyBtYXliZSBhIHJlZmVyZW5jZSBlcnJvciBiZWNhdXNlIG5vIGBNYXBgLiBHaXZlIGl0IGEgZHVtbXkgdmFsdWUgdGhhdCBub1xuICAvLyB2YWx1ZSB3aWxsIGV2ZXIgYmUgYW4gaW5zdGFuY2VvZi5cbiAgbmF0aXZlTWFwID0gZnVuY3Rpb24oKSB7fTtcbn1cblxudmFyIG5hdGl2ZVNldDtcbnRyeSB7XG4gIG5hdGl2ZVNldCA9IFNldDtcbn0gY2F0Y2goXykge1xuICBuYXRpdmVTZXQgPSBmdW5jdGlvbigpIHt9O1xufVxuXG52YXIgbmF0aXZlUHJvbWlzZTtcbnRyeSB7XG4gIG5hdGl2ZVByb21pc2UgPSBQcm9taXNlO1xufSBjYXRjaChfKSB7XG4gIG5hdGl2ZVByb21pc2UgPSBmdW5jdGlvbigpIHt9O1xufVxuXG4vKipcbiAqIENsb25lcyAoY29waWVzKSBhbiBPYmplY3QgdXNpbmcgZGVlcCBjb3B5aW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBkZWZhdWx0LCBidXQgaWYgeW91IGFyZSBjZXJ0YWluXG4gKiB0aGVyZSBhcmUgbm8gY2lyY3VsYXIgcmVmZXJlbmNlcyBpbiB5b3VyIG9iamVjdCwgeW91IGNhbiBzYXZlIHNvbWUgQ1BVIHRpbWVcbiAqIGJ5IGNhbGxpbmcgY2xvbmUob2JqLCBmYWxzZSkuXG4gKlxuICogQ2F1dGlvbjogaWYgYGNpcmN1bGFyYCBpcyBmYWxzZSBhbmQgYHBhcmVudGAgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlcyxcbiAqIHlvdXIgcHJvZ3JhbSBtYXkgZW50ZXIgYW4gaW5maW5pdGUgbG9vcCBhbmQgY3Jhc2guXG4gKlxuICogQHBhcmFtIGBwYXJlbnRgIC0gdGhlIG9iamVjdCB0byBiZSBjbG9uZWRcbiAqIEBwYXJhbSBgY2lyY3VsYXJgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdCB0byBiZSBjbG9uZWQgbWF5IGNvbnRhaW5cbiAqICAgIGNpcmN1bGFyIHJlZmVyZW5jZXMuIChvcHRpb25hbCAtIHRydWUgYnkgZGVmYXVsdClcbiAqIEBwYXJhbSBgZGVwdGhgIC0gc2V0IHRvIGEgbnVtYmVyIGlmIHRoZSBvYmplY3QgaXMgb25seSB0byBiZSBjbG9uZWQgdG9cbiAqICAgIGEgcGFydGljdWxhciBkZXB0aC4gKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gSW5maW5pdHkpXG4gKiBAcGFyYW0gYHByb3RvdHlwZWAgLSBzZXRzIHRoZSBwcm90b3R5cGUgdG8gYmUgdXNlZCB3aGVuIGNsb25pbmcgYW4gb2JqZWN0LlxuICogICAgKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gcGFyZW50IHByb3RvdHlwZSkuXG4gKiBAcGFyYW0gYGluY2x1ZGVOb25FbnVtZXJhYmxlYCAtIHNldCB0byB0cnVlIGlmIHRoZSBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gKiAgICBzaG91bGQgYmUgY2xvbmVkIGFzIHdlbGwuIE5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgb24gdGhlIHByb3RvdHlwZVxuICogICAgY2hhaW4gd2lsbCBiZSBpZ25vcmVkLiAob3B0aW9uYWwgLSBmYWxzZSBieSBkZWZhdWx0KVxuKi9cbmZ1bmN0aW9uIGNsb25lKHBhcmVudCwgY2lyY3VsYXIsIGRlcHRoLCBwcm90b3R5cGUsIGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT09ICdvYmplY3QnKSB7XG4gICAgZGVwdGggPSBjaXJjdWxhci5kZXB0aDtcbiAgICBwcm90b3R5cGUgPSBjaXJjdWxhci5wcm90b3R5cGU7XG4gICAgaW5jbHVkZU5vbkVudW1lcmFibGUgPSBjaXJjdWxhci5pbmNsdWRlTm9uRW51bWVyYWJsZTtcbiAgICBjaXJjdWxhciA9IGNpcmN1bGFyLmNpcmN1bGFyO1xuICB9XG4gIC8vIG1haW50YWluIHR3byBhcnJheXMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHdoZXJlIGNvcnJlc3BvbmRpbmcgcGFyZW50c1xuICAvLyBhbmQgY2hpbGRyZW4gaGF2ZSB0aGUgc2FtZSBpbmRleFxuICB2YXIgYWxsUGFyZW50cyA9IFtdO1xuICB2YXIgYWxsQ2hpbGRyZW4gPSBbXTtcblxuICB2YXIgdXNlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPSAndW5kZWZpbmVkJztcblxuICBpZiAodHlwZW9mIGNpcmN1bGFyID09ICd1bmRlZmluZWQnKVxuICAgIGNpcmN1bGFyID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGRlcHRoID09ICd1bmRlZmluZWQnKVxuICAgIGRlcHRoID0gSW5maW5pdHk7XG5cbiAgLy8gcmVjdXJzZSB0aGlzIGZ1bmN0aW9uIHNvIHdlIGRvbid0IHJlc2V0IGFsbFBhcmVudHMgYW5kIGFsbENoaWxkcmVuXG4gIGZ1bmN0aW9uIF9jbG9uZShwYXJlbnQsIGRlcHRoKSB7XG4gICAgLy8gY2xvbmluZyBudWxsIGFsd2F5cyByZXR1cm5zIG51bGxcbiAgICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoZGVwdGggPT09IDApXG4gICAgICByZXR1cm4gcGFyZW50O1xuXG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBwcm90bztcbiAgICBpZiAodHlwZW9mIHBhcmVudCAhPSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVNYXAoKTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlU2V0KSkge1xuICAgICAgY2hpbGQgPSBuZXcgbmF0aXZlU2V0KCk7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVByb21pc2UpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcGFyZW50LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlKF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJlamVjdChfY2xvbmUoZXJyLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IFtdO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc1JlZ0V4cChwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBSZWdFeHAocGFyZW50LnNvdXJjZSwgX19nZXRSZWdFeHBGbGFncyhwYXJlbnQpKTtcbiAgICAgIGlmIChwYXJlbnQubGFzdEluZGV4KSBjaGlsZC5sYXN0SW5kZXggPSBwYXJlbnQubGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0RhdGUocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgRGF0ZShwYXJlbnQuZ2V0VGltZSgpKTtcbiAgICB9IGVsc2UgaWYgKHVzZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIocGFyZW50KSkge1xuICAgICAgaWYgKEJ1ZmZlci5hbGxvY1Vuc2FmZSkge1xuICAgICAgICAvLyBOb2RlLmpzID49IDQuNS4wXG4gICAgICAgIGNoaWxkID0gQnVmZmVyLmFsbG9jVW5zYWZlKHBhcmVudC5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT2xkZXIgTm9kZS5qcyB2ZXJzaW9uc1xuICAgICAgICBjaGlsZCA9IG5ldyBCdWZmZXIocGFyZW50Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBwYXJlbnQuY29weShjaGlsZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIEVycm9yKSkge1xuICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudCk7XG4gICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICAgIHByb3RvID0gcHJvdG90eXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgdmFyIGluZGV4ID0gYWxsUGFyZW50cy5pbmRleE9mKHBhcmVudCk7XG5cbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICByZXR1cm4gYWxsQ2hpbGRyZW5baW5kZXhdO1xuICAgICAgfVxuICAgICAgYWxsUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICBhbGxDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBrZXlDaGlsZCA9IF9jbG9uZShrZXksIGRlcHRoIC0gMSk7XG4gICAgICAgIHZhciB2YWx1ZUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuICAgICAgICBjaGlsZC5zZXQoa2V5Q2hpbGQsIHZhbHVlQ2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVNldCkpIHtcbiAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBlbnRyeUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuICAgICAgICBjaGlsZC5hZGQoZW50cnlDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIHBhcmVudCkge1xuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgIGF0dHJzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRycyAmJiBhdHRycy5zZXQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkW2ldID0gX2Nsb25lKHBhcmVudFtpXSwgZGVwdGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHBhcmVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBjbG9uaW5nIGEgc3ltYm9sIGJlY2F1c2UgaXQgaXMgYSBwcmltaXRpdmUsXG4gICAgICAgIC8vIGxpa2UgYSBudW1iZXIgb3Igc3RyaW5nLlxuICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc1tpXTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgc3ltYm9sKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZW51bWVyYWJsZSAmJiAhaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZFtzeW1ib2xdID0gX2Nsb25lKHBhcmVudFtzeW1ib2xdLCBkZXB0aCAtIDEpO1xuICAgICAgICBpZiAoIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgc3ltYm9sLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgICB2YXIgYWxsUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcmVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IGFsbFByb3BlcnR5TmFtZXNbaV07XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkW3Byb3BlcnR5TmFtZV0gPSBfY2xvbmUocGFyZW50W3Byb3BlcnR5TmFtZV0sIGRlcHRoIC0gMSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIF9jbG9uZShwYXJlbnQsIGRlcHRoKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgZmxhdCBjbG9uZSB1c2luZyBwcm90b3R5cGUsIGFjY2VwdHMgb25seSBvYmplY3RzLCB1c2VmdWxsIGZvciBwcm9wZXJ0eVxuICogb3ZlcnJpZGUgb24gRkxBVCBjb25maWd1cmF0aW9uIG9iamVjdCAobm8gbmVzdGVkIHByb3BzKS5cbiAqXG4gKiBVU0UgV0lUSCBDQVVUSU9OISBUaGlzIG1heSBub3QgYmVoYXZlIGFzIHlvdSB3aXNoIGlmIHlvdSBkbyBub3Qga25vdyBob3cgdGhpc1xuICogd29ya3MuXG4gKi9cbmNsb25lLmNsb25lUHJvdG90eXBlID0gZnVuY3Rpb24gY2xvbmVQcm90b3R5cGUocGFyZW50KSB7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgYy5wcm90b3R5cGUgPSBwYXJlbnQ7XG4gIHJldHVybiBuZXcgYygpO1xufTtcblxuLy8gcHJpdmF0ZSB1dGlsaXR5IGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBfX29ialRvU3RyKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbmNsb25lLl9fb2JqVG9TdHIgPSBfX29ialRvU3RyO1xuXG5mdW5jdGlvbiBfX2lzRGF0ZShvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuY2xvbmUuX19pc0RhdGUgPSBfX2lzRGF0ZTtcblxuZnVuY3Rpb24gX19pc0FycmF5KG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuY2xvbmUuX19pc0FycmF5ID0gX19pc0FycmF5O1xuXG5mdW5jdGlvbiBfX2lzUmVnRXhwKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmNsb25lLl9faXNSZWdFeHAgPSBfX2lzUmVnRXhwO1xuXG5mdW5jdGlvbiBfX2dldFJlZ0V4cEZsYWdzKHJlKSB7XG4gIHZhciBmbGFncyA9ICcnO1xuICBpZiAocmUuZ2xvYmFsKSBmbGFncyArPSAnZyc7XG4gIGlmIChyZS5pZ25vcmVDYXNlKSBmbGFncyArPSAnaSc7XG4gIGlmIChyZS5tdWx0aWxpbmUpIGZsYWdzICs9ICdtJztcbiAgcmV0dXJuIGZsYWdzO1xufVxuY2xvbmUuX19nZXRSZWdFeHBGbGFncyA9IF9fZ2V0UmVnRXhwRmxhZ3M7XG5cbnJldHVybiBjbG9uZTtcbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xufVxuIl0sIm5hbWVzIjpbImNsb25lIiwiX2luc3RhbmNlb2YiLCJvYmoiLCJ0eXBlIiwibmF0aXZlTWFwIiwiTWFwIiwiXyIsIm5hdGl2ZVNldCIsIlNldCIsIm5hdGl2ZVByb21pc2UiLCJQcm9taXNlIiwicGFyZW50IiwiY2lyY3VsYXIiLCJkZXB0aCIsInByb3RvdHlwZSIsImluY2x1ZGVOb25FbnVtZXJhYmxlIiwiYWxsUGFyZW50cyIsImFsbENoaWxkcmVuIiwidXNlQnVmZmVyIiwiQnVmZmVyIiwiSW5maW5pdHkiLCJfY2xvbmUiLCJjaGlsZCIsInByb3RvIiwicmVzb2x2ZSIsInJlamVjdCIsInRoZW4iLCJ2YWx1ZSIsImVyciIsIl9faXNBcnJheSIsIl9faXNSZWdFeHAiLCJSZWdFeHAiLCJzb3VyY2UiLCJfX2dldFJlZ0V4cEZsYWdzIiwibGFzdEluZGV4IiwiX19pc0RhdGUiLCJEYXRlIiwiZ2V0VGltZSIsImlzQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJsZW5ndGgiLCJjb3B5IiwiRXJyb3IiLCJPYmplY3QiLCJjcmVhdGUiLCJnZXRQcm90b3R5cGVPZiIsImluZGV4IiwiaW5kZXhPZiIsInB1c2giLCJmb3JFYWNoIiwia2V5Iiwia2V5Q2hpbGQiLCJ2YWx1ZUNoaWxkIiwic2V0IiwiZW50cnlDaGlsZCIsImFkZCIsImkiLCJhdHRycyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJzeW1ib2wiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5IiwiYWxsUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eU5hbWUiLCJjbG9uZVByb3RvdHlwZSIsImMiLCJfX29ialRvU3RyIiwibyIsInRvU3RyaW5nIiwiY2FsbCIsInJlIiwiZmxhZ3MiLCJnbG9iYWwiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/clone/clone.js\n");

/***/ })

};
;