/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/clone";
exports.ids = ["vendor-chunks/clone"];
exports.modules = {

/***/ "(ssr)/./node_modules/clone/clone.js":
/*!*************************************!*\
  !*** ./node_modules/clone/clone.js ***!
  \*************************************/
/***/ ((module) => {

eval("var clone = function() {\n    \"use strict\";\n    function _instanceof(obj, type) {\n        return type != null && obj instanceof type;\n    }\n    var nativeMap;\n    try {\n        nativeMap = Map;\n    } catch (_) {\n        // maybe a reference error because no `Map`. Give it a dummy value that no\n        // value will ever be an instanceof.\n        nativeMap = function() {};\n    }\n    var nativeSet;\n    try {\n        nativeSet = Set;\n    } catch (_) {\n        nativeSet = function() {};\n    }\n    var nativePromise;\n    try {\n        nativePromise = Promise;\n    } catch (_) {\n        nativePromise = function() {};\n    }\n    /**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/ function clone(parent, circular, depth, prototype, includeNonEnumerable) {\n        if (typeof circular === \"object\") {\n            depth = circular.depth;\n            prototype = circular.prototype;\n            includeNonEnumerable = circular.includeNonEnumerable;\n            circular = circular.circular;\n        }\n        // maintain two arrays for circular references, where corresponding parents\n        // and children have the same index\n        var allParents = [];\n        var allChildren = [];\n        var useBuffer = typeof Buffer != \"undefined\";\n        if (typeof circular == \"undefined\") circular = true;\n        if (typeof depth == \"undefined\") depth = Infinity;\n        // recurse this function so we don't reset allParents and allChildren\n        function _clone(parent, depth) {\n            // cloning null always returns null\n            if (parent === null) return null;\n            if (depth === 0) return parent;\n            var child;\n            var proto;\n            if (typeof parent != \"object\") {\n                return parent;\n            }\n            if (_instanceof(parent, nativeMap)) {\n                child = new nativeMap();\n            } else if (_instanceof(parent, nativeSet)) {\n                child = new nativeSet();\n            } else if (_instanceof(parent, nativePromise)) {\n                child = new nativePromise(function(resolve, reject) {\n                    parent.then(function(value) {\n                        resolve(_clone(value, depth - 1));\n                    }, function(err) {\n                        reject(_clone(err, depth - 1));\n                    });\n                });\n            } else if (clone.__isArray(parent)) {\n                child = [];\n            } else if (clone.__isRegExp(parent)) {\n                child = new RegExp(parent.source, __getRegExpFlags(parent));\n                if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n            } else if (clone.__isDate(parent)) {\n                child = new Date(parent.getTime());\n            } else if (useBuffer && Buffer.isBuffer(parent)) {\n                if (Buffer.allocUnsafe) {\n                    // Node.js >= 4.5.0\n                    child = Buffer.allocUnsafe(parent.length);\n                } else {\n                    // Older Node.js versions\n                    child = new Buffer(parent.length);\n                }\n                parent.copy(child);\n                return child;\n            } else if (_instanceof(parent, Error)) {\n                child = Object.create(parent);\n            } else {\n                if (typeof prototype == \"undefined\") {\n                    proto = Object.getPrototypeOf(parent);\n                    child = Object.create(proto);\n                } else {\n                    child = Object.create(prototype);\n                    proto = prototype;\n                }\n            }\n            if (circular) {\n                var index = allParents.indexOf(parent);\n                if (index != -1) {\n                    return allChildren[index];\n                }\n                allParents.push(parent);\n                allChildren.push(child);\n            }\n            if (_instanceof(parent, nativeMap)) {\n                parent.forEach(function(value, key) {\n                    var keyChild = _clone(key, depth - 1);\n                    var valueChild = _clone(value, depth - 1);\n                    child.set(keyChild, valueChild);\n                });\n            }\n            if (_instanceof(parent, nativeSet)) {\n                parent.forEach(function(value) {\n                    var entryChild = _clone(value, depth - 1);\n                    child.add(entryChild);\n                });\n            }\n            for(var i in parent){\n                var attrs;\n                if (proto) {\n                    attrs = Object.getOwnPropertyDescriptor(proto, i);\n                }\n                if (attrs && attrs.set == null) {\n                    continue;\n                }\n                child[i] = _clone(parent[i], depth - 1);\n            }\n            if (Object.getOwnPropertySymbols) {\n                var symbols = Object.getOwnPropertySymbols(parent);\n                for(var i = 0; i < symbols.length; i++){\n                    // Don't need to worry about cloning a symbol because it is a primitive,\n                    // like a number or string.\n                    var symbol = symbols[i];\n                    var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n                        continue;\n                    }\n                    child[symbol] = _clone(parent[symbol], depth - 1);\n                    if (!descriptor.enumerable) {\n                        Object.defineProperty(child, symbol, {\n                            enumerable: false\n                        });\n                    }\n                }\n            }\n            if (includeNonEnumerable) {\n                var allPropertyNames = Object.getOwnPropertyNames(parent);\n                for(var i = 0; i < allPropertyNames.length; i++){\n                    var propertyName = allPropertyNames[i];\n                    var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n                    if (descriptor && descriptor.enumerable) {\n                        continue;\n                    }\n                    child[propertyName] = _clone(parent[propertyName], depth - 1);\n                    Object.defineProperty(child, propertyName, {\n                        enumerable: false\n                    });\n                }\n            }\n            return child;\n        }\n        return _clone(parent, depth);\n    }\n    /**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */ clone.clonePrototype = function clonePrototype(parent) {\n        if (parent === null) return null;\n        var c = function() {};\n        c.prototype = parent;\n        return new c();\n    };\n    // private utility functions\n    function __objToStr(o) {\n        return Object.prototype.toString.call(o);\n    }\n    clone.__objToStr = __objToStr;\n    function __isDate(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object Date]\";\n    }\n    clone.__isDate = __isDate;\n    function __isArray(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object Array]\";\n    }\n    clone.__isArray = __isArray;\n    function __isRegExp(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object RegExp]\";\n    }\n    clone.__isRegExp = __isRegExp;\n    function __getRegExpFlags(re) {\n        var flags = \"\";\n        if (re.global) flags += \"g\";\n        if (re.ignoreCase) flags += \"i\";\n        if (re.multiline) flags += \"m\";\n        return flags;\n    }\n    clone.__getRegExpFlags = __getRegExpFlags;\n    return clone;\n}();\nif ( true && module.exports) {\n    module.exports = clone;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBZ0IsR0FBR0E7SUFFekIsT0FBT2pDO0FBQ1A7QUFFQSxJQUFJLEtBQWtCLElBQVkrRSxPQUFPQyxPQUFPLEVBQUU7SUFDaERELE9BQU9DLE9BQU8sR0FBR2hGO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nsb25lL2Nsb25lLmpzPzFkYzkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNsb25lID0gKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5zdGFuY2VvZihvYmosIHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUgIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiB0eXBlO1xufVxuXG52YXIgbmF0aXZlTWFwO1xudHJ5IHtcbiAgbmF0aXZlTWFwID0gTWFwO1xufSBjYXRjaChfKSB7XG4gIC8vIG1heWJlIGEgcmVmZXJlbmNlIGVycm9yIGJlY2F1c2Ugbm8gYE1hcGAuIEdpdmUgaXQgYSBkdW1teSB2YWx1ZSB0aGF0IG5vXG4gIC8vIHZhbHVlIHdpbGwgZXZlciBiZSBhbiBpbnN0YW5jZW9mLlxuICBuYXRpdmVNYXAgPSBmdW5jdGlvbigpIHt9O1xufVxuXG52YXIgbmF0aXZlU2V0O1xudHJ5IHtcbiAgbmF0aXZlU2V0ID0gU2V0O1xufSBjYXRjaChfKSB7XG4gIG5hdGl2ZVNldCA9IGZ1bmN0aW9uKCkge307XG59XG5cbnZhciBuYXRpdmVQcm9taXNlO1xudHJ5IHtcbiAgbmF0aXZlUHJvbWlzZSA9IFByb21pc2U7XG59IGNhdGNoKF8pIHtcbiAgbmF0aXZlUHJvbWlzZSA9IGZ1bmN0aW9uKCkge307XG59XG5cbi8qKlxuICogQ2xvbmVzIChjb3BpZXMpIGFuIE9iamVjdCB1c2luZyBkZWVwIGNvcHlpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGRlZmF1bHQsIGJ1dCBpZiB5b3UgYXJlIGNlcnRhaW5cbiAqIHRoZXJlIGFyZSBubyBjaXJjdWxhciByZWZlcmVuY2VzIGluIHlvdXIgb2JqZWN0LCB5b3UgY2FuIHNhdmUgc29tZSBDUFUgdGltZVxuICogYnkgY2FsbGluZyBjbG9uZShvYmosIGZhbHNlKS5cbiAqXG4gKiBDYXV0aW9uOiBpZiBgY2lyY3VsYXJgIGlzIGZhbHNlIGFuZCBgcGFyZW50YCBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzLFxuICogeW91ciBwcm9ncmFtIG1heSBlbnRlciBhbiBpbmZpbml0ZSBsb29wIGFuZCBjcmFzaC5cbiAqXG4gKiBAcGFyYW0gYHBhcmVudGAgLSB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxuICogQHBhcmFtIGBjaXJjdWxhcmAgLSBzZXQgdG8gdHJ1ZSBpZiB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZCBtYXkgY29udGFpblxuICogICAgY2lyY3VsYXIgcmVmZXJlbmNlcy4gKG9wdGlvbmFsIC0gdHJ1ZSBieSBkZWZhdWx0KVxuICogQHBhcmFtIGBkZXB0aGAgLSBzZXQgdG8gYSBudW1iZXIgaWYgdGhlIG9iamVjdCBpcyBvbmx5IHRvIGJlIGNsb25lZCB0b1xuICogICAgYSBwYXJ0aWN1bGFyIGRlcHRoLiAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBJbmZpbml0eSlcbiAqIEBwYXJhbSBgcHJvdG90eXBlYCAtIHNldHMgdGhlIHByb3RvdHlwZSB0byBiZSB1c2VkIHdoZW4gY2xvbmluZyBhbiBvYmplY3QuXG4gKiAgICAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBwYXJlbnQgcHJvdG90eXBlKS5cbiAqIEBwYXJhbSBgaW5jbHVkZU5vbkVudW1lcmFibGVgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAqICAgIHNob3VsZCBiZSBjbG9uZWQgYXMgd2VsbC4gTm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBvbiB0aGUgcHJvdG90eXBlXG4gKiAgICBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuIChvcHRpb25hbCAtIGZhbHNlIGJ5IGRlZmF1bHQpXG4qL1xuZnVuY3Rpb24gY2xvbmUocGFyZW50LCBjaXJjdWxhciwgZGVwdGgsIHByb3RvdHlwZSwgaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PT0gJ29iamVjdCcpIHtcbiAgICBkZXB0aCA9IGNpcmN1bGFyLmRlcHRoO1xuICAgIHByb3RvdHlwZSA9IGNpcmN1bGFyLnByb3RvdHlwZTtcbiAgICBpbmNsdWRlTm9uRW51bWVyYWJsZSA9IGNpcmN1bGFyLmluY2x1ZGVOb25FbnVtZXJhYmxlO1xuICAgIGNpcmN1bGFyID0gY2lyY3VsYXIuY2lyY3VsYXI7XG4gIH1cbiAgLy8gbWFpbnRhaW4gdHdvIGFycmF5cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcywgd2hlcmUgY29ycmVzcG9uZGluZyBwYXJlbnRzXG4gIC8vIGFuZCBjaGlsZHJlbiBoYXZlIHRoZSBzYW1lIGluZGV4XG4gIHZhciBhbGxQYXJlbnRzID0gW107XG4gIHZhciBhbGxDaGlsZHJlbiA9IFtdO1xuXG4gIHZhciB1c2VCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9ICd1bmRlZmluZWQnO1xuXG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT0gJ3VuZGVmaW5lZCcpXG4gICAgY2lyY3VsYXIgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZGVwdGggPT0gJ3VuZGVmaW5lZCcpXG4gICAgZGVwdGggPSBJbmZpbml0eTtcblxuICAvLyByZWN1cnNlIHRoaXMgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzZXQgYWxsUGFyZW50cyBhbmQgYWxsQ2hpbGRyZW5cbiAgZnVuY3Rpb24gX2Nsb25lKHBhcmVudCwgZGVwdGgpIHtcbiAgICAvLyBjbG9uaW5nIG51bGwgYWx3YXlzIHJldHVybnMgbnVsbFxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGlmIChkZXB0aCA9PT0gMClcbiAgICAgIHJldHVybiBwYXJlbnQ7XG5cbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIHByb3RvO1xuICAgIGlmICh0eXBlb2YgcGFyZW50ICE9ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZU1hcCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZU1hcCgpO1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVTZXQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVTZXQoKTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlUHJvbWlzZSkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwYXJlbnQudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJlc29sdmUoX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KF9jbG9uZShlcnIsIGRlcHRoIC0gMSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gW107XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzUmVnRXhwKHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IFJlZ0V4cChwYXJlbnQuc291cmNlLCBfX2dldFJlZ0V4cEZsYWdzKHBhcmVudCkpO1xuICAgICAgaWYgKHBhcmVudC5sYXN0SW5kZXgpIGNoaWxkLmxhc3RJbmRleCA9IHBhcmVudC5sYXN0SW5kZXg7XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzRGF0ZShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBEYXRlKHBhcmVudC5nZXRUaW1lKCkpO1xuICAgIH0gZWxzZSBpZiAodXNlQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihwYXJlbnQpKSB7XG4gICAgICBpZiAoQnVmZmVyLmFsbG9jVW5zYWZlKSB7XG4gICAgICAgIC8vIE5vZGUuanMgPj0gNC41LjBcbiAgICAgICAgY2hpbGQgPSBCdWZmZXIuYWxsb2NVbnNhZmUocGFyZW50Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbGRlciBOb2RlLmpzIHZlcnNpb25zXG4gICAgICAgIGNoaWxkID0gbmV3IEJ1ZmZlcihwYXJlbnQubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5jb3B5KGNoaWxkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgRXJyb3IpKSB7XG4gICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcbiAgICAgICAgcHJvdG8gPSBwcm90b3R5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICB2YXIgaW5kZXggPSBhbGxQYXJlbnRzLmluZGV4T2YocGFyZW50KTtcblxuICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgIHJldHVybiBhbGxDaGlsZHJlbltpbmRleF07XG4gICAgICB9XG4gICAgICBhbGxQYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIGFsbENoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZU1hcCkpIHtcbiAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIGtleUNoaWxkID0gX2Nsb25lKGtleSwgZGVwdGggLSAxKTtcbiAgICAgICAgdmFyIHZhbHVlQ2hpbGQgPSBfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSk7XG4gICAgICAgIGNoaWxkLnNldChrZXlDaGlsZCwgdmFsdWVDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlU2V0KSkge1xuICAgICAgcGFyZW50LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGVudHJ5Q2hpbGQgPSBfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSk7XG4gICAgICAgIGNoaWxkLmFkZChlbnRyeUNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gcGFyZW50KSB7XG4gICAgICB2YXIgYXR0cnM7XG4gICAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgYXR0cnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJzICYmIGF0dHJzLnNldCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2hpbGRbaV0gPSBfY2xvbmUocGFyZW50W2ldLCBkZXB0aCAtIDEpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocGFyZW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBEb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IGNsb25pbmcgYSBzeW1ib2wgYmVjYXVzZSBpdCBpcyBhIHByaW1pdGl2ZSxcbiAgICAgICAgLy8gbGlrZSBhIG51bWJlciBvciBzdHJpbmcuXG4gICAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xzW2ldO1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBzeW1ib2wpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5lbnVtZXJhYmxlICYmICFpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkW3N5bWJvbF0gPSBfY2xvbmUocGFyZW50W3N5bWJvbF0sIGRlcHRoIC0gMSk7XG4gICAgICAgIGlmICghZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBzeW1ib2wsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgIHZhciBhbGxQcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyZW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsUHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gYWxsUHJvcGVydHlOYW1lc1tpXTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRbcHJvcGVydHlOYW1lXSA9IF9jbG9uZShwYXJlbnRbcHJvcGVydHlOYW1lXSwgZGVwdGggLSAxKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICByZXR1cm4gX2Nsb25lKHBhcmVudCwgZGVwdGgpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBmbGF0IGNsb25lIHVzaW5nIHByb3RvdHlwZSwgYWNjZXB0cyBvbmx5IG9iamVjdHMsIHVzZWZ1bGwgZm9yIHByb3BlcnR5XG4gKiBvdmVycmlkZSBvbiBGTEFUIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChubyBuZXN0ZWQgcHJvcHMpLlxuICpcbiAqIFVTRSBXSVRIIENBVVRJT04hIFRoaXMgbWF5IG5vdCBiZWhhdmUgYXMgeW91IHdpc2ggaWYgeW91IGRvIG5vdCBrbm93IGhvdyB0aGlzXG4gKiB3b3Jrcy5cbiAqL1xuY2xvbmUuY2xvbmVQcm90b3R5cGUgPSBmdW5jdGlvbiBjbG9uZVByb3RvdHlwZShwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgYyA9IGZ1bmN0aW9uICgpIHt9O1xuICBjLnByb3RvdHlwZSA9IHBhcmVudDtcbiAgcmV0dXJuIG5ldyBjKCk7XG59O1xuXG4vLyBwcml2YXRlIHV0aWxpdHkgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIF9fb2JqVG9TdHIobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuY2xvbmUuX19vYmpUb1N0ciA9IF9fb2JqVG9TdHI7XG5cbmZ1bmN0aW9uIF9faXNEYXRlKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5jbG9uZS5fX2lzRGF0ZSA9IF9faXNEYXRlO1xuXG5mdW5jdGlvbiBfX2lzQXJyYXkobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5jbG9uZS5fX2lzQXJyYXkgPSBfX2lzQXJyYXk7XG5cbmZ1bmN0aW9uIF9faXNSZWdFeHAobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuY2xvbmUuX19pc1JlZ0V4cCA9IF9faXNSZWdFeHA7XG5cbmZ1bmN0aW9uIF9fZ2V0UmVnRXhwRmxhZ3MocmUpIHtcbiAgdmFyIGZsYWdzID0gJyc7XG4gIGlmIChyZS5nbG9iYWwpIGZsYWdzICs9ICdnJztcbiAgaWYgKHJlLmlnbm9yZUNhc2UpIGZsYWdzICs9ICdpJztcbiAgaWYgKHJlLm11bHRpbGluZSkgZmxhZ3MgKz0gJ20nO1xuICByZXR1cm4gZmxhZ3M7XG59XG5jbG9uZS5fX2dldFJlZ0V4cEZsYWdzID0gX19nZXRSZWdFeHBGbGFncztcblxucmV0dXJuIGNsb25lO1xufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG59XG4iXSwibmFtZXMiOlsiY2xvbmUiLCJfaW5zdGFuY2VvZiIsIm9iaiIsInR5cGUiLCJuYXRpdmVNYXAiLCJNYXAiLCJfIiwibmF0aXZlU2V0IiwiU2V0IiwibmF0aXZlUHJvbWlzZSIsIlByb21pc2UiLCJwYXJlbnQiLCJjaXJjdWxhciIsImRlcHRoIiwicHJvdG90eXBlIiwiaW5jbHVkZU5vbkVudW1lcmFibGUiLCJhbGxQYXJlbnRzIiwiYWxsQ2hpbGRyZW4iLCJ1c2VCdWZmZXIiLCJCdWZmZXIiLCJJbmZpbml0eSIsIl9jbG9uZSIsImNoaWxkIiwicHJvdG8iLCJyZXNvbHZlIiwicmVqZWN0IiwidGhlbiIsInZhbHVlIiwiZXJyIiwiX19pc0FycmF5IiwiX19pc1JlZ0V4cCIsIlJlZ0V4cCIsInNvdXJjZSIsIl9fZ2V0UmVnRXhwRmxhZ3MiLCJsYXN0SW5kZXgiLCJfX2lzRGF0ZSIsIkRhdGUiLCJnZXRUaW1lIiwiaXNCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImxlbmd0aCIsImNvcHkiLCJFcnJvciIsIk9iamVjdCIsImNyZWF0ZSIsImdldFByb3RvdHlwZU9mIiwiaW5kZXgiLCJpbmRleE9mIiwicHVzaCIsImZvckVhY2giLCJrZXkiLCJrZXlDaGlsZCIsInZhbHVlQ2hpbGQiLCJzZXQiLCJlbnRyeUNoaWxkIiwiYWRkIiwiaSIsImF0dHJzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsInN5bWJvbCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJhbGxQcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInByb3BlcnR5TmFtZSIsImNsb25lUHJvdG90eXBlIiwiYyIsIl9fb2JqVG9TdHIiLCJvIiwidG9TdHJpbmciLCJjYWxsIiwicmUiLCJmbGFncyIsImdsb2JhbCIsImlnbm9yZUNhc2UiLCJtdWx0aWxpbmUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/clone/clone.js\n");

/***/ })

};
;