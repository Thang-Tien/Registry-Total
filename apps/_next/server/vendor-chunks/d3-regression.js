"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/d3-regression";
exports.ids = ["vendor-chunks/d3-regression"];
exports.modules = {

/***/ "(ssr)/./node_modules/d3-regression/dist/d3-regression.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-regression/dist/d3-regression.esm.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   regressionExp: () => (/* binding */ exponential),\n/* harmony export */   regressionLinear: () => (/* binding */ linear),\n/* harmony export */   regressionLoess: () => (/* binding */ loess),\n/* harmony export */   regressionLog: () => (/* binding */ logarithmic),\n/* harmony export */   regressionPoly: () => (/* binding */ polynomial),\n/* harmony export */   regressionPow: () => (/* binding */ power),\n/* harmony export */   regressionQuad: () => (/* binding */ quad)\n/* harmony export */ });\n// https://github.com/HarryStevens/d3-regression#readme Version 1.3.10. Copyright 2022 Harry Stevens.\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n// Adapted from vega-statistics by Jeffrey Heer\n// License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE\n// Source: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/packages/vega-statistics/src/regression/points.js\nfunction points(data, x, y, sort) {\n    data = data.filter(function(d, i) {\n        var u = x(d, i), v = y(d, i);\n        return u != null && isFinite(u) && v != null && isFinite(v);\n    });\n    if (sort) {\n        data.sort(function(a, b) {\n            return x(a) - x(b);\n        });\n    }\n    var n = data.length, X = new Float64Array(n), Y = new Float64Array(n); // extract values, calculate means\n    var ux = 0, uy = 0, xv, yv, d;\n    for(var i = 0; i < n;){\n        d = data[i];\n        X[i] = xv = +x(d, i, data);\n        Y[i] = yv = +y(d, i, data);\n        ++i;\n        ux += (xv - ux) / i;\n        uy += (yv - uy) / i;\n    } // mean center the data\n    for(var _i = 0; _i < n; ++_i){\n        X[_i] -= ux;\n        Y[_i] -= uy;\n    }\n    return [\n        X,\n        Y,\n        ux,\n        uy\n    ];\n}\nfunction visitPoints(data, x, y, cb) {\n    var iterations = 0;\n    for(var i = 0, n = data.length; i < n; i++){\n        var d = data[i], dx = +x(d, i, data), dy = +y(d, i, data);\n        if (dx != null && isFinite(dx) && dy != null && isFinite(dy)) {\n            cb(dx, dy, iterations++);\n        }\n    }\n}\n// return the coefficient of determination, or R squared.\nfunction determination(data, x, y, uY, predict) {\n    var SSE = 0, SST = 0;\n    visitPoints(data, x, y, function(dx, dy) {\n        var sse = dy - predict(dx), sst = dy - uY;\n        SSE += sse * sse;\n        SST += sst * sst;\n    });\n    return 1 - SSE / SST;\n}\n// Returns the angle of a line in degrees.\nfunction angle(line) {\n    return Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]) * 180 / Math.PI;\n} // Returns the midpoint of a line.\nfunction midpoint(line) {\n    return [\n        (line[0][0] + line[1][0]) / 2,\n        (line[0][1] + line[1][1]) / 2\n    ];\n}\n// returns a smooth line.\nfunction interpose(xmin, xmax, predict) {\n    var l = Math.log(xmax - xmin) * Math.LOG10E + 1 | 0;\n    var precision = 1 * Math.pow(10, -l / 2 - 1), maxIter = 1e4;\n    var points = [\n        px(xmin),\n        px(xmax)\n    ], iter = 0;\n    while(find(points) && iter < maxIter){}\n    return points;\n    function px(x) {\n        return [\n            x,\n            predict(x)\n        ];\n    }\n    function find(points) {\n        iter++;\n        var n = points.length;\n        var found = false;\n        for(var i = 0; i < n - 1; i++){\n            var p0 = points[i], p1 = points[i + 1], m = midpoint([\n                p0,\n                p1\n            ]), mp = px(m[0]), a0 = angle([\n                p0,\n                m\n            ]), a1 = angle([\n                p0,\n                mp\n            ]), a = Math.abs(a0 - a1);\n            if (a > precision) {\n                points.splice(i + 1, 0, mp);\n                found = true;\n            }\n        }\n        return found;\n    }\n}\n// Ordinary Least Squares from vega-statistics by Jeffrey Heer\n// License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE\n// Source: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/packages/vega-statistics/src/regression/ols.js\nfunction ols(uX, uY, uXY, uX2) {\n    var delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;\n    return [\n        intercept,\n        slope\n    ];\n}\nfunction exponential() {\n    var x = function x(d) {\n        return d[0];\n    }, y = function y(d) {\n        return d[1];\n    }, domain;\n    function exponential(data) {\n        var n = 0, Y = 0, YL = 0, XY = 0, XYL = 0, X2Y = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;\n        visitPoints(data, x, y, function(dx, dy) {\n            var ly = Math.log(dy), xy = dx * dy;\n            ++n;\n            Y += (dy - Y) / n;\n            XY += (xy - XY) / n;\n            X2Y += (dx * xy - X2Y) / n;\n            YL += (dy * ly - YL) / n;\n            XYL += (xy * ly - XYL) / n;\n            if (!domain) {\n                if (dx < xmin) xmin = dx;\n                if (dx > xmax) xmax = dx;\n            }\n        });\n        var _ols = ols(XY / Y, YL / Y, XYL / Y, X2Y / Y), _ols2 = _slicedToArray(_ols, 2), a = _ols2[0], b = _ols2[1];\n        a = Math.exp(a);\n        var fn = function fn(x) {\n            return a * Math.exp(b * x);\n        }, out = interpose(xmin, xmax, fn);\n        out.a = a;\n        out.b = b;\n        out.predict = fn;\n        out.rSquared = determination(data, x, y, Y, fn);\n        return out;\n    }\n    exponential.domain = function(arr) {\n        return arguments.length ? (domain = arr, exponential) : domain;\n    };\n    exponential.x = function(fn) {\n        return arguments.length ? (x = fn, exponential) : x;\n    };\n    exponential.y = function(fn) {\n        return arguments.length ? (y = fn, exponential) : y;\n    };\n    return exponential;\n}\nfunction linear() {\n    var x = function x(d) {\n        return d[0];\n    }, y = function y(d) {\n        return d[1];\n    }, domain;\n    function linear(data) {\n        var n = 0, X = 0, // sum of x\n        Y = 0, // sum of y\n        XY = 0, // sum of x * y\n        X2 = 0, // sum of x * x\n        xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;\n        visitPoints(data, x, y, function(dx, dy) {\n            ++n;\n            X += (dx - X) / n;\n            Y += (dy - Y) / n;\n            XY += (dx * dy - XY) / n;\n            X2 += (dx * dx - X2) / n;\n            if (!domain) {\n                if (dx < xmin) xmin = dx;\n                if (dx > xmax) xmax = dx;\n            }\n        });\n        var _ols = ols(X, Y, XY, X2), _ols2 = _slicedToArray(_ols, 2), intercept = _ols2[0], slope = _ols2[1], fn = function fn(x) {\n            return slope * x + intercept;\n        }, out = [\n            [\n                xmin,\n                fn(xmin)\n            ],\n            [\n                xmax,\n                fn(xmax)\n            ]\n        ];\n        out.a = slope;\n        out.b = intercept;\n        out.predict = fn;\n        out.rSquared = determination(data, x, y, Y, fn);\n        return out;\n    }\n    linear.domain = function(arr) {\n        return arguments.length ? (domain = arr, linear) : domain;\n    };\n    linear.x = function(fn) {\n        return arguments.length ? (x = fn, linear) : x;\n    };\n    linear.y = function(fn) {\n        return arguments.length ? (y = fn, linear) : y;\n    };\n    return linear;\n}\n// Returns the medium value of an array of numbers.\nfunction median(arr) {\n    arr.sort(function(a, b) {\n        return a - b;\n    });\n    var i = arr.length / 2;\n    return i % 1 === 0 ? (arr[i - 1] + arr[i]) / 2 : arr[Math.floor(i)];\n}\nvar maxiters = 2, epsilon = 1e-12;\nfunction loess() {\n    var x = function x(d) {\n        return d[0];\n    }, y = function y(d) {\n        return d[1];\n    }, bandwidth = .3;\n    function loess(data) {\n        var _points = points(data, x, y, true), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n = xv.length, bw = Math.max(2, ~~(bandwidth * n)), yhat = new Float64Array(n), residuals = new Float64Array(n), robustWeights = new Float64Array(n).fill(1);\n        for(var iter = -1; ++iter <= maxiters;){\n            var interval = [\n                0,\n                bw - 1\n            ];\n            for(var i = 0; i < n; ++i){\n                var dx = xv[i], i0 = interval[0], i1 = interval[1], edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;\n                var W = 0, X = 0, Y = 0, XY = 0, X2 = 0, denom = 1 / Math.abs(xv[edge] - dx || 1); // Avoid singularity\n                for(var k = i0; k <= i1; ++k){\n                    var xk = xv[k], yk = yv[k], w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k], xkw = xk * w;\n                    W += w;\n                    X += xkw;\n                    Y += yk * w;\n                    XY += yk * xkw;\n                    X2 += xk * xkw;\n                } // Linear regression fit\n                var _ols = ols(X / W, Y / W, XY / W, X2 / W), _ols2 = _slicedToArray(_ols, 2), a = _ols2[0], b = _ols2[1];\n                yhat[i] = a + b * dx;\n                residuals[i] = Math.abs(yv[i] - yhat[i]);\n                updateInterval(xv, i + 1, interval);\n            }\n            if (iter === maxiters) {\n                break;\n            }\n            var medianResidual = median(residuals);\n            if (Math.abs(medianResidual) < epsilon) break;\n            for(var _i = 0, arg, _w; _i < n; ++_i){\n                arg = residuals[_i] / (6 * medianResidual); // Default to epsilon (rather than zero) for large deviations\n                // Keeping weights tiny but non-zero prevents singularites\n                robustWeights[_i] = arg >= 1 ? epsilon : (_w = 1 - arg * arg) * _w;\n            }\n        }\n        return output(xv, yhat, ux, uy);\n    }\n    loess.bandwidth = function(bw) {\n        return arguments.length ? (bandwidth = bw, loess) : bandwidth;\n    };\n    loess.x = function(fn) {\n        return arguments.length ? (x = fn, loess) : x;\n    };\n    loess.y = function(fn) {\n        return arguments.length ? (y = fn, loess) : y;\n    };\n    return loess;\n} // Weighting kernel for local regression\nfunction tricube(x) {\n    return (x = 1 - x * x * x) * x * x;\n} // Advance sliding window interval of nearest neighbors\nfunction updateInterval(xv, i, interval) {\n    var val = xv[i], left = interval[0], right = interval[1] + 1;\n    if (right >= xv.length) return; // Step right if distance to new right edge is <= distance to old left edge\n    // Step when distance is equal to ensure movement over duplicate x values\n    while(i > left && xv[right] - val <= val - xv[left]){\n        interval[0] = ++left;\n        interval[1] = right;\n        ++right;\n    }\n} // Generate smoothed output points\n// Average points with repeated x values\nfunction output(xv, yhat, ux, uy) {\n    var n = xv.length, out = [];\n    var i = 0, cnt = 0, prev = [], v;\n    for(; i < n; ++i){\n        v = xv[i] + ux;\n        if (prev[0] === v) {\n            // Average output values via online update\n            prev[1] += (yhat[i] - prev[1]) / ++cnt;\n        } else {\n            // Add new output point\n            cnt = 0;\n            prev[1] += uy;\n            prev = [\n                v,\n                yhat[i]\n            ];\n            out.push(prev);\n        }\n    }\n    prev[1] += uy;\n    return out;\n}\nfunction logarithmic() {\n    var x = function x(d) {\n        return d[0];\n    }, y = function y(d) {\n        return d[1];\n    }, base = Math.E, domain;\n    function logarithmic(data) {\n        var n = 0, X = 0, Y = 0, XY = 0, X2 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity, lb = Math.log(base);\n        visitPoints(data, x, y, function(dx, dy) {\n            var lx = Math.log(dx) / lb;\n            ++n;\n            X += (lx - X) / n;\n            Y += (dy - Y) / n;\n            XY += (lx * dy - XY) / n;\n            X2 += (lx * lx - X2) / n;\n            if (!domain) {\n                if (dx < xmin) xmin = dx;\n                if (dx > xmax) xmax = dx;\n            }\n        });\n        var _ols = ols(X, Y, XY, X2), _ols2 = _slicedToArray(_ols, 2), intercept = _ols2[0], slope = _ols2[1], fn = function fn(x) {\n            return slope * Math.log(x) / lb + intercept;\n        }, out = interpose(xmin, xmax, fn);\n        out.a = slope;\n        out.b = intercept;\n        out.predict = fn;\n        out.rSquared = determination(data, x, y, Y, fn);\n        return out;\n    }\n    logarithmic.domain = function(arr) {\n        return arguments.length ? (domain = arr, logarithmic) : domain;\n    };\n    logarithmic.x = function(fn) {\n        return arguments.length ? (x = fn, logarithmic) : x;\n    };\n    logarithmic.y = function(fn) {\n        return arguments.length ? (y = fn, logarithmic) : y;\n    };\n    logarithmic.base = function(n) {\n        return arguments.length ? (base = n, logarithmic) : base;\n    };\n    return logarithmic;\n}\nfunction quad() {\n    var x = function x(d) {\n        return d[0];\n    }, y = function y(d) {\n        return d[1];\n    }, domain;\n    function quadratic(data) {\n        var _points = points(data, x, y), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n = xv.length;\n        var X2 = 0, X3 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x2;\n        for(i = 0; i < n;){\n            dx = xv[i];\n            dy = yv[i++];\n            x2 = dx * dx;\n            X2 += (x2 - X2) / i;\n            X3 += (x2 * dx - X3) / i;\n            X4 += (x2 * x2 - X4) / i;\n            XY += (dx * dy - XY) / i;\n            X2Y += (x2 * dy - X2Y) / i;\n        }\n        var Y = 0, n0 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;\n        visitPoints(data, x, y, function(dx, dy) {\n            n0++;\n            Y += (dy - Y) / n0;\n            if (!domain) {\n                if (dx < xmin) xmin = dx;\n                if (dx > xmax) xmax = dx;\n            }\n        });\n        var X2X2 = X4 - X2 * X2, d = X2 * X2X2 - X3 * X3, a = (X2Y * X2 - XY * X3) / d, b = (XY * X2X2 - X2Y * X3) / d, c = -a * X2, fn = function fn(x) {\n            x = x - ux;\n            return a * x * x + b * x + c + uy;\n        };\n        var out = interpose(xmin, xmax, fn);\n        out.a = a;\n        out.b = b - 2 * a * ux;\n        out.c = c - b * ux + a * ux * ux + uy;\n        out.predict = fn;\n        out.rSquared = determination(data, x, y, Y, fn);\n        return out;\n    }\n    quadratic.domain = function(arr) {\n        return arguments.length ? (domain = arr, quadratic) : domain;\n    };\n    quadratic.x = function(fn) {\n        return arguments.length ? (x = fn, quadratic) : x;\n    };\n    quadratic.y = function(fn) {\n        return arguments.length ? (y = fn, quadratic) : y;\n    };\n    return quadratic;\n}\n// Source: https://github.com/Tom-Alexander/regression-js/blob/master/src/regression.js#L246\n// License: https://github.com/Tom-Alexander/regression-js/blob/master/LICENSE\n// ...with ideas from vega-statistics by Jeffrey Heer\n// Source: https://github.com/vega/vega/blob/f21cb8792b4e0cbe2b1a3fd44b0f5db370dbaadb/packages/vega-statistics/src/regression/poly.js\n// License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE\nfunction polynomial() {\n    var x = function x(d) {\n        return d[0];\n    }, y = function y(d) {\n        return d[1];\n    }, order = 3, domain;\n    function polynomial(data) {\n        // Use more efficient methods for lower orders\n        if (order === 1) {\n            var o = linear().x(x).y(y).domain(domain)(data);\n            o.coefficients = [\n                o.b,\n                o.a\n            ];\n            delete o.a;\n            delete o.b;\n            return o;\n        }\n        if (order === 2) {\n            var _o = quad().x(x).y(y).domain(domain)(data);\n            _o.coefficients = [\n                _o.c,\n                _o.b,\n                _o.a\n            ];\n            delete _o.a;\n            delete _o.b;\n            delete _o.c;\n            return _o;\n        }\n        var _points = points(data, x, y), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n = xv.length, lhs = [], rhs = [], k = order + 1;\n        var Y = 0, n0 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;\n        visitPoints(data, x, y, function(dx, dy) {\n            ++n0;\n            Y += (dy - Y) / n0;\n            if (!domain) {\n                if (dx < xmin) xmin = dx;\n                if (dx > xmax) xmax = dx;\n            }\n        });\n        var i, j, l, v, c;\n        for(i = 0; i < k; ++i){\n            for(l = 0, v = 0; l < n; ++l){\n                v += Math.pow(xv[l], i) * yv[l];\n            }\n            lhs.push(v);\n            c = new Float64Array(k);\n            for(j = 0; j < k; ++j){\n                for(l = 0, v = 0; l < n; ++l){\n                    v += Math.pow(xv[l], i + j);\n                }\n                c[j] = v;\n            }\n            rhs.push(c);\n        }\n        rhs.push(lhs);\n        var coef = gaussianElimination(rhs), fn = function fn(x) {\n            x -= ux;\n            var y = uy + coef[0] + coef[1] * x + coef[2] * x * x;\n            for(i = 3; i < k; ++i){\n                y += coef[i] * Math.pow(x, i);\n            }\n            return y;\n        }, out = interpose(xmin, xmax, fn);\n        out.coefficients = uncenter(k, coef, -ux, uy);\n        out.predict = fn;\n        out.rSquared = determination(data, x, y, Y, fn);\n        return out;\n    }\n    polynomial.domain = function(arr) {\n        return arguments.length ? (domain = arr, polynomial) : domain;\n    };\n    polynomial.x = function(fn) {\n        return arguments.length ? (x = fn, polynomial) : x;\n    };\n    polynomial.y = function(fn) {\n        return arguments.length ? (y = fn, polynomial) : y;\n    };\n    polynomial.order = function(n) {\n        return arguments.length ? (order = n, polynomial) : order;\n    };\n    return polynomial;\n}\nfunction uncenter(k, a, x, y) {\n    var z = Array(k);\n    var i, j, v, c; // initialize to zero\n    for(i = 0; i < k; ++i){\n        z[i] = 0;\n    } // polynomial expansion\n    for(i = k - 1; i >= 0; --i){\n        v = a[i];\n        c = 1;\n        z[i] += v;\n        for(j = 1; j <= i; ++j){\n            c *= (i + 1 - j) / j; // binomial coefficent\n            z[i - j] += v * Math.pow(x, j) * c;\n        }\n    } // bias term\n    z[0] += y;\n    return z;\n} // Given an array for a two-dimensional matrix and the polynomial order,\n// solve A * x = b using Gaussian elimination.\nfunction gaussianElimination(matrix) {\n    var n = matrix.length - 1, coef = [];\n    var i, j, k, r, t;\n    for(i = 0; i < n; ++i){\n        r = i; // max row\n        for(j = i + 1; j < n; ++j){\n            if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {\n                r = j;\n            }\n        }\n        for(k = i; k < n + 1; ++k){\n            t = matrix[k][i];\n            matrix[k][i] = matrix[k][r];\n            matrix[k][r] = t;\n        }\n        for(j = i + 1; j < n; ++j){\n            for(k = n; k >= i; k--){\n                matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];\n            }\n        }\n    }\n    for(j = n - 1; j >= 0; --j){\n        t = 0;\n        for(k = j + 1; k < n; ++k){\n            t += matrix[k][j] * coef[k];\n        }\n        coef[j] = (matrix[n][j] - t) / matrix[j][j];\n    }\n    return coef;\n}\nfunction power() {\n    var x = function x(d) {\n        return d[0];\n    }, y = function y(d) {\n        return d[1];\n    }, domain;\n    function power(data) {\n        var n = 0, X = 0, Y = 0, XY = 0, X2 = 0, YS = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;\n        visitPoints(data, x, y, function(dx, dy) {\n            var lx = Math.log(dx), ly = Math.log(dy);\n            ++n;\n            X += (lx - X) / n;\n            Y += (ly - Y) / n;\n            XY += (lx * ly - XY) / n;\n            X2 += (lx * lx - X2) / n;\n            YS += (dy - YS) / n;\n            if (!domain) {\n                if (dx < xmin) xmin = dx;\n                if (dx > xmax) xmax = dx;\n            }\n        });\n        var _ols = ols(X, Y, XY, X2), _ols2 = _slicedToArray(_ols, 2), a = _ols2[0], b = _ols2[1];\n        a = Math.exp(a);\n        var fn = function fn(x) {\n            return a * Math.pow(x, b);\n        }, out = interpose(xmin, xmax, fn);\n        out.a = a;\n        out.b = b;\n        out.predict = fn;\n        out.rSquared = determination(data, x, y, YS, fn);\n        return out;\n    }\n    power.domain = function(arr) {\n        return arguments.length ? (domain = arr, power) : domain;\n    };\n    power.x = function(fn) {\n        return arguments.length ? (x = fn, power) : x;\n    };\n    power.y = function(fn) {\n        return arguments.length ? (y = fn, power) : y;\n    };\n    return power;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZDMtcmVncmVzc2lvbi9kaXN0L2QzLXJlZ3Jlc3Npb24uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxxR0FBcUc7QUFDckcsU0FBU0EsZUFBZUMsR0FBRyxFQUFFQyxDQUFDO0lBQzVCLE9BQU9DLGdCQUFnQkYsUUFBUUcsc0JBQXNCSCxLQUFLQyxNQUFNRztBQUNsRTtBQUVBLFNBQVNGLGdCQUFnQkYsR0FBRztJQUMxQixJQUFJSyxNQUFNQyxPQUFPLENBQUNOLE1BQU0sT0FBT0E7QUFDakM7QUFFQSxTQUFTRyxzQkFBc0JILEdBQUcsRUFBRUMsQ0FBQztJQUNuQyxJQUFJTSxPQUFPLEVBQUU7SUFDYixJQUFJQyxLQUFLO0lBQ1QsSUFBSUMsS0FBSztJQUNULElBQUlDLEtBQUtDO0lBRVQsSUFBSTtRQUNGLElBQUssSUFBSUMsS0FBS1osR0FBRyxDQUFDYSxPQUFPQyxRQUFRLENBQUMsSUFBSUMsSUFBSSxDQUFFUCxDQUFBQSxLQUFLLENBQUNPLEtBQUtILEdBQUdJLElBQUksRUFBQyxFQUFHQyxJQUFJLEdBQUdULEtBQUssS0FBTTtZQUNsRkQsS0FBS1csSUFBSSxDQUFDSCxHQUFHSSxLQUFLO1lBRWxCLElBQUlsQixLQUFLTSxLQUFLYSxNQUFNLEtBQUtuQixHQUFHO1FBQzlCO0lBQ0YsRUFBRSxPQUFPb0IsS0FBSztRQUNaWixLQUFLO1FBQ0xDLEtBQUtXO0lBQ1AsU0FBVTtRQUNSLElBQUk7WUFDRixJQUFJLENBQUNiLE1BQU1JLEVBQUUsQ0FBQyxTQUFTLElBQUksTUFBTUEsRUFBRSxDQUFDLFNBQVM7UUFDL0MsU0FBVTtZQUNSLElBQUlILElBQUksTUFBTUM7UUFDaEI7SUFDRjtJQUVBLE9BQU9IO0FBQ1Q7QUFFQSxTQUFTSDtJQUNQLE1BQU0sSUFBSWtCLFVBQVU7QUFDdEI7QUFFQSwrQ0FBK0M7QUFDL0MsOEZBQThGO0FBQzlGLHVJQUF1STtBQUN2SSxTQUFTQyxPQUFPQyxJQUFJLEVBQUVDLENB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QUFLaUIsTUFBTUEsT0FBT2pCO1lBQ3hCO1FBQ0Y7UUFFQSxJQUFJb0QsT0FBT2hCLElBQUk5QyxHQUFHRSxHQUFHc0QsSUFBSWMsS0FDckJQLFFBQVFwRyxlQUFlbUcsTUFBTSxJQUM3QmpFLElBQUlrRSxLQUFLLENBQUMsRUFBRSxFQUNaakUsSUFBSWlFLEtBQUssQ0FBQyxFQUFFO1FBRWhCbEUsSUFBSXdCLEtBQUsyQyxHQUFHLENBQUNuRTtRQUViLElBQUlvRSxLQUFLLFNBQVNBLEdBQUc1RSxDQUFDO1lBQ3BCLE9BQU9RLElBQUl3QixLQUFLVyxHQUFHLENBQUMzQyxHQUFHUztRQUN6QixHQUNJb0UsTUFBTXpDLFVBQVVDLE1BQU1DLE1BQU1zQztRQUVoQ0MsSUFBSXJFLENBQUMsR0FBR0E7UUFDUnFFLElBQUlwRSxDQUFDLEdBQUdBO1FBQ1JvRSxJQUFJcEQsT0FBTyxHQUFHbUQ7UUFDZEMsSUFBSUMsUUFBUSxHQUFHdkQsY0FBY3hCLE1BQU1DLEdBQUdDLEdBQUdrSixJQUFJdkU7UUFDN0MsT0FBT0M7SUFDVDtJQUVBcUUsTUFBTWpGLE1BQU0sR0FBRyxTQUFVMUYsR0FBRztRQUMxQixPQUFPd0csVUFBVXBGLE1BQU0sR0FBSXNFLENBQUFBLFNBQVMxRixLQUFLMkssS0FBSSxJQUFLakY7SUFDcEQ7SUFFQWlGLE1BQU1sSixDQUFDLEdBQUcsU0FBVTRFLEVBQUU7UUFDcEIsT0FBT0csVUFBVXBGLE1BQU0sR0FBSUssQ0FBQUEsSUFBSTRFLElBQUlzRSxLQUFJLElBQUtsSjtJQUM5QztJQUVBa0osTUFBTWpKLENBQUMsR0FBRyxTQUFVMkUsRUFBRTtRQUNwQixPQUFPRyxVQUFVcEYsTUFBTSxHQUFJTSxDQUFBQSxJQUFJMkUsSUFBSXNFLEtBQUksSUFBS2pKO0lBQzlDO0lBRUEsT0FBT2lKO0FBQ1Q7QUFFME0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMtcmVncmVzc2lvbi9kaXN0L2QzLXJlZ3Jlc3Npb24uZXNtLmpzP2U3NzciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhcnJ5U3RldmVucy9kMy1yZWdyZXNzaW9uI3JlYWRtZSBWZXJzaW9uIDEuMy4xMC4gQ29weXJpZ2h0IDIwMjIgSGFycnkgU3RldmVucy5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIHZlZ2Etc3RhdGlzdGljcyBieSBKZWZmcmV5IEhlZXJcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EvYmxvYi9mMDU4YjA5OWRlY2FkOWRiNzgzMDE0MDVkZDBkMmU5ZDhiYTNkNTFhL0xJQ0VOU0Vcbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS9ibG9iL2YwNThiMDk5ZGVjYWQ5ZGI3ODMwMTQwNWRkMGQyZTlkOGJhM2Q1MWEvcGFja2FnZXMvdmVnYS1zdGF0aXN0aWNzL3NyYy9yZWdyZXNzaW9uL3BvaW50cy5qc1xuZnVuY3Rpb24gcG9pbnRzKGRhdGEsIHgsIHksIHNvcnQpIHtcbiAgZGF0YSA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgdmFyIHUgPSB4KGQsIGkpLFxuICAgICAgICB2ID0geShkLCBpKTtcbiAgICByZXR1cm4gdSAhPSBudWxsICYmIGlzRmluaXRlKHUpICYmIHYgIT0gbnVsbCAmJiBpc0Zpbml0ZSh2KTtcbiAgfSk7XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBkYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiB4KGEpIC0geChiKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBuID0gZGF0YS5sZW5ndGgsXG4gICAgICBYID0gbmV3IEZsb2F0NjRBcnJheShuKSxcbiAgICAgIFkgPSBuZXcgRmxvYXQ2NEFycmF5KG4pOyAvLyBleHRyYWN0IHZhbHVlcywgY2FsY3VsYXRlIG1lYW5zXG5cbiAgdmFyIHV4ID0gMCxcbiAgICAgIHV5ID0gMCxcbiAgICAgIHh2LFxuICAgICAgeXYsXG4gICAgICBkO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjspIHtcbiAgICBkID0gZGF0YVtpXTtcbiAgICBYW2ldID0geHYgPSAreChkLCBpLCBkYXRhKTtcbiAgICBZW2ldID0geXYgPSAreShkLCBpLCBkYXRhKTtcbiAgICArK2k7XG4gICAgdXggKz0gKHh2IC0gdXgpIC8gaTtcbiAgICB1eSArPSAoeXYgLSB1eSkgLyBpO1xuICB9IC8vIG1lYW4gY2VudGVyIHRoZSBkYXRhXG5cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbjsgKytfaSkge1xuICAgIFhbX2ldIC09IHV4O1xuICAgIFlbX2ldIC09IHV5O1xuICB9XG5cbiAgcmV0dXJuIFtYLCBZLCB1eCwgdXldO1xufVxuZnVuY3Rpb24gdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgY2IpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgZCA9IGRhdGFbaV0sXG4gICAgICAgIGR4ID0gK3goZCwgaSwgZGF0YSksXG4gICAgICAgIGR5ID0gK3koZCwgaSwgZGF0YSk7XG5cbiAgICBpZiAoZHggIT0gbnVsbCAmJiBpc0Zpbml0ZShkeCkgJiYgZHkgIT0gbnVsbCAmJiBpc0Zpbml0ZShkeSkpIHtcbiAgICAgIGNiKGR4LCBkeSwgaXRlcmF0aW9ucysrKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcmV0dXJuIHRoZSBjb2VmZmljaWVudCBvZiBkZXRlcm1pbmF0aW9uLCBvciBSIHNxdWFyZWQuXG5cbmZ1bmN0aW9uIGRldGVybWluYXRpb24oZGF0YSwgeCwgeSwgdVksIHByZWRpY3QpIHtcbiAgdmFyIFNTRSA9IDAsXG4gICAgICBTU1QgPSAwO1xuICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgdmFyIHNzZSA9IGR5IC0gcHJlZGljdChkeCksXG4gICAgICAgIHNzdCA9IGR5IC0gdVk7XG4gICAgU1NFICs9IHNzZSAqIHNzZTtcbiAgICBTU1QgKz0gc3N0ICogc3N0O1xuICB9KTtcbiAgcmV0dXJuIDEgLSBTU0UgLyBTU1Q7XG59XG5cbi8vIFJldHVybnMgdGhlIGFuZ2xlIG9mIGEgbGluZSBpbiBkZWdyZWVzLlxuZnVuY3Rpb24gYW5nbGUobGluZSkge1xuICByZXR1cm4gTWF0aC5hdGFuMihsaW5lWzFdWzFdIC0gbGluZVswXVsxXSwgbGluZVsxXVswXSAtIGxpbmVbMF1bMF0pICogMTgwIC8gTWF0aC5QSTtcbn0gLy8gUmV0dXJucyB0aGUgbWlkcG9pbnQgb2YgYSBsaW5lLlxuXG5mdW5jdGlvbiBtaWRwb2ludChsaW5lKSB7XG4gIHJldHVybiBbKGxpbmVbMF1bMF0gKyBsaW5lWzFdWzBdKSAvIDIsIChsaW5lWzBdWzFdICsgbGluZVsxXVsxXSkgLyAyXTtcbn1cblxuLy8gcmV0dXJucyBhIHNtb290aCBsaW5lLlxuXG5mdW5jdGlvbiBpbnRlcnBvc2UoeG1pbiwgeG1heCwgcHJlZGljdCkge1xuICB2YXIgbCA9IE1hdGgubG9nKHhtYXggLSB4bWluKSAqIE1hdGguTE9HMTBFICsgMSB8IDA7XG4gIHZhciBwcmVjaXNpb24gPSAxICogTWF0aC5wb3coMTAsIC1sIC8gMiAtIDEpLFxuICAgICAgbWF4SXRlciA9IDFlNDtcbiAgdmFyIHBvaW50cyA9IFtweCh4bWluKSwgcHgoeG1heCldLFxuICAgICAgaXRlciA9IDA7XG5cbiAgd2hpbGUgKGZpbmQocG9pbnRzKSAmJiBpdGVyIDwgbWF4SXRlcikge1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcblxuICBmdW5jdGlvbiBweCh4KSB7XG4gICAgcmV0dXJuIFt4LCBwcmVkaWN0KHgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmQocG9pbnRzKSB7XG4gICAgaXRlcisrO1xuICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgdmFyIHAwID0gcG9pbnRzW2ldLFxuICAgICAgICAgIHAxID0gcG9pbnRzW2kgKyAxXSxcbiAgICAgICAgICBtID0gbWlkcG9pbnQoW3AwLCBwMV0pLFxuICAgICAgICAgIG1wID0gcHgobVswXSksXG4gICAgICAgICAgYTAgPSBhbmdsZShbcDAsIG1dKSxcbiAgICAgICAgICBhMSA9IGFuZ2xlKFtwMCwgbXBdKSxcbiAgICAgICAgICBhID0gTWF0aC5hYnMoYTAgLSBhMSk7XG5cbiAgICAgIGlmIChhID4gcHJlY2lzaW9uKSB7XG4gICAgICAgIHBvaW50cy5zcGxpY2UoaSArIDEsIDAsIG1wKTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxufVxuXG4vLyBPcmRpbmFyeSBMZWFzdCBTcXVhcmVzIGZyb20gdmVnYS1zdGF0aXN0aWNzIGJ5IEplZmZyZXkgSGVlclxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS9ibG9iL2YwNThiMDk5ZGVjYWQ5ZGI3ODMwMTQwNWRkMGQyZTlkOGJhM2Q1MWEvTElDRU5TRVxuLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhL2Jsb2IvZjA1OGIwOTlkZWNhZDlkYjc4MzAxNDA1ZGQwZDJlOWQ4YmEzZDUxYS9wYWNrYWdlcy92ZWdhLXN0YXRpc3RpY3Mvc3JjL3JlZ3Jlc3Npb24vb2xzLmpzXG5mdW5jdGlvbiBvbHModVgsIHVZLCB1WFksIHVYMikge1xuICB2YXIgZGVsdGEgPSB1WDIgLSB1WCAqIHVYLFxuICAgICAgc2xvcGUgPSBNYXRoLmFicyhkZWx0YSkgPCAxZS0yNCA/IDAgOiAodVhZIC0gdVggKiB1WSkgLyBkZWx0YSxcbiAgICAgIGludGVyY2VwdCA9IHVZIC0gc2xvcGUgKiB1WDtcbiAgcmV0dXJuIFtpbnRlcmNlcHQsIHNsb3BlXTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnRpYWwgKCkge1xuICB2YXIgeCA9IGZ1bmN0aW9uIHgoZCkge1xuICAgIHJldHVybiBkWzBdO1xuICB9LFxuICAgICAgeSA9IGZ1bmN0aW9uIHkoZCkge1xuICAgIHJldHVybiBkWzFdO1xuICB9LFxuICAgICAgZG9tYWluO1xuXG4gIGZ1bmN0aW9uIGV4cG9uZW50aWFsKGRhdGEpIHtcbiAgICB2YXIgbiA9IDAsXG4gICAgICAgIFkgPSAwLFxuICAgICAgICBZTCA9IDAsXG4gICAgICAgIFhZID0gMCxcbiAgICAgICAgWFlMID0gMCxcbiAgICAgICAgWDJZID0gMCxcbiAgICAgICAgeG1pbiA9IGRvbWFpbiA/ICtkb21haW5bMF0gOiBJbmZpbml0eSxcbiAgICAgICAgeG1heCA9IGRvbWFpbiA/ICtkb21haW5bMV0gOiAtSW5maW5pdHk7XG4gICAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgdmFyIGx5ID0gTWF0aC5sb2coZHkpLFxuICAgICAgICAgIHh5ID0gZHggKiBkeTtcbiAgICAgICsrbjtcbiAgICAgIFkgKz0gKGR5IC0gWSkgLyBuO1xuICAgICAgWFkgKz0gKHh5IC0gWFkpIC8gbjtcbiAgICAgIFgyWSArPSAoZHggKiB4eSAtIFgyWSkgLyBuO1xuICAgICAgWUwgKz0gKGR5ICogbHkgLSBZTCkgLyBuO1xuICAgICAgWFlMICs9ICh4eSAqIGx5IC0gWFlMKSAvIG47XG5cbiAgICAgIGlmICghZG9tYWluKSB7XG4gICAgICAgIGlmIChkeCA8IHhtaW4pIHhtaW4gPSBkeDtcbiAgICAgICAgaWYgKGR4ID4geG1heCkgeG1heCA9IGR4O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIF9vbHMgPSBvbHMoWFkgLyBZLCBZTCAvIFksIFhZTCAvIFksIFgyWSAvIFkpLFxuICAgICAgICBfb2xzMiA9IF9zbGljZWRUb0FycmF5KF9vbHMsIDIpLFxuICAgICAgICBhID0gX29sczJbMF0sXG4gICAgICAgIGIgPSBfb2xzMlsxXTtcblxuICAgIGEgPSBNYXRoLmV4cChhKTtcblxuICAgIHZhciBmbiA9IGZ1bmN0aW9uIGZuKHgpIHtcbiAgICAgIHJldHVybiBhICogTWF0aC5leHAoYiAqIHgpO1xuICAgIH0sXG4gICAgICAgIG91dCA9IGludGVycG9zZSh4bWluLCB4bWF4LCBmbik7XG5cbiAgICBvdXQuYSA9IGE7XG4gICAgb3V0LmIgPSBiO1xuICAgIG91dC5wcmVkaWN0ID0gZm47XG4gICAgb3V0LnJTcXVhcmVkID0gZGV0ZXJtaW5hdGlvbihkYXRhLCB4LCB5LCBZLCBmbik7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGV4cG9uZW50aWFsLmRvbWFpbiA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBhcnIsIGV4cG9uZW50aWFsKSA6IGRvbWFpbjtcbiAgfTtcblxuICBleHBvbmVudGlhbC54ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IGZuLCBleHBvbmVudGlhbCkgOiB4O1xuICB9O1xuXG4gIGV4cG9uZW50aWFsLnkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gZm4sIGV4cG9uZW50aWFsKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIGV4cG9uZW50aWFsO1xufVxuXG5mdW5jdGlvbiBsaW5lYXIgKCkge1xuICB2YXIgeCA9IGZ1bmN0aW9uIHgoZCkge1xuICAgIHJldHVybiBkWzBdO1xuICB9LFxuICAgICAgeSA9IGZ1bmN0aW9uIHkoZCkge1xuICAgIHJldHVybiBkWzFdO1xuICB9LFxuICAgICAgZG9tYWluO1xuXG4gIGZ1bmN0aW9uIGxpbmVhcihkYXRhKSB7XG4gICAgdmFyIG4gPSAwLFxuICAgICAgICBYID0gMCxcbiAgICAgICAgLy8gc3VtIG9mIHhcbiAgICBZID0gMCxcbiAgICAgICAgLy8gc3VtIG9mIHlcbiAgICBYWSA9IDAsXG4gICAgICAgIC8vIHN1bSBvZiB4ICogeVxuICAgIFgyID0gMCxcbiAgICAgICAgLy8gc3VtIG9mIHggKiB4XG4gICAgeG1pbiA9IGRvbWFpbiA/ICtkb21haW5bMF0gOiBJbmZpbml0eSxcbiAgICAgICAgeG1heCA9IGRvbWFpbiA/ICtkb21haW5bMV0gOiAtSW5maW5pdHk7XG4gICAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgKytuO1xuICAgICAgWCArPSAoZHggLSBYKSAvIG47XG4gICAgICBZICs9IChkeSAtIFkpIC8gbjtcbiAgICAgIFhZICs9IChkeCAqIGR5IC0gWFkpIC8gbjtcbiAgICAgIFgyICs9IChkeCAqIGR4IC0gWDIpIC8gbjtcblxuICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgaWYgKGR4IDwgeG1pbikgeG1pbiA9IGR4O1xuICAgICAgICBpZiAoZHggPiB4bWF4KSB4bWF4ID0gZHg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgX29scyA9IG9scyhYLCBZLCBYWSwgWDIpLFxuICAgICAgICBfb2xzMiA9IF9zbGljZWRUb0FycmF5KF9vbHMsIDIpLFxuICAgICAgICBpbnRlcmNlcHQgPSBfb2xzMlswXSxcbiAgICAgICAgc2xvcGUgPSBfb2xzMlsxXSxcbiAgICAgICAgZm4gPSBmdW5jdGlvbiBmbih4KSB7XG4gICAgICByZXR1cm4gc2xvcGUgKiB4ICsgaW50ZXJjZXB0O1xuICAgIH0sXG4gICAgICAgIG91dCA9IFtbeG1pbiwgZm4oeG1pbildLCBbeG1heCwgZm4oeG1heCldXTtcblxuICAgIG91dC5hID0gc2xvcGU7XG4gICAgb3V0LmIgPSBpbnRlcmNlcHQ7XG4gICAgb3V0LnByZWRpY3QgPSBmbjtcbiAgICBvdXQuclNxdWFyZWQgPSBkZXRlcm1pbmF0aW9uKGRhdGEsIHgsIHksIFksIGZuKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgbGluZWFyLmRvbWFpbiA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBhcnIsIGxpbmVhcikgOiBkb21haW47XG4gIH07XG5cbiAgbGluZWFyLnggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gZm4sIGxpbmVhcikgOiB4O1xuICB9O1xuXG4gIGxpbmVhci55ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IGZuLCBsaW5lYXIpIDogeTtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBtZWRpdW0gdmFsdWUgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbmZ1bmN0aW9uIG1lZGlhbihhcnIpIHtcbiAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuICB2YXIgaSA9IGFyci5sZW5ndGggLyAyO1xuICByZXR1cm4gaSAlIDEgPT09IDAgPyAoYXJyW2kgLSAxXSArIGFycltpXSkgLyAyIDogYXJyW01hdGguZmxvb3IoaSldO1xufVxuXG52YXIgbWF4aXRlcnMgPSAyLFxuICAgIGVwc2lsb24gPSAxZS0xMjtcbmZ1bmN0aW9uIGxvZXNzICgpIHtcbiAgdmFyIHggPSBmdW5jdGlvbiB4KGQpIHtcbiAgICByZXR1cm4gZFswXTtcbiAgfSxcbiAgICAgIHkgPSBmdW5jdGlvbiB5KGQpIHtcbiAgICByZXR1cm4gZFsxXTtcbiAgfSxcbiAgICAgIGJhbmR3aWR0aCA9IC4zO1xuXG4gIGZ1bmN0aW9uIGxvZXNzKGRhdGEpIHtcbiAgICB2YXIgX3BvaW50cyA9IHBvaW50cyhkYXRhLCB4LCB5LCB0cnVlKSxcbiAgICAgICAgX3BvaW50czIgPSBfc2xpY2VkVG9BcnJheShfcG9pbnRzLCA0KSxcbiAgICAgICAgeHYgPSBfcG9pbnRzMlswXSxcbiAgICAgICAgeXYgPSBfcG9pbnRzMlsxXSxcbiAgICAgICAgdXggPSBfcG9pbnRzMlsyXSxcbiAgICAgICAgdXkgPSBfcG9pbnRzMlszXSxcbiAgICAgICAgbiA9IHh2Lmxlbmd0aCxcbiAgICAgICAgYncgPSBNYXRoLm1heCgyLCB+fihiYW5kd2lkdGggKiBuKSksXG4gICAgICAgIHloYXQgPSBuZXcgRmxvYXQ2NEFycmF5KG4pLFxuICAgICAgICByZXNpZHVhbHMgPSBuZXcgRmxvYXQ2NEFycmF5KG4pLFxuICAgICAgICByb2J1c3RXZWlnaHRzID0gbmV3IEZsb2F0NjRBcnJheShuKS5maWxsKDEpO1xuXG4gICAgZm9yICh2YXIgaXRlciA9IC0xOyArK2l0ZXIgPD0gbWF4aXRlcnM7KSB7XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBbMCwgYncgLSAxXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdmFyIGR4ID0geHZbaV0sXG4gICAgICAgICAgICBpMCA9IGludGVydmFsWzBdLFxuICAgICAgICAgICAgaTEgPSBpbnRlcnZhbFsxXSxcbiAgICAgICAgICAgIGVkZ2UgPSBkeCAtIHh2W2kwXSA+IHh2W2kxXSAtIGR4ID8gaTAgOiBpMTtcbiAgICAgICAgdmFyIFcgPSAwLFxuICAgICAgICAgICAgWCA9IDAsXG4gICAgICAgICAgICBZID0gMCxcbiAgICAgICAgICAgIFhZID0gMCxcbiAgICAgICAgICAgIFgyID0gMCxcbiAgICAgICAgICAgIGRlbm9tID0gMSAvIE1hdGguYWJzKHh2W2VkZ2VdIC0gZHggfHwgMSk7IC8vIEF2b2lkIHNpbmd1bGFyaXR5XG5cbiAgICAgICAgZm9yICh2YXIgayA9IGkwOyBrIDw9IGkxOyArK2spIHtcbiAgICAgICAgICB2YXIgeGsgPSB4dltrXSxcbiAgICAgICAgICAgICAgeWsgPSB5dltrXSxcbiAgICAgICAgICAgICAgdyA9IHRyaWN1YmUoTWF0aC5hYnMoZHggLSB4aykgKiBkZW5vbSkgKiByb2J1c3RXZWlnaHRzW2tdLFxuICAgICAgICAgICAgICB4a3cgPSB4ayAqIHc7XG4gICAgICAgICAgVyArPSB3O1xuICAgICAgICAgIFggKz0geGt3O1xuICAgICAgICAgIFkgKz0geWsgKiB3O1xuICAgICAgICAgIFhZICs9IHlrICogeGt3O1xuICAgICAgICAgIFgyICs9IHhrICogeGt3O1xuICAgICAgICB9IC8vIExpbmVhciByZWdyZXNzaW9uIGZpdFxuXG5cbiAgICAgICAgdmFyIF9vbHMgPSBvbHMoWCAvIFcsIFkgLyBXLCBYWSAvIFcsIFgyIC8gVyksXG4gICAgICAgICAgICBfb2xzMiA9IF9zbGljZWRUb0FycmF5KF9vbHMsIDIpLFxuICAgICAgICAgICAgYSA9IF9vbHMyWzBdLFxuICAgICAgICAgICAgYiA9IF9vbHMyWzFdO1xuXG4gICAgICAgIHloYXRbaV0gPSBhICsgYiAqIGR4O1xuICAgICAgICByZXNpZHVhbHNbaV0gPSBNYXRoLmFicyh5dltpXSAtIHloYXRbaV0pO1xuICAgICAgICB1cGRhdGVJbnRlcnZhbCh4diwgaSArIDEsIGludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZXIgPT09IG1heGl0ZXJzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWVkaWFuUmVzaWR1YWwgPSBtZWRpYW4ocmVzaWR1YWxzKTtcbiAgICAgIGlmIChNYXRoLmFicyhtZWRpYW5SZXNpZHVhbCkgPCBlcHNpbG9uKSBicmVhaztcblxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBhcmcsIF93OyBfaSA8IG47ICsrX2kpIHtcbiAgICAgICAgYXJnID0gcmVzaWR1YWxzW19pXSAvICg2ICogbWVkaWFuUmVzaWR1YWwpOyAvLyBEZWZhdWx0IHRvIGVwc2lsb24gKHJhdGhlciB0aGFuIHplcm8pIGZvciBsYXJnZSBkZXZpYXRpb25zXG4gICAgICAgIC8vIEtlZXBpbmcgd2VpZ2h0cyB0aW55IGJ1dCBub24temVybyBwcmV2ZW50cyBzaW5ndWxhcml0ZXNcblxuICAgICAgICByb2J1c3RXZWlnaHRzW19pXSA9IGFyZyA+PSAxID8gZXBzaWxvbiA6IChfdyA9IDEgLSBhcmcgKiBhcmcpICogX3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dCh4diwgeWhhdCwgdXgsIHV5KTtcbiAgfVxuXG4gIGxvZXNzLmJhbmR3aWR0aCA9IGZ1bmN0aW9uIChidykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGJhbmR3aWR0aCA9IGJ3LCBsb2VzcykgOiBiYW5kd2lkdGg7XG4gIH07XG5cbiAgbG9lc3MueCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSBmbiwgbG9lc3MpIDogeDtcbiAgfTtcblxuICBsb2Vzcy55ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IGZuLCBsb2VzcykgOiB5O1xuICB9O1xuXG4gIHJldHVybiBsb2Vzcztcbn0gLy8gV2VpZ2h0aW5nIGtlcm5lbCBmb3IgbG9jYWwgcmVncmVzc2lvblxuXG5mdW5jdGlvbiB0cmljdWJlKHgpIHtcbiAgcmV0dXJuICh4ID0gMSAtIHggKiB4ICogeCkgKiB4ICogeDtcbn0gLy8gQWR2YW5jZSBzbGlkaW5nIHdpbmRvdyBpbnRlcnZhbCBvZiBuZWFyZXN0IG5laWdoYm9yc1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZUludGVydmFsKHh2LCBpLCBpbnRlcnZhbCkge1xuICB2YXIgdmFsID0geHZbaV0sXG4gICAgICBsZWZ0ID0gaW50ZXJ2YWxbMF0sXG4gICAgICByaWdodCA9IGludGVydmFsWzFdICsgMTtcbiAgaWYgKHJpZ2h0ID49IHh2Lmxlbmd0aCkgcmV0dXJuOyAvLyBTdGVwIHJpZ2h0IGlmIGRpc3RhbmNlIHRvIG5ldyByaWdodCBlZGdlIGlzIDw9IGRpc3RhbmNlIHRvIG9sZCBsZWZ0IGVkZ2VcbiAgLy8gU3RlcCB3aGVuIGRpc3RhbmNlIGlzIGVxdWFsIHRvIGVuc3VyZSBtb3ZlbWVudCBvdmVyIGR1cGxpY2F0ZSB4IHZhbHVlc1xuXG4gIHdoaWxlIChpID4gbGVmdCAmJiB4dltyaWdodF0gLSB2YWwgPD0gdmFsIC0geHZbbGVmdF0pIHtcbiAgICBpbnRlcnZhbFswXSA9ICsrbGVmdDtcbiAgICBpbnRlcnZhbFsxXSA9IHJpZ2h0O1xuICAgICsrcmlnaHQ7XG4gIH1cbn0gLy8gR2VuZXJhdGUgc21vb3RoZWQgb3V0cHV0IHBvaW50c1xuLy8gQXZlcmFnZSBwb2ludHMgd2l0aCByZXBlYXRlZCB4IHZhbHVlc1xuXG5cbmZ1bmN0aW9uIG91dHB1dCh4diwgeWhhdCwgdXgsIHV5KSB7XG4gIHZhciBuID0geHYubGVuZ3RoLFxuICAgICAgb3V0ID0gW107XG4gIHZhciBpID0gMCxcbiAgICAgIGNudCA9IDAsXG4gICAgICBwcmV2ID0gW10sXG4gICAgICB2O1xuXG4gIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgdiA9IHh2W2ldICsgdXg7XG5cbiAgICBpZiAocHJldlswXSA9PT0gdikge1xuICAgICAgLy8gQXZlcmFnZSBvdXRwdXQgdmFsdWVzIHZpYSBvbmxpbmUgdXBkYXRlXG4gICAgICBwcmV2WzFdICs9ICh5aGF0W2ldIC0gcHJldlsxXSkgLyArK2NudDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIG5ldyBvdXRwdXQgcG9pbnRcbiAgICAgIGNudCA9IDA7XG4gICAgICBwcmV2WzFdICs9IHV5O1xuICAgICAgcHJldiA9IFt2LCB5aGF0W2ldXTtcbiAgICAgIG91dC5wdXNoKHByZXYpO1xuICAgIH1cbiAgfVxuXG4gIHByZXZbMV0gKz0gdXk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGxvZ2FyaXRobWljICgpIHtcbiAgdmFyIHggPSBmdW5jdGlvbiB4KGQpIHtcbiAgICByZXR1cm4gZFswXTtcbiAgfSxcbiAgICAgIHkgPSBmdW5jdGlvbiB5KGQpIHtcbiAgICByZXR1cm4gZFsxXTtcbiAgfSxcbiAgICAgIGJhc2UgPSBNYXRoLkUsXG4gICAgICBkb21haW47XG5cbiAgZnVuY3Rpb24gbG9nYXJpdGhtaWMoZGF0YSkge1xuICAgIHZhciBuID0gMCxcbiAgICAgICAgWCA9IDAsXG4gICAgICAgIFkgPSAwLFxuICAgICAgICBYWSA9IDAsXG4gICAgICAgIFgyID0gMCxcbiAgICAgICAgeG1pbiA9IGRvbWFpbiA/ICtkb21haW5bMF0gOiBJbmZpbml0eSxcbiAgICAgICAgeG1heCA9IGRvbWFpbiA/ICtkb21haW5bMV0gOiAtSW5maW5pdHksXG4gICAgICAgIGxiID0gTWF0aC5sb2coYmFzZSk7XG4gICAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgdmFyIGx4ID0gTWF0aC5sb2coZHgpIC8gbGI7XG4gICAgICArK247XG4gICAgICBYICs9IChseCAtIFgpIC8gbjtcbiAgICAgIFkgKz0gKGR5IC0gWSkgLyBuO1xuICAgICAgWFkgKz0gKGx4ICogZHkgLSBYWSkgLyBuO1xuICAgICAgWDIgKz0gKGx4ICogbHggLSBYMikgLyBuO1xuXG4gICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICBpZiAoZHggPCB4bWluKSB4bWluID0gZHg7XG4gICAgICAgIGlmIChkeCA+IHhtYXgpIHhtYXggPSBkeDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBfb2xzID0gb2xzKFgsIFksIFhZLCBYMiksXG4gICAgICAgIF9vbHMyID0gX3NsaWNlZFRvQXJyYXkoX29scywgMiksXG4gICAgICAgIGludGVyY2VwdCA9IF9vbHMyWzBdLFxuICAgICAgICBzbG9wZSA9IF9vbHMyWzFdLFxuICAgICAgICBmbiA9IGZ1bmN0aW9uIGZuKHgpIHtcbiAgICAgIHJldHVybiBzbG9wZSAqIE1hdGgubG9nKHgpIC8gbGIgKyBpbnRlcmNlcHQ7XG4gICAgfSxcbiAgICAgICAgb3V0ID0gaW50ZXJwb3NlKHhtaW4sIHhtYXgsIGZuKTtcblxuICAgIG91dC5hID0gc2xvcGU7XG4gICAgb3V0LmIgPSBpbnRlcmNlcHQ7XG4gICAgb3V0LnByZWRpY3QgPSBmbjtcbiAgICBvdXQuclNxdWFyZWQgPSBkZXRlcm1pbmF0aW9uKGRhdGEsIHgsIHksIFksIGZuKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgbG9nYXJpdGhtaWMuZG9tYWluID0gZnVuY3Rpb24gKGFycikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IGFyciwgbG9nYXJpdGhtaWMpIDogZG9tYWluO1xuICB9O1xuXG4gIGxvZ2FyaXRobWljLnggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gZm4sIGxvZ2FyaXRobWljKSA6IHg7XG4gIH07XG5cbiAgbG9nYXJpdGhtaWMueSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBmbiwgbG9nYXJpdGhtaWMpIDogeTtcbiAgfTtcblxuICBsb2dhcml0aG1pYy5iYXNlID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChiYXNlID0gbiwgbG9nYXJpdGhtaWMpIDogYmFzZTtcbiAgfTtcblxuICByZXR1cm4gbG9nYXJpdGhtaWM7XG59XG5cbmZ1bmN0aW9uIHF1YWQgKCkge1xuICB2YXIgeCA9IGZ1bmN0aW9uIHgoZCkge1xuICAgIHJldHVybiBkWzBdO1xuICB9LFxuICAgICAgeSA9IGZ1bmN0aW9uIHkoZCkge1xuICAgIHJldHVybiBkWzFdO1xuICB9LFxuICAgICAgZG9tYWluO1xuXG4gIGZ1bmN0aW9uIHF1YWRyYXRpYyhkYXRhKSB7XG4gICAgdmFyIF9wb2ludHMgPSBwb2ludHMoZGF0YSwgeCwgeSksXG4gICAgICAgIF9wb2ludHMyID0gX3NsaWNlZFRvQXJyYXkoX3BvaW50cywgNCksXG4gICAgICAgIHh2ID0gX3BvaW50czJbMF0sXG4gICAgICAgIHl2ID0gX3BvaW50czJbMV0sXG4gICAgICAgIHV4ID0gX3BvaW50czJbMl0sXG4gICAgICAgIHV5ID0gX3BvaW50czJbM10sXG4gICAgICAgIG4gPSB4di5sZW5ndGg7XG5cbiAgICB2YXIgWDIgPSAwLFxuICAgICAgICBYMyA9IDAsXG4gICAgICAgIFg0ID0gMCxcbiAgICAgICAgWFkgPSAwLFxuICAgICAgICBYMlkgPSAwLFxuICAgICAgICBpLFxuICAgICAgICBkeCxcbiAgICAgICAgZHksXG4gICAgICAgIHgyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47KSB7XG4gICAgICBkeCA9IHh2W2ldO1xuICAgICAgZHkgPSB5dltpKytdO1xuICAgICAgeDIgPSBkeCAqIGR4O1xuICAgICAgWDIgKz0gKHgyIC0gWDIpIC8gaTtcbiAgICAgIFgzICs9ICh4MiAqIGR4IC0gWDMpIC8gaTtcbiAgICAgIFg0ICs9ICh4MiAqIHgyIC0gWDQpIC8gaTtcbiAgICAgIFhZICs9IChkeCAqIGR5IC0gWFkpIC8gaTtcbiAgICAgIFgyWSArPSAoeDIgKiBkeSAtIFgyWSkgLyBpO1xuICAgIH1cblxuICAgIHZhciBZID0gMCxcbiAgICAgICAgbjAgPSAwLFxuICAgICAgICB4bWluID0gZG9tYWluID8gK2RvbWFpblswXSA6IEluZmluaXR5LFxuICAgICAgICB4bWF4ID0gZG9tYWluID8gK2RvbWFpblsxXSA6IC1JbmZpbml0eTtcbiAgICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICBuMCsrO1xuICAgICAgWSArPSAoZHkgLSBZKSAvIG4wO1xuXG4gICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICBpZiAoZHggPCB4bWluKSB4bWluID0gZHg7XG4gICAgICAgIGlmIChkeCA+IHhtYXgpIHhtYXggPSBkeDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBYMlgyID0gWDQgLSBYMiAqIFgyLFxuICAgICAgICBkID0gWDIgKiBYMlgyIC0gWDMgKiBYMyxcbiAgICAgICAgYSA9IChYMlkgKiBYMiAtIFhZICogWDMpIC8gZCxcbiAgICAgICAgYiA9IChYWSAqIFgyWDIgLSBYMlkgKiBYMykgLyBkLFxuICAgICAgICBjID0gLWEgKiBYMixcbiAgICAgICAgZm4gPSBmdW5jdGlvbiBmbih4KSB7XG4gICAgICB4ID0geCAtIHV4O1xuICAgICAgcmV0dXJuIGEgKiB4ICogeCArIGIgKiB4ICsgYyArIHV5O1xuICAgIH07XG5cbiAgICB2YXIgb3V0ID0gaW50ZXJwb3NlKHhtaW4sIHhtYXgsIGZuKTtcbiAgICBvdXQuYSA9IGE7XG4gICAgb3V0LmIgPSBiIC0gMiAqIGEgKiB1eDtcbiAgICBvdXQuYyA9IGMgLSBiICogdXggKyBhICogdXggKiB1eCArIHV5O1xuICAgIG91dC5wcmVkaWN0ID0gZm47XG4gICAgb3V0LnJTcXVhcmVkID0gZGV0ZXJtaW5hdGlvbihkYXRhLCB4LCB5LCBZLCBmbik7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIHF1YWRyYXRpYy5kb21haW4gPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gYXJyLCBxdWFkcmF0aWMpIDogZG9tYWluO1xuICB9O1xuXG4gIHF1YWRyYXRpYy54ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IGZuLCBxdWFkcmF0aWMpIDogeDtcbiAgfTtcblxuICBxdWFkcmF0aWMueSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBmbiwgcXVhZHJhdGljKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIHF1YWRyYXRpYztcbn1cblxuLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vVG9tLUFsZXhhbmRlci9yZWdyZXNzaW9uLWpzL2Jsb2IvbWFzdGVyL3NyYy9yZWdyZXNzaW9uLmpzI0wyNDZcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9Ub20tQWxleGFuZGVyL3JlZ3Jlc3Npb24tanMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuLy8gLi4ud2l0aCBpZGVhcyBmcm9tIHZlZ2Etc3RhdGlzdGljcyBieSBKZWZmcmV5IEhlZXJcbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS9ibG9iL2YyMWNiODc5MmI0ZTBjYmUyYjFhM2ZkNDRiMGY1ZGIzNzBkYmFhZGIvcGFja2FnZXMvdmVnYS1zdGF0aXN0aWNzL3NyYy9yZWdyZXNzaW9uL3BvbHkuanNcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EvYmxvYi9mMDU4YjA5OWRlY2FkOWRiNzgzMDE0MDVkZDBkMmU5ZDhiYTNkNTFhL0xJQ0VOU0VcblxuZnVuY3Rpb24gcG9seW5vbWlhbCAoKSB7XG4gIHZhciB4ID0gZnVuY3Rpb24geChkKSB7XG4gICAgcmV0dXJuIGRbMF07XG4gIH0sXG4gICAgICB5ID0gZnVuY3Rpb24geShkKSB7XG4gICAgcmV0dXJuIGRbMV07XG4gIH0sXG4gICAgICBvcmRlciA9IDMsXG4gICAgICBkb21haW47XG5cbiAgZnVuY3Rpb24gcG9seW5vbWlhbChkYXRhKSB7XG4gICAgLy8gVXNlIG1vcmUgZWZmaWNpZW50IG1ldGhvZHMgZm9yIGxvd2VyIG9yZGVyc1xuICAgIGlmIChvcmRlciA9PT0gMSkge1xuICAgICAgdmFyIG8gPSBsaW5lYXIoKS54KHgpLnkoeSkuZG9tYWluKGRvbWFpbikoZGF0YSk7XG4gICAgICBvLmNvZWZmaWNpZW50cyA9IFtvLmIsIG8uYV07XG4gICAgICBkZWxldGUgby5hO1xuICAgICAgZGVsZXRlIG8uYjtcbiAgICAgIHJldHVybiBvO1xuICAgIH1cblxuICAgIGlmIChvcmRlciA9PT0gMikge1xuICAgICAgdmFyIF9vID0gcXVhZCgpLngoeCkueSh5KS5kb21haW4oZG9tYWluKShkYXRhKTtcblxuICAgICAgX28uY29lZmZpY2llbnRzID0gW19vLmMsIF9vLmIsIF9vLmFdO1xuICAgICAgZGVsZXRlIF9vLmE7XG4gICAgICBkZWxldGUgX28uYjtcbiAgICAgIGRlbGV0ZSBfby5jO1xuICAgICAgcmV0dXJuIF9vO1xuICAgIH1cblxuICAgIHZhciBfcG9pbnRzID0gcG9pbnRzKGRhdGEsIHgsIHkpLFxuICAgICAgICBfcG9pbnRzMiA9IF9zbGljZWRUb0FycmF5KF9wb2ludHMsIDQpLFxuICAgICAgICB4diA9IF9wb2ludHMyWzBdLFxuICAgICAgICB5diA9IF9wb2ludHMyWzFdLFxuICAgICAgICB1eCA9IF9wb2ludHMyWzJdLFxuICAgICAgICB1eSA9IF9wb2ludHMyWzNdLFxuICAgICAgICBuID0geHYubGVuZ3RoLFxuICAgICAgICBsaHMgPSBbXSxcbiAgICAgICAgcmhzID0gW10sXG4gICAgICAgIGsgPSBvcmRlciArIDE7XG5cbiAgICB2YXIgWSA9IDAsXG4gICAgICAgIG4wID0gMCxcbiAgICAgICAgeG1pbiA9IGRvbWFpbiA/ICtkb21haW5bMF0gOiBJbmZpbml0eSxcbiAgICAgICAgeG1heCA9IGRvbWFpbiA/ICtkb21haW5bMV0gOiAtSW5maW5pdHk7XG4gICAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgKytuMDtcbiAgICAgIFkgKz0gKGR5IC0gWSkgLyBuMDtcblxuICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgaWYgKGR4IDwgeG1pbikgeG1pbiA9IGR4O1xuICAgICAgICBpZiAoZHggPiB4bWF4KSB4bWF4ID0gZHg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGksIGosIGwsIHYsIGM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgazsgKytpKSB7XG4gICAgICBmb3IgKGwgPSAwLCB2ID0gMDsgbCA8IG47ICsrbCkge1xuICAgICAgICB2ICs9IE1hdGgucG93KHh2W2xdLCBpKSAqIHl2W2xdO1xuICAgICAgfVxuXG4gICAgICBsaHMucHVzaCh2KTtcbiAgICAgIGMgPSBuZXcgRmxvYXQ2NEFycmF5KGspO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgazsgKytqKSB7XG4gICAgICAgIGZvciAobCA9IDAsIHYgPSAwOyBsIDwgbjsgKytsKSB7XG4gICAgICAgICAgdiArPSBNYXRoLnBvdyh4dltsXSwgaSArIGopO1xuICAgICAgICB9XG5cbiAgICAgICAgY1tqXSA9IHY7XG4gICAgICB9XG5cbiAgICAgIHJocy5wdXNoKGMpO1xuICAgIH1cblxuICAgIHJocy5wdXNoKGxocyk7XG5cbiAgICB2YXIgY29lZiA9IGdhdXNzaWFuRWxpbWluYXRpb24ocmhzKSxcbiAgICAgICAgZm4gPSBmdW5jdGlvbiBmbih4KSB7XG4gICAgICB4IC09IHV4O1xuICAgICAgdmFyIHkgPSB1eSArIGNvZWZbMF0gKyBjb2VmWzFdICogeCArIGNvZWZbMl0gKiB4ICogeDtcblxuICAgICAgZm9yIChpID0gMzsgaSA8IGs7ICsraSkge1xuICAgICAgICB5ICs9IGNvZWZbaV0gKiBNYXRoLnBvdyh4LCBpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHk7XG4gICAgfSxcbiAgICAgICAgb3V0ID0gaW50ZXJwb3NlKHhtaW4sIHhtYXgsIGZuKTtcblxuICAgIG91dC5jb2VmZmljaWVudHMgPSB1bmNlbnRlcihrLCBjb2VmLCAtdXgsIHV5KTtcbiAgICBvdXQucHJlZGljdCA9IGZuO1xuICAgIG91dC5yU3F1YXJlZCA9IGRldGVybWluYXRpb24oZGF0YSwgeCwgeSwgWSwgZm4pO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBwb2x5bm9taWFsLmRvbWFpbiA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBhcnIsIHBvbHlub21pYWwpIDogZG9tYWluO1xuICB9O1xuXG4gIHBvbHlub21pYWwueCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSBmbiwgcG9seW5vbWlhbCkgOiB4O1xuICB9O1xuXG4gIHBvbHlub21pYWwueSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBmbiwgcG9seW5vbWlhbCkgOiB5O1xuICB9O1xuXG4gIHBvbHlub21pYWwub3JkZXIgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9yZGVyID0gbiwgcG9seW5vbWlhbCkgOiBvcmRlcjtcbiAgfTtcblxuICByZXR1cm4gcG9seW5vbWlhbDtcbn1cblxuZnVuY3Rpb24gdW5jZW50ZXIoaywgYSwgeCwgeSkge1xuICB2YXIgeiA9IEFycmF5KGspO1xuICB2YXIgaSwgaiwgdiwgYzsgLy8gaW5pdGlhbGl6ZSB0byB6ZXJvXG5cbiAgZm9yIChpID0gMDsgaSA8IGs7ICsraSkge1xuICAgIHpbaV0gPSAwO1xuICB9IC8vIHBvbHlub21pYWwgZXhwYW5zaW9uXG5cblxuICBmb3IgKGkgPSBrIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2ID0gYVtpXTtcbiAgICBjID0gMTtcbiAgICB6W2ldICs9IHY7XG5cbiAgICBmb3IgKGogPSAxOyBqIDw9IGk7ICsraikge1xuICAgICAgYyAqPSAoaSArIDEgLSBqKSAvIGo7IC8vIGJpbm9taWFsIGNvZWZmaWNlbnRcblxuICAgICAgeltpIC0gal0gKz0gdiAqIE1hdGgucG93KHgsIGopICogYztcbiAgICB9XG4gIH0gLy8gYmlhcyB0ZXJtXG5cblxuICB6WzBdICs9IHk7XG4gIHJldHVybiB6O1xufSAvLyBHaXZlbiBhbiBhcnJheSBmb3IgYSB0d28tZGltZW5zaW9uYWwgbWF0cml4IGFuZCB0aGUgcG9seW5vbWlhbCBvcmRlcixcbi8vIHNvbHZlIEEgKiB4ID0gYiB1c2luZyBHYXVzc2lhbiBlbGltaW5hdGlvbi5cblxuXG5mdW5jdGlvbiBnYXVzc2lhbkVsaW1pbmF0aW9uKG1hdHJpeCkge1xuICB2YXIgbiA9IG1hdHJpeC5sZW5ndGggLSAxLFxuICAgICAgY29lZiA9IFtdO1xuICB2YXIgaSwgaiwgaywgciwgdDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgciA9IGk7IC8vIG1heCByb3dcblxuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICBpZiAoTWF0aC5hYnMobWF0cml4W2ldW2pdKSA+IE1hdGguYWJzKG1hdHJpeFtpXVtyXSkpIHtcbiAgICAgICAgciA9IGo7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrID0gaTsgayA8IG4gKyAxOyArK2spIHtcbiAgICAgIHQgPSBtYXRyaXhba11baV07XG4gICAgICBtYXRyaXhba11baV0gPSBtYXRyaXhba11bcl07XG4gICAgICBtYXRyaXhba11bcl0gPSB0O1xuICAgIH1cblxuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICBmb3IgKGsgPSBuOyBrID49IGk7IGstLSkge1xuICAgICAgICBtYXRyaXhba11bal0gLT0gbWF0cml4W2tdW2ldICogbWF0cml4W2ldW2pdIC8gbWF0cml4W2ldW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoaiA9IG4gLSAxOyBqID49IDA7IC0taikge1xuICAgIHQgPSAwO1xuXG4gICAgZm9yIChrID0gaiArIDE7IGsgPCBuOyArK2spIHtcbiAgICAgIHQgKz0gbWF0cml4W2tdW2pdICogY29lZltrXTtcbiAgICB9XG5cbiAgICBjb2VmW2pdID0gKG1hdHJpeFtuXVtqXSAtIHQpIC8gbWF0cml4W2pdW2pdO1xuICB9XG5cbiAgcmV0dXJuIGNvZWY7XG59XG5cbmZ1bmN0aW9uIHBvd2VyICgpIHtcbiAgdmFyIHggPSBmdW5jdGlvbiB4KGQpIHtcbiAgICByZXR1cm4gZFswXTtcbiAgfSxcbiAgICAgIHkgPSBmdW5jdGlvbiB5KGQpIHtcbiAgICByZXR1cm4gZFsxXTtcbiAgfSxcbiAgICAgIGRvbWFpbjtcblxuICBmdW5jdGlvbiBwb3dlcihkYXRhKSB7XG4gICAgdmFyIG4gPSAwLFxuICAgICAgICBYID0gMCxcbiAgICAgICAgWSA9IDAsXG4gICAgICAgIFhZID0gMCxcbiAgICAgICAgWDIgPSAwLFxuICAgICAgICBZUyA9IDAsXG4gICAgICAgIHhtaW4gPSBkb21haW4gPyArZG9tYWluWzBdIDogSW5maW5pdHksXG4gICAgICAgIHhtYXggPSBkb21haW4gPyArZG9tYWluWzFdIDogLUluZmluaXR5O1xuICAgIHZpc2l0UG9pbnRzKGRhdGEsIHgsIHksIGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICAgIHZhciBseCA9IE1hdGgubG9nKGR4KSxcbiAgICAgICAgICBseSA9IE1hdGgubG9nKGR5KTtcbiAgICAgICsrbjtcbiAgICAgIFggKz0gKGx4IC0gWCkgLyBuO1xuICAgICAgWSArPSAobHkgLSBZKSAvIG47XG4gICAgICBYWSArPSAobHggKiBseSAtIFhZKSAvIG47XG4gICAgICBYMiArPSAobHggKiBseCAtIFgyKSAvIG47XG4gICAgICBZUyArPSAoZHkgLSBZUykgLyBuO1xuXG4gICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICBpZiAoZHggPCB4bWluKSB4bWluID0gZHg7XG4gICAgICAgIGlmIChkeCA+IHhtYXgpIHhtYXggPSBkeDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBfb2xzID0gb2xzKFgsIFksIFhZLCBYMiksXG4gICAgICAgIF9vbHMyID0gX3NsaWNlZFRvQXJyYXkoX29scywgMiksXG4gICAgICAgIGEgPSBfb2xzMlswXSxcbiAgICAgICAgYiA9IF9vbHMyWzFdO1xuXG4gICAgYSA9IE1hdGguZXhwKGEpO1xuXG4gICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oeCkge1xuICAgICAgcmV0dXJuIGEgKiBNYXRoLnBvdyh4LCBiKTtcbiAgICB9LFxuICAgICAgICBvdXQgPSBpbnRlcnBvc2UoeG1pbiwgeG1heCwgZm4pO1xuXG4gICAgb3V0LmEgPSBhO1xuICAgIG91dC5iID0gYjtcbiAgICBvdXQucHJlZGljdCA9IGZuO1xuICAgIG91dC5yU3F1YXJlZCA9IGRldGVybWluYXRpb24oZGF0YSwgeCwgeSwgWVMsIGZuKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgcG93ZXIuZG9tYWluID0gZnVuY3Rpb24gKGFycikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IGFyciwgcG93ZXIpIDogZG9tYWluO1xuICB9O1xuXG4gIHBvd2VyLnggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gZm4sIHBvd2VyKSA6IHg7XG4gIH07XG5cbiAgcG93ZXIueSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBmbiwgcG93ZXIpIDogeTtcbiAgfTtcblxuICByZXR1cm4gcG93ZXI7XG59XG5cbmV4cG9ydCB7IGV4cG9uZW50aWFsIGFzIHJlZ3Jlc3Npb25FeHAsIGxpbmVhciBhcyByZWdyZXNzaW9uTGluZWFyLCBsb2VzcyBhcyByZWdyZXNzaW9uTG9lc3MsIGxvZ2FyaXRobWljIGFzIHJlZ3Jlc3Npb25Mb2csIHBvbHlub21pYWwgYXMgcmVncmVzc2lvblBvbHksIHBvd2VyIGFzIHJlZ3Jlc3Npb25Qb3csIHF1YWQgYXMgcmVncmVzc2lvblF1YWQgfTtcbiJdLCJuYW1lcyI6WyJfc2xpY2VkVG9BcnJheSIsImFyciIsImkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfbm9uSXRlcmFibGVSZXN0IiwiQXJyYXkiLCJpc0FycmF5IiwiX2FyciIsIl9uIiwiX2QiLCJfZSIsInVuZGVmaW5lZCIsIl9pIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfcyIsIm5leHQiLCJkb25lIiwicHVzaCIsInZhbHVlIiwibGVuZ3RoIiwiZXJyIiwiVHlwZUVycm9yIiwicG9pbnRzIiwiZGF0YSIsIngiLCJ5Iiwic29ydCIsImZpbHRlciIsImQiLCJ1IiwidiIsImlzRmluaXRlIiwiYSIsImIiLCJuIiwiWCIsIkZsb2F0NjRBcnJheSIsIlkiLCJ1eCIsInV5IiwieHYiLCJ5diIsInZpc2l0UG9pbnRzIiwiY2IiLCJpdGVyYXRpb25zIiwiZHgiLCJkeSIsImRldGVybWluYXRpb24iLCJ1WSIsInByZWRpY3QiLCJTU0UiLCJTU1QiLCJzc2UiLCJzc3QiLCJhbmdsZSIsImxpbmUiLCJNYXRoIiwiYXRhbjIiLCJQSSIsIm1pZHBvaW50IiwiaW50ZXJwb3NlIiwieG1pbiIsInhtYXgiLCJsIiwibG9nIiwiTE9HMTBFIiwicHJlY2lzaW9uIiwicG93IiwibWF4SXRlciIsInB4IiwiaXRlciIsImZpbmQiLCJmb3VuZCIsInAwIiwicDEiLCJtIiwibXAiLCJhMCIsImExIiwiYWJzIiwic3BsaWNlIiwib2xzIiwidVgiLCJ1WFkiLCJ1WDIiLCJkZWx0YSIsInNsb3BlIiwiaW50ZXJjZXB0IiwiZXhwb25lbnRpYWwiLCJkb21haW4iLCJZTCIsIlhZIiwiWFlMIiwiWDJZIiwiSW5maW5pdHkiLCJseSIsInh5IiwiX29scyIsIl9vbHMyIiwiZXhwIiwiZm4iLCJvdXQiLCJyU3F1YXJlZCIsImFyZ3VtZW50cyIsImxpbmVhciIsIlgyIiwibWVkaWFuIiwiZmxvb3IiLCJtYXhpdGVycyIsImVwc2lsb24iLCJsb2VzcyIsImJhbmR3aWR0aCIsIl9wb2ludHMiLCJfcG9pbnRzMiIsImJ3IiwibWF4IiwieWhhdCIsInJlc2lkdWFscyIsInJvYnVzdFdlaWdodHMiLCJmaWxsIiwiaW50ZXJ2YWwiLCJpMCIsImkxIiwiZWRnZSIsIlciLCJkZW5vbSIsImsiLCJ4ayIsInlrIiwidyIsInRyaWN1YmUiLCJ4a3ciLCJ1cGRhdGVJbnRlcnZhbCIsIm1lZGlhblJlc2lkdWFsIiwiYXJnIiwiX3ciLCJvdXRwdXQiLCJ2YWwiLCJsZWZ0IiwicmlnaHQiLCJjbnQiLCJwcmV2IiwibG9nYXJpdGhtaWMiLCJiYXNlIiwiRSIsImxiIiwibHgiLCJxdWFkIiwicXVhZHJhdGljIiwiWDMiLCJYNCIsIngyIiwibjAiLCJYMlgyIiwiYyIsInBvbHlub21pYWwiLCJvcmRlciIsIm8iLCJjb2VmZmljaWVudHMiLCJfbyIsImxocyIsInJocyIsImoiLCJjb2VmIiwiZ2F1c3NpYW5FbGltaW5hdGlvbiIsInVuY2VudGVyIiwieiIsIm1hdHJpeCIsInIiLCJ0IiwicG93ZXIiLCJZUyIsInJlZ3Jlc3Npb25FeHAiLCJyZWdyZXNzaW9uTGluZWFyIiwicmVncmVzc2lvbkxvZXNzIiwicmVncmVzc2lvbkxvZyIsInJlZ3Jlc3Npb25Qb2x5IiwicmVncmVzc2lvblBvdyIsInJlZ3Jlc3Npb25RdWFkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/d3-regression/dist/d3-regression.esm.js\n");

/***/ })

};
;