/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fmin";
exports.ids = ["vendor-chunks/fmin"];
exports.modules = {

/***/ "(ssr)/./node_modules/fmin/build/fmin.js":
/*!*****************************************!*\
  !*** ./node_modules/fmin/build/fmin.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    /** finds the zeros of a function, given two starting points (which must\n     * have opposite signs */ function bisect(f, a, b, parameters) {\n        parameters = parameters || {};\n        var maxIterations = parameters.maxIterations || 100, tolerance = parameters.tolerance || 1e-10, fA = f(a), fB = f(b), delta = b - a;\n        if (fA * fB > 0) {\n            throw \"Initial bisect points must have opposite signs\";\n        }\n        if (fA === 0) return a;\n        if (fB === 0) return b;\n        for(var i = 0; i < maxIterations; ++i){\n            delta /= 2;\n            var mid = a + delta, fMid = f(mid);\n            if (fMid * fA >= 0) {\n                a = mid;\n            }\n            if (Math.abs(delta) < tolerance || fMid === 0) {\n                return mid;\n            }\n        }\n        return a + delta;\n    }\n    // need some basic operations on vectors, rather than adding a dependency,\n    // just define here\n    function zeros(x) {\n        var r = new Array(x);\n        for(var i = 0; i < x; ++i){\n            r[i] = 0;\n        }\n        return r;\n    }\n    function zerosM(x, y) {\n        return zeros(x).map(function() {\n            return zeros(y);\n        });\n    }\n    function dot(a, b) {\n        var ret = 0;\n        for(var i = 0; i < a.length; ++i){\n            ret += a[i] * b[i];\n        }\n        return ret;\n    }\n    function norm2(a) {\n        return Math.sqrt(dot(a, a));\n    }\n    function scale(ret, value, c) {\n        for(var i = 0; i < value.length; ++i){\n            ret[i] = value[i] * c;\n        }\n    }\n    function weightedSum(ret, w1, v1, w2, v2) {\n        for(var j = 0; j < ret.length; ++j){\n            ret[j] = w1 * v1[j] + w2 * v2[j];\n        }\n    }\n    /** minimizes a function using the downhill simplex method */ function nelderMead(f, x0, parameters) {\n        parameters = parameters || {};\n        var maxIterations = parameters.maxIterations || x0.length * 200, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || 0.001, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = parameters.rho !== undefined ? parameters.rho : 1, chi = parameters.chi !== undefined ? parameters.chi : 2, psi = parameters.psi !== undefined ? parameters.psi : -0.5, sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5, maxDiff;\n        // initialize simplex.\n        var N = x0.length, simplex = new Array(N + 1);\n        simplex[0] = x0;\n        simplex[0].fx = f(x0);\n        simplex[0].id = 0;\n        for(var i = 0; i < N; ++i){\n            var point = x0.slice();\n            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n            simplex[i + 1] = point;\n            simplex[i + 1].fx = f(point);\n            simplex[i + 1].id = i + 1;\n        }\n        function updateSimplex(value) {\n            for(var i = 0; i < value.length; i++){\n                simplex[N][i] = value[i];\n            }\n            simplex[N].fx = value.fx;\n        }\n        var sortOrder = function(a, b) {\n            return a.fx - b.fx;\n        };\n        var centroid = x0.slice(), reflected = x0.slice(), contracted = x0.slice(), expanded = x0.slice();\n        for(var iteration = 0; iteration < maxIterations; ++iteration){\n            simplex.sort(sortOrder);\n            if (parameters.history) {\n                // copy the simplex (since later iterations will mutate) and\n                // sort it to have a consistent order between iterations\n                var sortedSimplex = simplex.map(function(x) {\n                    var state = x.slice();\n                    state.fx = x.fx;\n                    state.id = x.id;\n                    return state;\n                });\n                sortedSimplex.sort(function(a, b) {\n                    return a.id - b.id;\n                });\n                parameters.history.push({\n                    x: simplex[0].slice(),\n                    fx: simplex[0].fx,\n                    simplex: sortedSimplex\n                });\n            }\n            maxDiff = 0;\n            for(i = 0; i < N; ++i){\n                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n            }\n            if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {\n                break;\n            }\n            // compute the centroid of all but the worst point in the simplex\n            for(i = 0; i < N; ++i){\n                centroid[i] = 0;\n                for(var j = 0; j < N; ++j){\n                    centroid[i] += simplex[j][i];\n                }\n                centroid[i] /= N;\n            }\n            // reflect the worst point past the centroid  and compute loss at reflected\n            // point\n            var worst = simplex[N];\n            weightedSum(reflected, 1 + rho, centroid, -rho, worst);\n            reflected.fx = f(reflected);\n            // if the reflected point is the best seen, then possibly expand\n            if (reflected.fx < simplex[0].fx) {\n                weightedSum(expanded, 1 + chi, centroid, -chi, worst);\n                expanded.fx = f(expanded);\n                if (expanded.fx < reflected.fx) {\n                    updateSimplex(expanded);\n                } else {\n                    updateSimplex(reflected);\n                }\n            } else if (reflected.fx >= simplex[N - 1].fx) {\n                var shouldReduce = false;\n                if (reflected.fx > worst.fx) {\n                    // do an inside contraction\n                    weightedSum(contracted, 1 + psi, centroid, -psi, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < worst.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                } else {\n                    // do an outside contraction\n                    weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < reflected.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                }\n                if (shouldReduce) {\n                    // if we don't contract here, we're done\n                    if (sigma >= 1) break;\n                    // do a reduction\n                    for(i = 1; i < simplex.length; ++i){\n                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                        simplex[i].fx = f(simplex[i]);\n                    }\n                }\n            } else {\n                updateSimplex(reflected);\n            }\n        }\n        simplex.sort(sortOrder);\n        return {\n            fx: simplex[0].fx,\n            x: simplex[0]\n        };\n    }\n    /// searches along line 'pk' for a point that satifies the wolfe conditions\n    /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n    /// f : objective function\n    /// pk : search direction\n    /// current: object containing current gradient/loss\n    /// next: output: contains next gradient/loss\n    /// returns a: step size taken\n    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk), phi = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;\n        a = a || 1;\n        c1 = c1 || 1e-6;\n        c2 = c2 || 0.1;\n        function zoom(a_lo, a_high, phi_lo) {\n            for(var iteration = 0; iteration < 16; ++iteration){\n                a = (a_lo + a_high) / 2;\n                weightedSum(next.x, 1.0, current.x, a, pk);\n                phi = next.fx = f(next.x, next.fxprime);\n                phiPrime = dot(next.fxprime, pk);\n                if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {\n                    a_high = a;\n                } else {\n                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                        return a;\n                    }\n                    if (phiPrime * (a_high - a_lo) >= 0) {\n                        a_high = a_lo;\n                    }\n                    a_lo = a;\n                    phi_lo = phi;\n                }\n            }\n            return 0;\n        }\n        for(var iteration = 0; iteration < 10; ++iteration){\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n            if (phi > phi0 + c1 * a * phiPrime0 || iteration && phi >= phi_old) {\n                return zoom(a0, a, phi_old);\n            }\n            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                return a;\n            }\n            if (phiPrime >= 0) {\n                return zoom(a, a0, phi);\n            }\n            phi_old = phi;\n            a0 = a;\n            a *= 2;\n        }\n        return a;\n    }\n    function conjugateGradient(f, initial, params) {\n        // allocate all memory up front here, keep out of the loop for perfomance\n        // reasons\n        var current = {\n            x: initial.slice(),\n            fx: 0,\n            fxprime: initial.slice()\n        }, next = {\n            x: initial.slice(),\n            fx: 0,\n            fxprime: initial.slice()\n        }, yk = initial.slice(), pk, temp, a = 1, maxIterations;\n        params = params || {};\n        maxIterations = params.maxIterations || initial.length * 20;\n        current.fx = f(current.x, current.fxprime);\n        pk = current.fxprime.slice();\n        scale(pk, current.fxprime, -1);\n        for(var i = 0; i < maxIterations; ++i){\n            a = wolfeLineSearch(f, pk, current, next, a);\n            // todo: history in wrong spot?\n            if (params.history) {\n                params.history.push({\n                    x: current.x.slice(),\n                    fx: current.fx,\n                    fxprime: current.fxprime.slice(),\n                    alpha: a\n                });\n            }\n            if (!a) {\n                // faiiled to find point that satifies wolfe conditions.\n                // reset direction for next iteration\n                scale(pk, current.fxprime, -1);\n            } else {\n                // update direction using Polakâ€“Ribiere CG method\n                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n                var delta_k = dot(current.fxprime, current.fxprime), beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n                weightedSum(pk, beta_k, pk, -1, next.fxprime);\n                temp = current;\n                current = next;\n                next = temp;\n            }\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n        if (params.history) {\n            params.history.push({\n                x: current.x.slice(),\n                fx: current.fx,\n                fxprime: current.fxprime.slice(),\n                alpha: a\n            });\n        }\n        return current;\n    }\n    function gradientDescent(f, initial, params) {\n        params = params || {};\n        var maxIterations = params.maxIterations || initial.length * 100, learnRate = params.learnRate || 0.001, current = {\n            x: initial.slice(),\n            fx: 0,\n            fxprime: initial.slice()\n        };\n        for(var i = 0; i < maxIterations; ++i){\n            current.fx = f(current.x, current.fxprime);\n            if (params.history) {\n                params.history.push({\n                    x: current.x.slice(),\n                    fx: current.fx,\n                    fxprime: current.fxprime.slice()\n                });\n            }\n            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n        return current;\n    }\n    function gradientDescentLineSearch(f, initial, params) {\n        params = params || {};\n        var current = {\n            x: initial.slice(),\n            fx: 0,\n            fxprime: initial.slice()\n        }, next = {\n            x: initial.slice(),\n            fx: 0,\n            fxprime: initial.slice()\n        }, maxIterations = params.maxIterations || initial.length * 100, learnRate = params.learnRate || 1, pk = initial.slice(), c1 = params.c1 || 1e-3, c2 = params.c2 || 0.1, temp, functionCalls = [];\n        if (params.history) {\n            // wrap the function call to track linesearch samples\n            var inner = f;\n            f = function(x, fxprime) {\n                functionCalls.push(x.slice());\n                return inner(x, fxprime);\n            };\n        }\n        current.fx = f(current.x, current.fxprime);\n        for(var i = 0; i < maxIterations; ++i){\n            scale(pk, current.fxprime, -1);\n            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);\n            if (params.history) {\n                params.history.push({\n                    x: current.x.slice(),\n                    fx: current.fx,\n                    fxprime: current.fxprime.slice(),\n                    functionCalls: functionCalls,\n                    learnRate: learnRate,\n                    alpha: learnRate\n                });\n                functionCalls = [];\n            }\n            temp = current;\n            current = next;\n            next = temp;\n            if (learnRate === 0 || norm2(current.fxprime) < 1e-5) break;\n        }\n        return current;\n    }\n    exports1.bisect = bisect;\n    exports1.nelderMead = nelderMead;\n    exports1.conjugateGradient = conjugateGradient;\n    exports1.gradientDescent = gradientDescent;\n    exports1.gradientDescentLineSearch = gradientDescentLineSearch;\n    exports1.zeros = zeros;\n    exports1.zerosM = zerosM;\n    exports1.norm2 = norm2;\n    exports1.weightedSum = weightedSum;\n    exports1.scale = scale;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm1pbi9idWlsZC9mbWluLmpzIiwibWFwcGluZ3MiOiJBQUFDLFVBQVVBLE1BQU0sRUFBRUMsT0FBTztJQUN0QixLQUFpRCxHQUFjQSxRQUFRQyxXQUN2RSxDQUMwQztBQUM5QyxHQUFFLElBQUksRUFBRSxTQUFVQSxRQUFPO0lBQUk7SUFFekI7MkJBQ3VCLEdBQ3ZCLFNBQVNLLE9BQU9DLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLFVBQVU7UUFDL0JBLGFBQWFBLGNBQWMsQ0FBQztRQUM1QixJQUFJQyxnQkFBZ0JELFdBQVdDLGFBQWEsSUFBSSxLQUM1Q0MsWUFBWUYsV0FBV0UsU0FBUyxJQUFJLE9BQ3BDQyxLQUFLTixFQUFFQyxJQUNQTSxLQUFLUCxFQUFFRSxJQUNQTSxRQUFRTixJQUFJRDtRQUVoQixJQUFJSyxLQUFLQyxLQUFLLEdBQUc7WUFDYixNQUFNO1FBQ1Y7UUFFQSxJQUFJRCxPQUFPLEdBQUcsT0FBT0w7UUFDckIsSUFBSU0sT0FBTyxHQUFHLE9BQU9MO1FBRXJCLElBQUssSUFBSU8sSUFBSSxHQUFHQSxJQUFJTCxlQUFlLEVBQUVLLEVBQUc7WUFDcENELFNBQVM7WUFDVCxJQUFJRSxNQUFNVCxJQUFJTyxPQUNWRyxPQUFPWCxFQUFFVTtZQUViLElBQUlDLE9BQU9MLE1BQU0sR0FBRztnQkFDaEJMLElBQUlTO1lBQ1I7WUFFQSxJQUFJLEtBQU1HLEdBQUcsQ0FBQ0wsU0FBU0gsYUFBZU0sU0FBUyxHQUFJO2dCQUMvQyxPQUFPRDtZQUNYO1FBQ0o7UUFDQSxPQUFPVCxJQUFJTztJQUNmO0lBRUEsMEVBQTBFO0lBQzFFLG1CQUFtQjtJQUNuQixTQUFTTSxNQUFNQyxDQUFDO1FBQUksSUFBSUMsSUFBSSxJQUFJQyxNQUFNRjtRQUFJLElBQUssSUFBSU4sSUFBSSxHQUFHQSxJQUFJTSxHQUFHLEVBQUVOLEVBQUc7WUFBRU8sQ0FBQyxDQUFDUCxFQUFFLEdBQUc7UUFBRztRQUFFLE9BQU9PO0lBQUc7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QUFRTSxPQUFPLEVBQUUsQ0FBQztZQUM1QmtCLFlBQVkxQixnQkFBZ0JwRSxHQUFHcUUsSUFBSUMsU0FBU0MsTUFBTXVCLFdBQVd0QixJQUFJQztZQUVqRSxJQUFJYyxPQUFPMUIsT0FBTyxFQUFFO2dCQUNoQjBCLE9BQU8xQixPQUFPLENBQUNHLElBQUksQ0FBQztvQkFBQ2pELEdBQUd1RCxRQUFRdkQsQ0FBQyxDQUFDcUMsS0FBSztvQkFDbEJILElBQUlxQixRQUFRckIsRUFBRTtvQkFDZDJCLFNBQVNOLFFBQVFNLE9BQU8sQ0FBQ3hCLEtBQUs7b0JBQzlCNEMsZUFBZUE7b0JBQ2ZGLFdBQVdBO29CQUNYSixPQUFPSTtnQkFBUztnQkFDckNFLGdCQUFnQixFQUFFO1lBQ3RCO1lBR0FQLE9BQU9uQjtZQUNQQSxVQUFVQztZQUNWQSxPQUFPa0I7WUFFUCxJQUFJLGNBQWUsS0FBT2pFLE1BQU04QyxRQUFRTSxPQUFPLElBQUksTUFBTztRQUM5RDtRQUVBLE9BQU9OO0lBQ1g7SUFFQTVFLFNBQVFLLE1BQU0sR0FBR0E7SUFDakJMLFNBQVF5QyxVQUFVLEdBQUdBO0lBQ3JCekMsU0FBUTJGLGlCQUFpQixHQUFHQTtJQUM1QjNGLFNBQVFtRyxlQUFlLEdBQUdBO0lBQzFCbkcsU0FBUXFHLHlCQUF5QixHQUFHQTtJQUNwQ3JHLFNBQVFvQixLQUFLLEdBQUdBO0lBQ2hCcEIsU0FBUXdCLE1BQU0sR0FBR0E7SUFDakJ4QixTQUFROEIsS0FBSyxHQUFHQTtJQUNoQjlCLFNBQVFtQyxXQUFXLEdBQUdBO0lBQ3RCbkMsU0FBUWdDLEtBQUssR0FBR0E7QUFFcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm1pbi9idWlsZC9mbWluLmpzP2U2YjQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLmZtaW4gPSBnbG9iYWwuZm1pbiB8fCB7fSkpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqIGZpbmRzIHRoZSB6ZXJvcyBvZiBhIGZ1bmN0aW9uLCBnaXZlbiB0d28gc3RhcnRpbmcgcG9pbnRzICh3aGljaCBtdXN0XG4gICAgICogaGF2ZSBvcHBvc2l0ZSBzaWducyAqL1xuICAgIGZ1bmN0aW9uIGJpc2VjdChmLCBhLCBiLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuICAgICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IHBhcmFtZXRlcnMubWF4SXRlcmF0aW9ucyB8fCAxMDAsXG4gICAgICAgICAgICB0b2xlcmFuY2UgPSBwYXJhbWV0ZXJzLnRvbGVyYW5jZSB8fCAxZS0xMCxcbiAgICAgICAgICAgIGZBID0gZihhKSxcbiAgICAgICAgICAgIGZCID0gZihiKSxcbiAgICAgICAgICAgIGRlbHRhID0gYiAtIGE7XG5cbiAgICAgICAgaWYgKGZBICogZkIgPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkluaXRpYWwgYmlzZWN0IHBvaW50cyBtdXN0IGhhdmUgb3Bwb3NpdGUgc2lnbnNcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmQSA9PT0gMCkgcmV0dXJuIGE7XG4gICAgICAgIGlmIChmQiA9PT0gMCkgcmV0dXJuIGI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhJdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIGRlbHRhIC89IDI7XG4gICAgICAgICAgICB2YXIgbWlkID0gYSArIGRlbHRhLFxuICAgICAgICAgICAgICAgIGZNaWQgPSBmKG1pZCk7XG5cbiAgICAgICAgICAgIGlmIChmTWlkICogZkEgPj0gMCkge1xuICAgICAgICAgICAgICAgIGEgPSBtaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnMoZGVsdGEpIDwgdG9sZXJhbmNlKSB8fCAoZk1pZCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhICsgZGVsdGE7XG4gICAgfVxuXG4gICAgLy8gbmVlZCBzb21lIGJhc2ljIG9wZXJhdGlvbnMgb24gdmVjdG9ycywgcmF0aGVyIHRoYW4gYWRkaW5nIGEgZGVwZW5kZW5jeSxcbiAgICAvLyBqdXN0IGRlZmluZSBoZXJlXG4gICAgZnVuY3Rpb24gemVyb3MoeCkgeyB2YXIgciA9IG5ldyBBcnJheSh4KTsgZm9yICh2YXIgaSA9IDA7IGkgPCB4OyArK2kpIHsgcltpXSA9IDA7IH0gcmV0dXJuIHI7IH1cbiAgICBmdW5jdGlvbiB6ZXJvc00oeCx5KSB7IHJldHVybiB6ZXJvcyh4KS5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiB6ZXJvcyh5KTsgfSk7IH1cblxuICAgIGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgICAgIHZhciByZXQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJldCArPSBhW2ldICogYltpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm0yKGEpICB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZG90KGEsIGEpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZShyZXQsIHZhbHVlLCBjKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHZhbHVlW2ldICogYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlaWdodGVkU3VtKHJldCwgdzEsIHYxLCB3MiwgdjIpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHJldFtqXSA9IHcxICogdjFbal0gKyB3MiAqIHYyW2pdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIG1pbmltaXplcyBhIGZ1bmN0aW9uIHVzaW5nIHRoZSBkb3duaGlsbCBzaW1wbGV4IG1ldGhvZCAqL1xuICAgIGZ1bmN0aW9uIG5lbGRlck1lYWQoZiwgeDAsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSBwYXJhbWV0ZXJzLm1heEl0ZXJhdGlvbnMgfHwgeDAubGVuZ3RoICogMjAwLFxuICAgICAgICAgICAgbm9uWmVyb0RlbHRhID0gcGFyYW1ldGVycy5ub25aZXJvRGVsdGEgfHwgMS4wNSxcbiAgICAgICAgICAgIHplcm9EZWx0YSA9IHBhcmFtZXRlcnMuemVyb0RlbHRhIHx8IDAuMDAxLFxuICAgICAgICAgICAgbWluRXJyb3JEZWx0YSA9IHBhcmFtZXRlcnMubWluRXJyb3JEZWx0YSB8fCAxZS02LFxuICAgICAgICAgICAgbWluVG9sZXJhbmNlID0gcGFyYW1ldGVycy5taW5FcnJvckRlbHRhIHx8IDFlLTUsXG4gICAgICAgICAgICByaG8gPSAocGFyYW1ldGVycy5yaG8gIT09IHVuZGVmaW5lZCkgPyBwYXJhbWV0ZXJzLnJobyA6IDEsXG4gICAgICAgICAgICBjaGkgPSAocGFyYW1ldGVycy5jaGkgIT09IHVuZGVmaW5lZCkgPyBwYXJhbWV0ZXJzLmNoaSA6IDIsXG4gICAgICAgICAgICBwc2kgPSAocGFyYW1ldGVycy5wc2kgIT09IHVuZGVmaW5lZCkgPyBwYXJhbWV0ZXJzLnBzaSA6IC0wLjUsXG4gICAgICAgICAgICBzaWdtYSA9IChwYXJhbWV0ZXJzLnNpZ21hICE9PSB1bmRlZmluZWQpID8gcGFyYW1ldGVycy5zaWdtYSA6IDAuNSxcbiAgICAgICAgICAgIG1heERpZmY7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBzaW1wbGV4LlxuICAgICAgICB2YXIgTiA9IHgwLmxlbmd0aCxcbiAgICAgICAgICAgIHNpbXBsZXggPSBuZXcgQXJyYXkoTiArIDEpO1xuICAgICAgICBzaW1wbGV4WzBdID0geDA7XG4gICAgICAgIHNpbXBsZXhbMF0uZnggPSBmKHgwKTtcbiAgICAgICAgc2ltcGxleFswXS5pZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSB4MC5zbGljZSgpO1xuICAgICAgICAgICAgcG9pbnRbaV0gPSBwb2ludFtpXSA/IHBvaW50W2ldICogbm9uWmVyb0RlbHRhIDogemVyb0RlbHRhO1xuICAgICAgICAgICAgc2ltcGxleFtpKzFdID0gcG9pbnQ7XG4gICAgICAgICAgICBzaW1wbGV4W2krMV0uZnggPSBmKHBvaW50KTtcbiAgICAgICAgICAgIHNpbXBsZXhbaSsxXS5pZCA9IGkrMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNpbXBsZXgodmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzaW1wbGV4W05dW2ldID0gdmFsdWVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaW1wbGV4W05dLmZ4ID0gdmFsdWUuZng7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc29ydE9yZGVyID0gZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5meCAtIGIuZng7IH07XG5cbiAgICAgICAgdmFyIGNlbnRyb2lkID0geDAuc2xpY2UoKSxcbiAgICAgICAgICAgIHJlZmxlY3RlZCA9IHgwLnNsaWNlKCksXG4gICAgICAgICAgICBjb250cmFjdGVkID0geDAuc2xpY2UoKSxcbiAgICAgICAgICAgIGV4cGFuZGVkID0geDAuc2xpY2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zOyArK2l0ZXJhdGlvbikge1xuICAgICAgICAgICAgc2ltcGxleC5zb3J0KHNvcnRPcmRlcik7XG5cbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb3B5IHRoZSBzaW1wbGV4IChzaW5jZSBsYXRlciBpdGVyYXRpb25zIHdpbGwgbXV0YXRlKSBhbmRcbiAgICAgICAgICAgICAgICAvLyBzb3J0IGl0IHRvIGhhdmUgYSBjb25zaXN0ZW50IG9yZGVyIGJldHdlZW4gaXRlcmF0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBzb3J0ZWRTaW1wbGV4ID0gc2ltcGxleC5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0geC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5meCA9IHguZng7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlkID0geC5pZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNvcnRlZFNpbXBsZXguc29ydChmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuaGlzdG9yeS5wdXNoKHt4OiBzaW1wbGV4WzBdLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ4OiBzaW1wbGV4WzBdLmZ4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGV4OiBzb3J0ZWRTaW1wbGV4fSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1heERpZmYgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICAgICAgICAgIG1heERpZmYgPSBNYXRoLm1heChtYXhEaWZmLCBNYXRoLmFicyhzaW1wbGV4WzBdW2ldIC0gc2ltcGxleFsxXVtpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHNpbXBsZXhbMF0uZnggLSBzaW1wbGV4W05dLmZ4KSA8IG1pbkVycm9yRGVsdGEpICYmXG4gICAgICAgICAgICAgICAgKG1heERpZmYgPCBtaW5Ub2xlcmFuY2UpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbXB1dGUgdGhlIGNlbnRyb2lkIG9mIGFsbCBidXQgdGhlIHdvcnN0IHBvaW50IGluIHRoZSBzaW1wbGV4XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2VudHJvaWRbaV0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgTjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRyb2lkW2ldICs9IHNpbXBsZXhbal1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbnRyb2lkW2ldIC89IE47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlZmxlY3QgdGhlIHdvcnN0IHBvaW50IHBhc3QgdGhlIGNlbnRyb2lkICBhbmQgY29tcHV0ZSBsb3NzIGF0IHJlZmxlY3RlZFxuICAgICAgICAgICAgLy8gcG9pbnRcbiAgICAgICAgICAgIHZhciB3b3JzdCA9IHNpbXBsZXhbTl07XG4gICAgICAgICAgICB3ZWlnaHRlZFN1bShyZWZsZWN0ZWQsIDErcmhvLCBjZW50cm9pZCwgLXJobywgd29yc3QpO1xuICAgICAgICAgICAgcmVmbGVjdGVkLmZ4ID0gZihyZWZsZWN0ZWQpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVmbGVjdGVkIHBvaW50IGlzIHRoZSBiZXN0IHNlZW4sIHRoZW4gcG9zc2libHkgZXhwYW5kXG4gICAgICAgICAgICBpZiAocmVmbGVjdGVkLmZ4IDwgc2ltcGxleFswXS5meCkge1xuICAgICAgICAgICAgICAgIHdlaWdodGVkU3VtKGV4cGFuZGVkLCAxK2NoaSwgY2VudHJvaWQsIC1jaGksIHdvcnN0KTtcbiAgICAgICAgICAgICAgICBleHBhbmRlZC5meCA9IGYoZXhwYW5kZWQpO1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmRlZC5meCA8IHJlZmxlY3RlZC5meCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTaW1wbGV4KGV4cGFuZGVkKTtcbiAgICAgICAgICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2ltcGxleChyZWZsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIHJlZmxlY3RlZCBwb2ludCBpcyB3b3JzZSB0aGFuIHRoZSBzZWNvbmQgd29yc3QsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGNvbnRyYWN0XG4gICAgICAgICAgICBlbHNlIGlmIChyZWZsZWN0ZWQuZnggPj0gc2ltcGxleFtOLTFdLmZ4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZFJlZHVjZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlZmxlY3RlZC5meCA+IHdvcnN0LmZ4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIGFuIGluc2lkZSBjb250cmFjdGlvblxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRlZFN1bShjb250cmFjdGVkLCAxK3BzaSwgY2VudHJvaWQsIC1wc2ksIHdvcnN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RlZC5meCA9IGYoY29udHJhY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cmFjdGVkLmZ4IDwgd29yc3QuZngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNpbXBsZXgoY29udHJhY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRSZWR1Y2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gYW4gb3V0c2lkZSBjb250cmFjdGlvblxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRlZFN1bShjb250cmFjdGVkLCAxLXBzaSAqIHJobywgY2VudHJvaWQsIHBzaSpyaG8sIHdvcnN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RlZC5meCA9IGYoY29udHJhY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cmFjdGVkLmZ4IDwgcmVmbGVjdGVkLmZ4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTaW1wbGV4KGNvbnRyYWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVkdWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZWR1Y2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgY29udHJhY3QgaGVyZSwgd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbWEgPj0gMSkgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gYSByZWR1Y3Rpb25cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHNpbXBsZXgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodGVkU3VtKHNpbXBsZXhbaV0sIDEgLSBzaWdtYSwgc2ltcGxleFswXSwgc2lnbWEsIHNpbXBsZXhbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxleFtpXS5meCA9IGYoc2ltcGxleFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVNpbXBsZXgocmVmbGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNpbXBsZXguc29ydChzb3J0T3JkZXIpO1xuICAgICAgICByZXR1cm4ge2Z4IDogc2ltcGxleFswXS5meCxcbiAgICAgICAgICAgICAgICB4IDogc2ltcGxleFswXX07XG4gICAgfVxuXG4gICAgLy8vIHNlYXJjaGVzIGFsb25nIGxpbmUgJ3BrJyBmb3IgYSBwb2ludCB0aGF0IHNhdGlmaWVzIHRoZSB3b2xmZSBjb25kaXRpb25zXG4gICAgLy8vIFNlZSAnTnVtZXJpY2FsIE9wdGltaXphdGlvbicgYnkgTm9jZWRhbCBhbmQgV3JpZ2h0IHA1OS02MFxuICAgIC8vLyBmIDogb2JqZWN0aXZlIGZ1bmN0aW9uXG4gICAgLy8vIHBrIDogc2VhcmNoIGRpcmVjdGlvblxuICAgIC8vLyBjdXJyZW50OiBvYmplY3QgY29udGFpbmluZyBjdXJyZW50IGdyYWRpZW50L2xvc3NcbiAgICAvLy8gbmV4dDogb3V0cHV0OiBjb250YWlucyBuZXh0IGdyYWRpZW50L2xvc3NcbiAgICAvLy8gcmV0dXJucyBhOiBzdGVwIHNpemUgdGFrZW5cbiAgICBmdW5jdGlvbiB3b2xmZUxpbmVTZWFyY2goZiwgcGssIGN1cnJlbnQsIG5leHQsIGEsIGMxLCBjMikge1xuICAgICAgICB2YXIgcGhpMCA9IGN1cnJlbnQuZngsIHBoaVByaW1lMCA9IGRvdChjdXJyZW50LmZ4cHJpbWUsIHBrKSxcbiAgICAgICAgICAgIHBoaSA9IHBoaTAsIHBoaV9vbGQgPSBwaGkwLFxuICAgICAgICAgICAgcGhpUHJpbWUgPSBwaGlQcmltZTAsXG4gICAgICAgICAgICBhMCA9IDA7XG5cbiAgICAgICAgYSA9IGEgfHwgMTtcbiAgICAgICAgYzEgPSBjMSB8fCAxZS02O1xuICAgICAgICBjMiA9IGMyIHx8IDAuMTtcblxuICAgICAgICBmdW5jdGlvbiB6b29tKGFfbG8sIGFfaGlnaCwgcGhpX2xvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCAxNjsgKytpdGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBhID0gKGFfbG8gKyBhX2hpZ2gpLzI7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ZWRTdW0obmV4dC54LCAxLjAsIGN1cnJlbnQueCwgYSwgcGspO1xuICAgICAgICAgICAgICAgIHBoaSA9IG5leHQuZnggPSBmKG5leHQueCwgbmV4dC5meHByaW1lKTtcbiAgICAgICAgICAgICAgICBwaGlQcmltZSA9IGRvdChuZXh0LmZ4cHJpbWUsIHBrKTtcblxuICAgICAgICAgICAgICAgIGlmICgocGhpID4gKHBoaTAgKyBjMSAqIGEgKiBwaGlQcmltZTApKSB8fFxuICAgICAgICAgICAgICAgICAgICAocGhpID49IHBoaV9sbykpIHtcbiAgICAgICAgICAgICAgICAgICAgYV9oaWdoID0gYTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocGhpUHJpbWUpIDw9IC1jMiAqIHBoaVByaW1lMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocGhpUHJpbWUgKiAoYV9oaWdoIC0gYV9sbykgPj0wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhX2hpZ2ggPSBhX2xvO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYV9sbyA9IGE7XG4gICAgICAgICAgICAgICAgICAgIHBoaV9sbyA9IHBoaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaXRlcmF0aW9uID0gMDsgaXRlcmF0aW9uIDwgMTA7ICsraXRlcmF0aW9uKSB7XG4gICAgICAgICAgICB3ZWlnaHRlZFN1bShuZXh0LngsIDEuMCwgY3VycmVudC54LCBhLCBwayk7XG4gICAgICAgICAgICBwaGkgPSBuZXh0LmZ4ID0gZihuZXh0LngsIG5leHQuZnhwcmltZSk7XG4gICAgICAgICAgICBwaGlQcmltZSA9IGRvdChuZXh0LmZ4cHJpbWUsIHBrKTtcbiAgICAgICAgICAgIGlmICgocGhpID4gKHBoaTAgKyBjMSAqIGEgKiBwaGlQcmltZTApKSB8fFxuICAgICAgICAgICAgICAgIChpdGVyYXRpb24gJiYgKHBoaSA+PSBwaGlfb2xkKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gem9vbShhMCwgYSwgcGhpX29sZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhwaGlQcmltZSkgPD0gLWMyICogcGhpUHJpbWUwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwaGlQcmltZSA+PSAwICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6b29tKGEsIGEwLCBwaGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwaGlfb2xkID0gcGhpO1xuICAgICAgICAgICAgYTAgPSBhO1xuICAgICAgICAgICAgYSAqPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uanVnYXRlR3JhZGllbnQoZiwgaW5pdGlhbCwgcGFyYW1zKSB7XG4gICAgICAgIC8vIGFsbG9jYXRlIGFsbCBtZW1vcnkgdXAgZnJvbnQgaGVyZSwga2VlcCBvdXQgb2YgdGhlIGxvb3AgZm9yIHBlcmZvbWFuY2VcbiAgICAgICAgLy8gcmVhc29uc1xuICAgICAgICB2YXIgY3VycmVudCA9IHt4OiBpbml0aWFsLnNsaWNlKCksIGZ4OiAwLCBmeHByaW1lOiBpbml0aWFsLnNsaWNlKCl9LFxuICAgICAgICAgICAgbmV4dCA9IHt4OiBpbml0aWFsLnNsaWNlKCksIGZ4OiAwLCBmeHByaW1lOiBpbml0aWFsLnNsaWNlKCl9LFxuICAgICAgICAgICAgeWsgPSBpbml0aWFsLnNsaWNlKCksXG4gICAgICAgICAgICBwaywgdGVtcCxcbiAgICAgICAgICAgIGEgPSAxLFxuICAgICAgICAgICAgbWF4SXRlcmF0aW9ucztcblxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIG1heEl0ZXJhdGlvbnMgPSBwYXJhbXMubWF4SXRlcmF0aW9ucyB8fCBpbml0aWFsLmxlbmd0aCAqIDIwO1xuXG4gICAgICAgIGN1cnJlbnQuZnggPSBmKGN1cnJlbnQueCwgY3VycmVudC5meHByaW1lKTtcbiAgICAgICAgcGsgPSBjdXJyZW50LmZ4cHJpbWUuc2xpY2UoKTtcbiAgICAgICAgc2NhbGUocGssIGN1cnJlbnQuZnhwcmltZSwtMSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhJdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIGEgPSB3b2xmZUxpbmVTZWFyY2goZiwgcGssIGN1cnJlbnQsIG5leHQsIGEpO1xuXG4gICAgICAgICAgICAvLyB0b2RvOiBoaXN0b3J5IGluIHdyb25nIHNwb3Q/XG4gICAgICAgICAgICBpZiAocGFyYW1zLmhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuaGlzdG9yeS5wdXNoKHt4OiBjdXJyZW50Lnguc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmeDogY3VycmVudC5meCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmeHByaW1lOiBjdXJyZW50LmZ4cHJpbWUuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTogYX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICAgICAgICAvLyBmYWlpbGVkIHRvIGZpbmQgcG9pbnQgdGhhdCBzYXRpZmllcyB3b2xmZSBjb25kaXRpb25zLlxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IGRpcmVjdGlvbiBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICBzY2FsZShwaywgY3VycmVudC5meHByaW1lLCAtMSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGRpcmVjdGlvbiB1c2luZyBQb2xha+KAk1JpYmllcmUgQ0cgbWV0aG9kXG4gICAgICAgICAgICAgICAgd2VpZ2h0ZWRTdW0oeWssIDEsIG5leHQuZnhwcmltZSwgLTEsIGN1cnJlbnQuZnhwcmltZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFfayA9IGRvdChjdXJyZW50LmZ4cHJpbWUsIGN1cnJlbnQuZnhwcmltZSksXG4gICAgICAgICAgICAgICAgICAgIGJldGFfayA9IE1hdGgubWF4KDAsIGRvdCh5aywgbmV4dC5meHByaW1lKSAvIGRlbHRhX2spO1xuXG4gICAgICAgICAgICAgICAgd2VpZ2h0ZWRTdW0ocGssIGJldGFfaywgcGssIC0xLCBuZXh0LmZ4cHJpbWUpO1xuXG4gICAgICAgICAgICAgICAgdGVtcCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHRlbXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub3JtMihjdXJyZW50LmZ4cHJpbWUpIDw9IDFlLTUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuaGlzdG9yeSkge1xuICAgICAgICAgICAgcGFyYW1zLmhpc3RvcnkucHVzaCh7eDogY3VycmVudC54LnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmeDogY3VycmVudC5meCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ4cHJpbWU6IGN1cnJlbnQuZnhwcmltZS5zbGljZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGE6IGF9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdyYWRpZW50RGVzY2VudChmLCBpbml0aWFsLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IHBhcmFtcy5tYXhJdGVyYXRpb25zIHx8IGluaXRpYWwubGVuZ3RoICogMTAwLFxuICAgICAgICAgICAgbGVhcm5SYXRlID0gcGFyYW1zLmxlYXJuUmF0ZSB8fCAwLjAwMSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSB7eDogaW5pdGlhbC5zbGljZSgpLCBmeDogMCwgZnhwcmltZTogaW5pdGlhbC5zbGljZSgpfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heEl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICAgICAgY3VycmVudC5meCA9IGYoY3VycmVudC54LCBjdXJyZW50LmZ4cHJpbWUpO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5oaXN0b3J5KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmhpc3RvcnkucHVzaCh7eDogY3VycmVudC54LnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZng6IGN1cnJlbnQuZngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnhwcmltZTogY3VycmVudC5meHByaW1lLnNsaWNlKCl9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2VpZ2h0ZWRTdW0oY3VycmVudC54LCAxLCBjdXJyZW50LngsIC1sZWFyblJhdGUsIGN1cnJlbnQuZnhwcmltZSk7XG4gICAgICAgICAgICBpZiAobm9ybTIoY3VycmVudC5meHByaW1lKSA8PSAxZS01KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBncmFkaWVudERlc2NlbnRMaW5lU2VhcmNoKGYsIGluaXRpYWwsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHZhciBjdXJyZW50ID0ge3g6IGluaXRpYWwuc2xpY2UoKSwgZng6IDAsIGZ4cHJpbWU6IGluaXRpYWwuc2xpY2UoKX0sXG4gICAgICAgICAgICBuZXh0ID0ge3g6IGluaXRpYWwuc2xpY2UoKSwgZng6IDAsIGZ4cHJpbWU6IGluaXRpYWwuc2xpY2UoKX0sXG4gICAgICAgICAgICBtYXhJdGVyYXRpb25zID0gcGFyYW1zLm1heEl0ZXJhdGlvbnMgfHwgaW5pdGlhbC5sZW5ndGggKiAxMDAsXG4gICAgICAgICAgICBsZWFyblJhdGUgPSBwYXJhbXMubGVhcm5SYXRlIHx8IDEsXG4gICAgICAgICAgICBwayA9IGluaXRpYWwuc2xpY2UoKSxcbiAgICAgICAgICAgIGMxID0gcGFyYW1zLmMxIHx8IDFlLTMsXG4gICAgICAgICAgICBjMiA9IHBhcmFtcy5jMiB8fCAwLjEsXG4gICAgICAgICAgICB0ZW1wLFxuICAgICAgICAgICAgZnVuY3Rpb25DYWxscyA9IFtdO1xuXG4gICAgICAgIGlmIChwYXJhbXMuaGlzdG9yeSkge1xuICAgICAgICAgICAgLy8gd3JhcCB0aGUgZnVuY3Rpb24gY2FsbCB0byB0cmFjayBsaW5lc2VhcmNoIHNhbXBsZXNcbiAgICAgICAgICAgIHZhciBpbm5lciA9IGY7XG4gICAgICAgICAgICBmID0gZnVuY3Rpb24oeCwgZnhwcmltZSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbHMucHVzaCh4LnNsaWNlKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcih4LCBmeHByaW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50LmZ4ID0gZihjdXJyZW50LngsIGN1cnJlbnQuZnhwcmltZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4SXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgICAgICBzY2FsZShwaywgY3VycmVudC5meHByaW1lLCAtMSk7XG4gICAgICAgICAgICBsZWFyblJhdGUgPSB3b2xmZUxpbmVTZWFyY2goZiwgcGssIGN1cnJlbnQsIG5leHQsIGxlYXJuUmF0ZSwgYzEsIGMyKTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5oaXN0b3J5KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmhpc3RvcnkucHVzaCh7eDogY3VycmVudC54LnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZng6IGN1cnJlbnQuZngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnhwcmltZTogY3VycmVudC5meHByaW1lLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsczogZnVuY3Rpb25DYWxscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWFyblJhdGU6IGxlYXJuUmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTogbGVhcm5SYXRlfSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxscyA9IFtdO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRlbXAgPSBjdXJyZW50O1xuICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gdGVtcDtcblxuICAgICAgICAgICAgaWYgKChsZWFyblJhdGUgPT09IDApIHx8IChub3JtMihjdXJyZW50LmZ4cHJpbWUpIDwgMWUtNSkpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5iaXNlY3QgPSBiaXNlY3Q7XG4gICAgZXhwb3J0cy5uZWxkZXJNZWFkID0gbmVsZGVyTWVhZDtcbiAgICBleHBvcnRzLmNvbmp1Z2F0ZUdyYWRpZW50ID0gY29uanVnYXRlR3JhZGllbnQ7XG4gICAgZXhwb3J0cy5ncmFkaWVudERlc2NlbnQgPSBncmFkaWVudERlc2NlbnQ7XG4gICAgZXhwb3J0cy5ncmFkaWVudERlc2NlbnRMaW5lU2VhcmNoID0gZ3JhZGllbnREZXNjZW50TGluZVNlYXJjaDtcbiAgICBleHBvcnRzLnplcm9zID0gemVyb3M7XG4gICAgZXhwb3J0cy56ZXJvc00gPSB6ZXJvc007XG4gICAgZXhwb3J0cy5ub3JtMiA9IG5vcm0yO1xuICAgIGV4cG9ydHMud2VpZ2h0ZWRTdW0gPSB3ZWlnaHRlZFN1bTtcbiAgICBleHBvcnRzLnNjYWxlID0gc2NhbGU7XG5cbn0pKTsiXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJmbWluIiwiYmlzZWN0IiwiZiIsImEiLCJiIiwicGFyYW1ldGVycyIsIm1heEl0ZXJhdGlvbnMiLCJ0b2xlcmFuY2UiLCJmQSIsImZCIiwiZGVsdGEiLCJpIiwibWlkIiwiZk1pZCIsIk1hdGgiLCJhYnMiLCJ6ZXJvcyIsIngiLCJyIiwiQXJyYXkiLCJ6ZXJvc00iLCJ5IiwibWFwIiwiZG90IiwicmV0IiwibGVuZ3RoIiwibm9ybTIiLCJzcXJ0Iiwic2NhbGUiLCJ2YWx1ZSIsImMiLCJ3ZWlnaHRlZFN1bSIsIncxIiwidjEiLCJ3MiIsInYyIiwiaiIsIm5lbGRlck1lYWQiLCJ4MCIsIm5vblplcm9EZWx0YSIsInplcm9EZWx0YSIsIm1pbkVycm9yRGVsdGEiLCJtaW5Ub2xlcmFuY2UiLCJyaG8iLCJ1bmRlZmluZWQiLCJjaGkiLCJwc2kiLCJzaWdtYSIsIm1heERpZmYiLCJOIiwic2ltcGxleCIsImZ4IiwiaWQiLCJwb2ludCIsInNsaWNlIiwidXBkYXRlU2ltcGxleCIsInNvcnRPcmRlciIsImNlbnRyb2lkIiwicmVmbGVjdGVkIiwiY29udHJhY3RlZCIsImV4cGFuZGVkIiwiaXRlcmF0aW9uIiwic29ydCIsImhpc3RvcnkiLCJzb3J0ZWRTaW1wbGV4Iiwic3RhdGUiLCJwdXNoIiwibWF4Iiwid29yc3QiLCJzaG91bGRSZWR1Y2UiLCJ3b2xmZUxpbmVTZWFyY2giLCJwayIsImN1cnJlbnQiLCJuZXh0IiwiYzEiLCJjMiIsInBoaTAiLCJwaGlQcmltZTAiLCJmeHByaW1lIiwicGhpIiwicGhpX29sZCIsInBoaVByaW1lIiwiYTAiLCJ6b29tIiwiYV9sbyIsImFfaGlnaCIsInBoaV9sbyIsImNvbmp1Z2F0ZUdyYWRpZW50IiwiaW5pdGlhbCIsInBhcmFtcyIsInlrIiwidGVtcCIsImFscGhhIiwiZGVsdGFfayIsImJldGFfayIsImdyYWRpZW50RGVzY2VudCIsImxlYXJuUmF0ZSIsImdyYWRpZW50RGVzY2VudExpbmVTZWFyY2giLCJmdW5jdGlvbkNhbGxzIiwiaW5uZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fmin/build/fmin.js\n");

/***/ })

};
;