/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-highlight-words";
exports.ids = ["vendor-chunks/react-highlight-words"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-highlight-words/dist/main.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-highlight-words/dist/main.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = /******/ function(modules) {\n    /******/ // The module cache\n    /******/ var installedModules = {};\n    /******/ /******/ // The require function\n    /******/ function __nested_webpack_require_178__(moduleId) {\n        /******/ /******/ // Check if module is in cache\n        /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;\n        /******/ /******/ // Create a new module (and put it into the cache)\n        /******/ var module1 = installedModules[moduleId] = {\n            /******/ exports: {},\n            /******/ id: moduleId,\n            /******/ loaded: false\n        };\n        /******/ /******/ // Execute the module function\n        /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_178__);\n        /******/ /******/ // Flag the module as loaded\n        /******/ module1.loaded = true;\n        /******/ /******/ // Return the exports of the module\n        /******/ return module1.exports;\n    /******/ }\n    /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n    /******/ __nested_webpack_require_178__.m = modules;\n    /******/ /******/ // expose the module cache\n    /******/ __nested_webpack_require_178__.c = installedModules;\n    /******/ /******/ // __webpack_public_path__\n    /******/ __nested_webpack_require_178__.p = \"\";\n    /******/ /******/ // Load entry module and return exports\n    /******/ return __nested_webpack_require_178__(0);\n/******/ }([\n    /* 0 */ /***/ function(module1, exports, __nested_webpack_require_1492__) {\n        module1.exports = __nested_webpack_require_1492__(1);\n    /***/ },\n    /* 1 */ /***/ function(module1, exports, __nested_webpack_require_1623__) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        function _interopRequireDefault(obj) {\n            return obj && obj.__esModule ? obj : {\n                \"default\": obj\n            };\n        }\n        var _Highlighter = __nested_webpack_require_1623__(2);\n        var _Highlighter2 = _interopRequireDefault(_Highlighter);\n        exports[\"default\"] = _Highlighter2[\"default\"];\n        module1.exports = exports[\"default\"];\n    /***/ },\n    /* 2 */ /***/ function(module1, exports, __nested_webpack_require_2189__) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        var _extends = Object.assign || function(target) {\n            for(var i = 1; i < arguments.length; i++){\n                var source = arguments[i];\n                for(var key in source){\n                    if (Object.prototype.hasOwnProperty.call(source, key)) {\n                        target[key] = source[key];\n                    }\n                }\n            }\n            return target;\n        };\n        exports[\"default\"] = Highlighter;\n        function _interopRequireDefault(obj) {\n            return obj && obj.__esModule ? obj : {\n                \"default\": obj\n            };\n        }\n        function _objectWithoutProperties(obj, keys) {\n            var target = {};\n            for(var i in obj){\n                if (keys.indexOf(i) >= 0) continue;\n                if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n                target[i] = obj[i];\n            }\n            return target;\n        }\n        var _highlightWordsCore = __nested_webpack_require_2189__(3);\n        var _propTypes = __nested_webpack_require_2189__(4);\n        var _propTypes2 = _interopRequireDefault(_propTypes);\n        var _react = __nested_webpack_require_2189__(14);\n        var _memoizeOne = __nested_webpack_require_2189__(15);\n        var _memoizeOne2 = _interopRequireDefault(_memoizeOne);\n        Highlighter.propTypes = {\n            activeClassName: _propTypes2[\"default\"].string,\n            activeIndex: _propTypes2[\"default\"].number,\n            activeStyle: _propTypes2[\"default\"].object,\n            autoEscape: _propTypes2[\"default\"].bool,\n            className: _propTypes2[\"default\"].string,\n            findChunks: _propTypes2[\"default\"].func,\n            highlightClassName: _propTypes2[\"default\"].oneOfType([\n                _propTypes2[\"default\"].object,\n                _propTypes2[\"default\"].string\n            ]),\n            highlightStyle: _propTypes2[\"default\"].object,\n            highlightTag: _propTypes2[\"default\"].oneOfType([\n                _propTypes2[\"default\"].node,\n                _propTypes2[\"default\"].func,\n                _propTypes2[\"default\"].string\n            ]),\n            sanitize: _propTypes2[\"default\"].func,\n            searchWords: _propTypes2[\"default\"].arrayOf(_propTypes2[\"default\"].oneOfType([\n                _propTypes2[\"default\"].string,\n                _propTypes2[\"default\"].instanceOf(RegExp)\n            ])).isRequired,\n            textToHighlight: _propTypes2[\"default\"].string.isRequired,\n            unhighlightTag: _propTypes2[\"default\"].oneOfType([\n                _propTypes2[\"default\"].node,\n                _propTypes2[\"default\"].func,\n                _propTypes2[\"default\"].string\n            ]),\n            unhighlightClassName: _propTypes2[\"default\"].string,\n            unhighlightStyle: _propTypes2[\"default\"].object\n        };\n        /**\r\n\t * Highlights all occurrences of search terms (searchText) within a string (textToHighlight).\r\n\t * This function returns an array of strings and <span>s (wrapping highlighted words).\r\n\t */ function Highlighter(_ref) {\n            var _ref$activeClassName = _ref.activeClassName;\n            var activeClassName = _ref$activeClassName === undefined ? \"\" : _ref$activeClassName;\n            var _ref$activeIndex = _ref.activeIndex;\n            var activeIndex = _ref$activeIndex === undefined ? -1 : _ref$activeIndex;\n            var activeStyle = _ref.activeStyle;\n            var autoEscape = _ref.autoEscape;\n            var _ref$caseSensitive = _ref.caseSensitive;\n            var caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive;\n            var className = _ref.className;\n            var findChunks = _ref.findChunks;\n            var _ref$highlightClassName = _ref.highlightClassName;\n            var highlightClassName = _ref$highlightClassName === undefined ? \"\" : _ref$highlightClassName;\n            var _ref$highlightStyle = _ref.highlightStyle;\n            var highlightStyle = _ref$highlightStyle === undefined ? {} : _ref$highlightStyle;\n            var _ref$highlightTag = _ref.highlightTag;\n            var highlightTag = _ref$highlightTag === undefined ? \"mark\" : _ref$highlightTag;\n            var sanitize = _ref.sanitize;\n            var searchWords = _ref.searchWords;\n            var textToHighlight = _ref.textToHighlight;\n            var _ref$unhighlightTag = _ref.unhighlightTag;\n            var unhighlightTag = _ref$unhighlightTag === undefined ? \"span\" : _ref$unhighlightTag;\n            var _ref$unhighlightClassName = _ref.unhighlightClassName;\n            var unhighlightClassName = _ref$unhighlightClassName === undefined ? \"\" : _ref$unhighlightClassName;\n            var unhighlightStyle = _ref.unhighlightStyle;\n            var rest = _objectWithoutProperties(_ref, [\n                \"activeClassName\",\n                \"activeIndex\",\n                \"activeStyle\",\n                \"autoEscape\",\n                \"caseSensitive\",\n                \"className\",\n                \"findChunks\",\n                \"highlightClassName\",\n                \"highlightStyle\",\n                \"highlightTag\",\n                \"sanitize\",\n                \"searchWords\",\n                \"textToHighlight\",\n                \"unhighlightTag\",\n                \"unhighlightClassName\",\n                \"unhighlightStyle\"\n            ]);\n            var chunks = (0, _highlightWordsCore.findAll)({\n                autoEscape: autoEscape,\n                caseSensitive: caseSensitive,\n                findChunks: findChunks,\n                sanitize: sanitize,\n                searchWords: searchWords,\n                textToHighlight: textToHighlight\n            });\n            var HighlightTag = highlightTag;\n            var highlightIndex = -1;\n            var highlightClassNames = \"\";\n            var highlightStyles = undefined;\n            var lowercaseProps = function lowercaseProps(object) {\n                var mapped = {};\n                for(var key in object){\n                    mapped[key.toLowerCase()] = object[key];\n                }\n                return mapped;\n            };\n            var memoizedLowercaseProps = (0, _memoizeOne2[\"default\"])(lowercaseProps);\n            return (0, _react.createElement)(\"span\", _extends({\n                className: className\n            }, rest, {\n                children: chunks.map(function(chunk, index) {\n                    var text = textToHighlight.substr(chunk.start, chunk.end - chunk.start);\n                    if (chunk.highlight) {\n                        highlightIndex++;\n                        var highlightClass = undefined;\n                        if (typeof highlightClassName === \"object\") {\n                            if (!caseSensitive) {\n                                highlightClassName = memoizedLowercaseProps(highlightClassName);\n                                highlightClass = highlightClassName[text.toLowerCase()];\n                            } else {\n                                highlightClass = highlightClassName[text];\n                            }\n                        } else {\n                            highlightClass = highlightClassName;\n                        }\n                        var isActive = highlightIndex === +activeIndex;\n                        highlightClassNames = highlightClass + \" \" + (isActive ? activeClassName : \"\");\n                        highlightStyles = isActive === true && activeStyle != null ? Object.assign({}, highlightStyle, activeStyle) : highlightStyle;\n                        var props = {\n                            children: text,\n                            className: highlightClassNames,\n                            key: index,\n                            style: highlightStyles\n                        };\n                        // Don't attach arbitrary props to DOM elements; this triggers React DEV warnings (https://fb.me/react-unknown-prop)\n                        // Only pass through the highlightIndex attribute for custom components.\n                        if (typeof HighlightTag !== \"string\") {\n                            props.highlightIndex = highlightIndex;\n                        }\n                        return (0, _react.createElement)(HighlightTag, props);\n                    } else {\n                        return (0, _react.createElement)(unhighlightTag, {\n                            children: text,\n                            className: unhighlightClassName,\n                            key: index,\n                            style: unhighlightStyle\n                        });\n                    }\n                })\n            }));\n        }\n        module1.exports = exports[\"default\"];\n    /***/ },\n    /* 3 */ /***/ function(module1, exports) {\n        module1.exports = /******/ function(modules) {\n            /******/ // The module cache\n            /******/ var installedModules = {};\n            /******/ /******/ // The require function\n            /******/ function __nested_webpack_require_11220__(moduleId) {\n                /******/ /******/ // Check if module is in cache\n                /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;\n                /******/ /******/ // Create a new module (and put it into the cache)\n                /******/ var module1 = installedModules[moduleId] = {\n                    /******/ exports: {},\n                    /******/ id: moduleId,\n                    /******/ loaded: false\n                };\n                /******/ /******/ // Execute the module function\n                /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_11220__);\n                /******/ /******/ // Flag the module as loaded\n                /******/ module1.loaded = true;\n                /******/ /******/ // Return the exports of the module\n                /******/ return module1.exports;\n            /******/ }\n            /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n            /******/ __nested_webpack_require_11220__.m = modules;\n            /******/ /******/ // expose the module cache\n            /******/ __nested_webpack_require_11220__.c = installedModules;\n            /******/ /******/ // __webpack_public_path__\n            /******/ __nested_webpack_require_11220__.p = \"\";\n            /******/ /******/ // Load entry module and return exports\n            /******/ return __nested_webpack_require_11220__(0);\n        /******/ }([\n            /* 0 */ /***/ function(module1, exports, __nested_webpack_require_12734__) {\n                module1.exports = __nested_webpack_require_12734__(1);\n            /***/ },\n            /* 1 */ /***/ function(module1, exports, __nested_webpack_require_12889__) {\n                \"use strict\";\n                Object.defineProperty(exports, \"__esModule\", {\n                    value: true\n                });\n                var _utils = __nested_webpack_require_12889__(2);\n                Object.defineProperty(exports, \"combineChunks\", {\n                    enumerable: true,\n                    get: function get() {\n                        return _utils.combineChunks;\n                    }\n                });\n                Object.defineProperty(exports, \"fillInChunks\", {\n                    enumerable: true,\n                    get: function get() {\n                        return _utils.fillInChunks;\n                    }\n                });\n                Object.defineProperty(exports, \"findAll\", {\n                    enumerable: true,\n                    get: function get() {\n                        return _utils.findAll;\n                    }\n                });\n                Object.defineProperty(exports, \"findChunks\", {\n                    enumerable: true,\n                    get: function get() {\n                        return _utils.findChunks;\n                    }\n                });\n            /***/ },\n            /* 2 */ /***/ function(module1, exports) {\n                \"use strict\";\n                Object.defineProperty(exports, \"__esModule\", {\n                    value: true\n                });\n                /**\n\t\t * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.\n\t\t * @return Array of \"chunks\" (where a Chunk is { start:number, end:number, highlight:boolean })\n\t\t */ var findAll = exports.findAll = function findAll(_ref) {\n                    var autoEscape = _ref.autoEscape, _ref$caseSensitive = _ref.caseSensitive, caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive, _ref$findChunks = _ref.findChunks, findChunks = _ref$findChunks === undefined ? defaultFindChunks : _ref$findChunks, sanitize = _ref.sanitize, searchWords = _ref.searchWords, textToHighlight = _ref.textToHighlight;\n                    return fillInChunks({\n                        chunksToHighlight: combineChunks({\n                            chunks: findChunks({\n                                autoEscape: autoEscape,\n                                caseSensitive: caseSensitive,\n                                sanitize: sanitize,\n                                searchWords: searchWords,\n                                textToHighlight: textToHighlight\n                            })\n                        }),\n                        totalLength: textToHighlight ? textToHighlight.length : 0\n                    });\n                };\n                /**\n\t\t * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.\n\t\t * @return {start:number, end:number}[]\n\t\t */ var combineChunks = exports.combineChunks = function combineChunks(_ref2) {\n                    var chunks = _ref2.chunks;\n                    chunks = chunks.sort(function(first, second) {\n                        return first.start - second.start;\n                    }).reduce(function(processedChunks, nextChunk) {\n                        // First chunk just goes straight in the array...\n                        if (processedChunks.length === 0) {\n                            return [\n                                nextChunk\n                            ];\n                        } else {\n                            // ... subsequent chunks get checked to see if they overlap...\n                            var prevChunk = processedChunks.pop();\n                            if (nextChunk.start <= prevChunk.end) {\n                                // It may be the case that prevChunk completely surrounds nextChunk, so take the\n                                // largest of the end indeces.\n                                var endIndex = Math.max(prevChunk.end, nextChunk.end);\n                                processedChunks.push({\n                                    start: prevChunk.start,\n                                    end: endIndex\n                                });\n                            } else {\n                                processedChunks.push(prevChunk, nextChunk);\n                            }\n                            return processedChunks;\n                        }\n                    }, []);\n                    return chunks;\n                };\n                /**\n\t\t * Examine text for any matches.\n\t\t * If we find matches, add them to the returned array as a \"chunk\" object ({start:number, end:number}).\n\t\t * @return {start:number, end:number}[]\n\t\t */ var defaultFindChunks = function defaultFindChunks(_ref3) {\n                    var autoEscape = _ref3.autoEscape, caseSensitive = _ref3.caseSensitive, _ref3$sanitize = _ref3.sanitize, sanitize = _ref3$sanitize === undefined ? identity : _ref3$sanitize, searchWords = _ref3.searchWords, textToHighlight = _ref3.textToHighlight;\n                    textToHighlight = sanitize(textToHighlight);\n                    return searchWords.filter(function(searchWord) {\n                        return searchWord;\n                    }) // Remove empty words\n                    .reduce(function(chunks, searchWord) {\n                        searchWord = sanitize(searchWord);\n                        if (autoEscape) {\n                            searchWord = escapeRegExpFn(searchWord);\n                        }\n                        var regex = new RegExp(searchWord, caseSensitive ? \"g\" : \"gi\");\n                        var match = void 0;\n                        while(match = regex.exec(textToHighlight)){\n                            var start = match.index;\n                            var end = regex.lastIndex;\n                            // We do not return zero-length matches\n                            if (end > start) {\n                                chunks.push({\n                                    start: start,\n                                    end: end\n                                });\n                            }\n                            // Prevent browsers like Firefox from getting stuck in an infinite loop\n                            // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/\n                            if (match.index == regex.lastIndex) {\n                                regex.lastIndex++;\n                            }\n                        }\n                        return chunks;\n                    }, []);\n                };\n                // Allow the findChunks to be overridden in findAll,\n                // but for backwards compatibility we export as the old name\n                exports.findChunks = defaultFindChunks;\n                /**\n\t\t * Given a set of chunks to highlight, create an additional set of chunks\n\t\t * to represent the bits of text between the highlighted text.\n\t\t * @param chunksToHighlight {start:number, end:number}[]\n\t\t * @param totalLength number\n\t\t * @return {start:number, end:number, highlight:boolean}[]\n\t\t */ var fillInChunks = exports.fillInChunks = function fillInChunks(_ref4) {\n                    var chunksToHighlight = _ref4.chunksToHighlight, totalLength = _ref4.totalLength;\n                    var allChunks = [];\n                    var append = function append(start, end, highlight) {\n                        if (end - start > 0) {\n                            allChunks.push({\n                                start: start,\n                                end: end,\n                                highlight: highlight\n                            });\n                        }\n                    };\n                    if (chunksToHighlight.length === 0) {\n                        append(0, totalLength, false);\n                    } else {\n                        var lastIndex = 0;\n                        chunksToHighlight.forEach(function(chunk) {\n                            append(lastIndex, chunk.start, false);\n                            append(chunk.start, chunk.end, true);\n                            lastIndex = chunk.end;\n                        });\n                        append(lastIndex, totalLength, false);\n                    }\n                    return allChunks;\n                };\n                function identity(value) {\n                    return value;\n                }\n                function escapeRegExpFn(str) {\n                    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n                }\n            /***/ }\n        ]);\n    //# sourceMappingURL=index.js.map\n    /***/ },\n    /* 4 */ /***/ function(module1, exports, __nested_webpack_require_21586__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            if (true) {\n                var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n                var isValidElement = function(object) {\n                    return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                };\n                // By explicitly using `prop-types` you are opting into new development behavior.\n                // http://fb.me/prop-types-in-prod\n                var throwOnDirectAccess = true;\n                module1.exports = __nested_webpack_require_21586__(6)(isValidElement, throwOnDirectAccess);\n            } else {}\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_21586__(5));\n    /***/ },\n    /* 5 */ /***/ function(module1, exports) {\n        // shim for using process in browser\n        var process = module1.exports = {};\n        // cached from whatever global is present so that test runners that stub it\n        // don't break things.  But we need to wrap it in a try catch in case it is\n        // wrapped in strict mode code which doesn't define any globals.  It's inside a\n        // function because try/catches deoptimize in certain engines.\n        var cachedSetTimeout;\n        var cachedClearTimeout;\n        function defaultSetTimout() {\n            throw new Error(\"setTimeout has not been defined\");\n        }\n        function defaultClearTimeout() {\n            throw new Error(\"clearTimeout has not been defined\");\n        }\n        (function() {\n            try {\n                if (typeof setTimeout === \"function\") {\n                    cachedSetTimeout = setTimeout;\n                } else {\n                    cachedSetTimeout = defaultSetTimout;\n                }\n            } catch (e) {\n                cachedSetTimeout = defaultSetTimout;\n            }\n            try {\n                if (typeof clearTimeout === \"function\") {\n                    cachedClearTimeout = clearTimeout;\n                } else {\n                    cachedClearTimeout = defaultClearTimeout;\n                }\n            } catch (e) {\n                cachedClearTimeout = defaultClearTimeout;\n            }\n        })();\n        function runTimeout(fun) {\n            if (cachedSetTimeout === setTimeout) {\n                //normal enviroments in sane situations\n                return setTimeout(fun, 0);\n            }\n            // if setTimeout wasn't available but was latter defined\n            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n                cachedSetTimeout = setTimeout;\n                return setTimeout(fun, 0);\n            }\n            try {\n                // when when somebody has screwed with setTimeout but no I.E. maddness\n                return cachedSetTimeout(fun, 0);\n            } catch (e) {\n                try {\n                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n                    return cachedSetTimeout.call(null, fun, 0);\n                } catch (e) {\n                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n                    return cachedSetTimeout.call(this, fun, 0);\n                }\n            }\n        }\n        function runClearTimeout(marker) {\n            if (cachedClearTimeout === clearTimeout) {\n                //normal enviroments in sane situations\n                return clearTimeout(marker);\n            }\n            // if clearTimeout wasn't available but was latter defined\n            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n                cachedClearTimeout = clearTimeout;\n                return clearTimeout(marker);\n            }\n            try {\n                // when when somebody has screwed with setTimeout but no I.E. maddness\n                return cachedClearTimeout(marker);\n            } catch (e) {\n                try {\n                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n                    return cachedClearTimeout.call(null, marker);\n                } catch (e) {\n                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n                    return cachedClearTimeout.call(this, marker);\n                }\n            }\n        }\n        var queue = [];\n        var draining = false;\n        var currentQueue;\n        var queueIndex = -1;\n        function cleanUpNextTick() {\n            if (!draining || !currentQueue) {\n                return;\n            }\n            draining = false;\n            if (currentQueue.length) {\n                queue = currentQueue.concat(queue);\n            } else {\n                queueIndex = -1;\n            }\n            if (queue.length) {\n                drainQueue();\n            }\n        }\n        function drainQueue() {\n            if (draining) {\n                return;\n            }\n            var timeout = runTimeout(cleanUpNextTick);\n            draining = true;\n            var len = queue.length;\n            while(len){\n                currentQueue = queue;\n                queue = [];\n                while(++queueIndex < len){\n                    if (currentQueue) {\n                        currentQueue[queueIndex].run();\n                    }\n                }\n                queueIndex = -1;\n                len = queue.length;\n            }\n            currentQueue = null;\n            draining = false;\n            runClearTimeout(timeout);\n        }\n        process.nextTick = function(fun) {\n            var args = new Array(arguments.length - 1);\n            if (arguments.length > 1) {\n                for(var i = 1; i < arguments.length; i++){\n                    args[i - 1] = arguments[i];\n                }\n            }\n            queue.push(new Item(fun, args));\n            if (queue.length === 1 && !draining) {\n                runTimeout(drainQueue);\n            }\n        };\n        // v8 likes predictible objects\n        function Item(fun, array) {\n            this.fun = fun;\n            this.array = array;\n        }\n        Item.prototype.run = function() {\n            this.fun.apply(null, this.array);\n        };\n        process.title = \"browser\";\n        process.browser = true;\n        process.env = {};\n        process.argv = [];\n        process.version = \"\"; // empty string to avoid regexp issues\n        process.versions = {};\n        function noop() {}\n        process.on = noop;\n        process.addListener = noop;\n        process.once = noop;\n        process.off = noop;\n        process.removeListener = noop;\n        process.removeAllListeners = noop;\n        process.emit = noop;\n        process.prependListener = noop;\n        process.prependOnceListener = noop;\n        process.listeners = function(name) {\n            return [];\n        };\n        process.binding = function(name) {\n            throw new Error(\"process.binding is not supported\");\n        };\n        process.cwd = function() {\n            return \"/\";\n        };\n        process.chdir = function(dir) {\n            throw new Error(\"process.chdir is not supported\");\n        };\n        process.umask = function() {\n            return 0;\n        };\n    /***/ },\n    /* 6 */ /***/ function(module1, exports, __nested_webpack_require_29550__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            \"use strict\";\n            var emptyFunction = __nested_webpack_require_29550__(7);\n            var invariant = __nested_webpack_require_29550__(8);\n            var warning = __nested_webpack_require_29550__(9);\n            var assign = __nested_webpack_require_29550__(10);\n            var ReactPropTypesSecret = __nested_webpack_require_29550__(11);\n            var checkPropTypes = __nested_webpack_require_29550__(12);\n            module1.exports = function(isValidElement, throwOnDirectAccess) {\n                /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n                var FAUX_ITERATOR_SYMBOL = \"@@iterator\"; // Before Symbol spec.\n                /**\n\t   * Returns the iterator method function contained on the iterable object.\n\t   *\n\t   * Be sure to invoke the function with the iterable as context:\n\t   *\n\t   *     var iteratorFn = getIteratorFn(myIterable);\n\t   *     if (iteratorFn) {\n\t   *       var iterator = iteratorFn.call(myIterable);\n\t   *       ...\n\t   *     }\n\t   *\n\t   * @param {?object} maybeIterable\n\t   * @return {?function}\n\t   */ function getIteratorFn(maybeIterable) {\n                    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n                    if (typeof iteratorFn === \"function\") {\n                        return iteratorFn;\n                    }\n                }\n                /**\n\t   * Collection of methods that allow declaration and validation of props that are\n\t   * supplied to React components. Example usage:\n\t   *\n\t   *   var Props = require('ReactPropTypes');\n\t   *   var MyArticle = React.createClass({\n\t   *     propTypes: {\n\t   *       // An optional string prop named \"description\".\n\t   *       description: Props.string,\n\t   *\n\t   *       // A required enum prop named \"category\".\n\t   *       category: Props.oneOf(['News','Photos']).isRequired,\n\t   *\n\t   *       // A prop named \"dialog\" that requires an instance of Dialog.\n\t   *       dialog: Props.instanceOf(Dialog).isRequired\n\t   *     },\n\t   *     render: function() { ... }\n\t   *   });\n\t   *\n\t   * A more formal specification of how these methods are used:\n\t   *\n\t   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n\t   *   decl := ReactPropTypes.{type}(.isRequired)?\n\t   *\n\t   * Each and every declaration produces a function with the same signature. This\n\t   * allows the creation of custom validation functions. For example:\n\t   *\n\t   *  var MyLink = React.createClass({\n\t   *    propTypes: {\n\t   *      // An optional string or URI prop named \"href\".\n\t   *      href: function(props, propName, componentName) {\n\t   *        var propValue = props[propName];\n\t   *        if (propValue != null && typeof propValue !== 'string' &&\n\t   *            !(propValue instanceof URI)) {\n\t   *          return new Error(\n\t   *            'Expected a string or an URI for ' + propName + ' in ' +\n\t   *            componentName\n\t   *          );\n\t   *        }\n\t   *      }\n\t   *    },\n\t   *    render: function() {...}\n\t   *  });\n\t   *\n\t   * @internal\n\t   */ var ANONYMOUS = \"<<anonymous>>\";\n                // Important!\n                // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n                var ReactPropTypes = {\n                    array: createPrimitiveTypeChecker(\"array\"),\n                    bool: createPrimitiveTypeChecker(\"boolean\"),\n                    func: createPrimitiveTypeChecker(\"function\"),\n                    number: createPrimitiveTypeChecker(\"number\"),\n                    object: createPrimitiveTypeChecker(\"object\"),\n                    string: createPrimitiveTypeChecker(\"string\"),\n                    symbol: createPrimitiveTypeChecker(\"symbol\"),\n                    any: createAnyTypeChecker(),\n                    arrayOf: createArrayOfTypeChecker,\n                    element: createElementTypeChecker(),\n                    instanceOf: createInstanceTypeChecker,\n                    node: createNodeChecker(),\n                    objectOf: createObjectOfTypeChecker,\n                    oneOf: createEnumTypeChecker,\n                    oneOfType: createUnionTypeChecker,\n                    shape: createShapeTypeChecker,\n                    exact: createStrictShapeTypeChecker\n                };\n                /**\n\t   * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t   */ /*eslint-disable no-self-compare*/ function is(x, y) {\n                    // SameValue algorithm\n                    if (x === y) {\n                        // Steps 1-5, 7-10\n                        // Steps 6.b-6.e: +0 != -0\n                        return x !== 0 || 1 / x === 1 / y;\n                    } else {\n                        // Step 6.a: NaN == NaN\n                        return x !== x && y !== y;\n                    }\n                }\n                /*eslint-enable no-self-compare*/ /**\n\t   * We use an Error-like object for backward compatibility as people may call\n\t   * PropTypes directly and inspect their output. However, we don't use real\n\t   * Errors anymore. We don't inspect their stack anyway, and creating them\n\t   * is prohibitively expensive if they are created too often, such as what\n\t   * happens in oneOfType() for any type before the one that matched.\n\t   */ function PropTypeError(message) {\n                    this.message = message;\n                    this.stack = \"\";\n                }\n                // Make `instanceof Error` still work for returned errors.\n                PropTypeError.prototype = Error.prototype;\n                function createChainableTypeChecker(validate) {\n                    if (true) {\n                        var manualPropTypeCallCache = {};\n                        var manualPropTypeWarningCount = 0;\n                    }\n                    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n                        componentName = componentName || ANONYMOUS;\n                        propFullName = propFullName || propName;\n                        if (secret !== ReactPropTypesSecret) {\n                            if (throwOnDirectAccess) {\n                                // New behavior only for users of `prop-types` package\n                                invariant(false, \"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use `PropTypes.checkPropTypes()` to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                            } else if ( true && typeof console !== \"undefined\") {\n                                // Old behavior for people using React.PropTypes\n                                var cacheKey = componentName + \":\" + propName;\n                                if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n                                manualPropTypeWarningCount < 3) {\n                                    warning(false, \"You are manually calling a React.PropTypes validation \" + \"function for the `%s` prop on `%s`. This is deprecated \" + \"and will throw in the standalone `prop-types` package. \" + \"You may be seeing this warning due to a third-party PropTypes \" + \"library. See https://fb.me/react-warning-dont-call-proptypes \" + \"for details.\", propFullName, componentName);\n                                    manualPropTypeCallCache[cacheKey] = true;\n                                    manualPropTypeWarningCount++;\n                                }\n                            }\n                        }\n                        if (props[propName] == null) {\n                            if (isRequired) {\n                                if (props[propName] === null) {\n                                    return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n                                }\n                                return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n                            }\n                            return null;\n                        } else {\n                            return validate(props, propName, componentName, location, propFullName);\n                        }\n                    }\n                    var chainedCheckType = checkType.bind(null, false);\n                    chainedCheckType.isRequired = checkType.bind(null, true);\n                    return chainedCheckType;\n                }\n                function createPrimitiveTypeChecker(expectedType) {\n                    function validate(props, propName, componentName, location, propFullName, secret) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== expectedType) {\n                            // `propValue` being instance of, say, date/regexp, pass the 'object'\n                            // check, but we can offer a more precise error message here rather than\n                            // 'of type `object`'.\n                            var preciseType = getPreciseType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createAnyTypeChecker() {\n                    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n                }\n                function createArrayOfTypeChecker(typeChecker) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (typeof typeChecker !== \"function\") {\n                            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n                        }\n                        var propValue = props[propName];\n                        if (!Array.isArray(propValue)) {\n                            var propType = getPropType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n                        }\n                        for(var i = 0; i < propValue.length; i++){\n                            var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret);\n                            if (error instanceof Error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createElementTypeChecker() {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        if (!isValidElement(propValue)) {\n                            var propType = getPropType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createInstanceTypeChecker(expectedClass) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (!(props[propName] instanceof expectedClass)) {\n                            var expectedClassName = expectedClass.name || ANONYMOUS;\n                            var actualClassName = getClassName(props[propName]);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createEnumTypeChecker(expectedValues) {\n                    if (!Array.isArray(expectedValues)) {\n                         true ? warning(false, \"Invalid argument supplied to oneOf, expected an instance of array.\") : 0;\n                        return emptyFunction.thatReturnsNull;\n                    }\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        for(var i = 0; i < expectedValues.length; i++){\n                            if (is(propValue, expectedValues[i])) {\n                                return null;\n                            }\n                        }\n                        var valuesString = JSON.stringify(expectedValues);\n                        return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + propValue + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createObjectOfTypeChecker(typeChecker) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (typeof typeChecker !== \"function\") {\n                            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n                        }\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n                        }\n                        for(var key in propValue){\n                            if (propValue.hasOwnProperty(key)) {\n                                var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                if (error instanceof Error) {\n                                    return error;\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createUnionTypeChecker(arrayOfTypeCheckers) {\n                    if (!Array.isArray(arrayOfTypeCheckers)) {\n                         true ? warning(false, \"Invalid argument supplied to oneOfType, expected an instance of array.\") : 0;\n                        return emptyFunction.thatReturnsNull;\n                    }\n                    for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                        var checker = arrayOfTypeCheckers[i];\n                        if (typeof checker !== \"function\") {\n                            warning(false, \"Invalid argument supplied to oneOfType. Expected an array of check functions, but \" + \"received %s at index %s.\", getPostfixForTypeWarning(checker), i);\n                            return emptyFunction.thatReturnsNull;\n                        }\n                    }\n                    function validate(props, propName, componentName, location, propFullName) {\n                        for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                            var checker = arrayOfTypeCheckers[i];\n                            if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n                                return null;\n                            }\n                        }\n                        return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`.\"));\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createNodeChecker() {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (!isNode(props[propName])) {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createShapeTypeChecker(shapeTypes) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                        }\n                        for(var key in shapeTypes){\n                            var checker = shapeTypes[key];\n                            if (!checker) {\n                                continue;\n                            }\n                            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                            if (error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createStrictShapeTypeChecker(shapeTypes) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                        }\n                        // We need to check all keys in case some are required but missing from\n                        // props.\n                        var allKeys = assign({}, props[propName], shapeTypes);\n                        for(var key in allKeys){\n                            var checker = shapeTypes[key];\n                            if (!checker) {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\" + \"\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \"));\n                            }\n                            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                            if (error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function isNode(propValue) {\n                    switch(typeof propValue){\n                        case \"number\":\n                        case \"string\":\n                        case \"undefined\":\n                            return true;\n                        case \"boolean\":\n                            return !propValue;\n                        case \"object\":\n                            if (Array.isArray(propValue)) {\n                                return propValue.every(isNode);\n                            }\n                            if (propValue === null || isValidElement(propValue)) {\n                                return true;\n                            }\n                            var iteratorFn = getIteratorFn(propValue);\n                            if (iteratorFn) {\n                                var iterator = iteratorFn.call(propValue);\n                                var step;\n                                if (iteratorFn !== propValue.entries) {\n                                    while(!(step = iterator.next()).done){\n                                        if (!isNode(step.value)) {\n                                            return false;\n                                        }\n                                    }\n                                } else {\n                                    // Iterator will provide entry [k,v] tuples rather than values.\n                                    while(!(step = iterator.next()).done){\n                                        var entry = step.value;\n                                        if (entry) {\n                                            if (!isNode(entry[1])) {\n                                                return false;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                return false;\n                            }\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n                function isSymbol(propType, propValue) {\n                    // Native Symbol.\n                    if (propType === \"symbol\") {\n                        return true;\n                    }\n                    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n                    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n                        return true;\n                    }\n                    // Fallback for non-spec compliant Symbols which are polyfilled.\n                    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n                        return true;\n                    }\n                    return false;\n                }\n                // Equivalent of `typeof` but with special handling for array and regexp.\n                function getPropType(propValue) {\n                    var propType = typeof propValue;\n                    if (Array.isArray(propValue)) {\n                        return \"array\";\n                    }\n                    if (propValue instanceof RegExp) {\n                        // Old webkits (at least until Android 4.0) return 'function' rather than\n                        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n                        // passes PropTypes.object.\n                        return \"object\";\n                    }\n                    if (isSymbol(propType, propValue)) {\n                        return \"symbol\";\n                    }\n                    return propType;\n                }\n                // This handles more types than `getPropType`. Only used for error messages.\n                // See `createPrimitiveTypeChecker`.\n                function getPreciseType(propValue) {\n                    if (typeof propValue === \"undefined\" || propValue === null) {\n                        return \"\" + propValue;\n                    }\n                    var propType = getPropType(propValue);\n                    if (propType === \"object\") {\n                        if (propValue instanceof Date) {\n                            return \"date\";\n                        } else if (propValue instanceof RegExp) {\n                            return \"regexp\";\n                        }\n                    }\n                    return propType;\n                }\n                // Returns a string that is postfixed to a warning about an invalid type.\n                // For example, \"undefined\" or \"of type array\"\n                function getPostfixForTypeWarning(value) {\n                    var type = getPreciseType(value);\n                    switch(type){\n                        case \"array\":\n                        case \"object\":\n                            return \"an \" + type;\n                        case \"boolean\":\n                        case \"date\":\n                        case \"regexp\":\n                            return \"a \" + type;\n                        default:\n                            return type;\n                    }\n                }\n                // Returns class name of the object, if any.\n                function getClassName(propValue) {\n                    if (!propValue.constructor || !propValue.constructor.name) {\n                        return ANONYMOUS;\n                    }\n                    return propValue.constructor.name;\n                }\n                ReactPropTypes.checkPropTypes = checkPropTypes;\n                ReactPropTypes.PropTypes = ReactPropTypes;\n                return ReactPropTypes;\n            };\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_29550__(5));\n    /***/ },\n    /* 7 */ /***/ function(module1, exports) {\n        \"use strict\";\n        /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * \n\t */ function makeEmptyFunction(arg) {\n            return function() {\n                return arg;\n            };\n        }\n        /**\n\t * This function accepts and discards inputs; it has no side effects. This is\n\t * primarily useful idiomatically for overridable function endpoints which\n\t * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n\t */ var emptyFunction = function emptyFunction() {};\n        emptyFunction.thatReturns = makeEmptyFunction;\n        emptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n        emptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n        emptyFunction.thatReturnsNull = makeEmptyFunction(null);\n        emptyFunction.thatReturnsThis = function() {\n            return this;\n        };\n        emptyFunction.thatReturnsArgument = function(arg) {\n            return arg;\n        };\n        module1.exports = emptyFunction;\n    /***/ },\n    /* 8 */ /***/ function(module1, exports, __nested_webpack_require_57082__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            \"use strict\";\n            /**\n\t * Use invariant() to assert state which your program assumes to be true.\n\t *\n\t * Provide sprintf-style format (only %s is supported) and arguments\n\t * to provide information about what broke and what you were\n\t * expecting.\n\t *\n\t * The invariant message will be stripped in production, but the invariant\n\t * will remain to ensure logic does not differ in production.\n\t */ var validateFormat = function validateFormat(format) {};\n            if (true) {\n                validateFormat = function validateFormat(format) {\n                    if (format === undefined) {\n                        throw new Error(\"invariant requires an error message argument\");\n                    }\n                };\n            }\n            function invariant(condition, format, a, b, c, d, e, f) {\n                validateFormat(format);\n                if (!condition) {\n                    var error;\n                    if (format === undefined) {\n                        error = new Error(\"Minified exception occurred; use the non-minified dev environment \" + \"for the full error message and additional helpful warnings.\");\n                    } else {\n                        var args = [\n                            a,\n                            b,\n                            c,\n                            d,\n                            e,\n                            f\n                        ];\n                        var argIndex = 0;\n                        error = new Error(format.replace(/%s/g, function() {\n                            return args[argIndex++];\n                        }));\n                        error.name = \"Invariant Violation\";\n                    }\n                    error.framesToPop = 1; // we don't care about invariant's own frame\n                    throw error;\n                }\n            }\n            module1.exports = invariant;\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_57082__(5));\n    /***/ },\n    /* 9 */ /***/ function(module1, exports, __nested_webpack_require_59235__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            \"use strict\";\n            var emptyFunction = __nested_webpack_require_59235__(7);\n            /**\n\t * Similar to invariant but only logs a warning if the condition is not met.\n\t * This can be used to log issues in development environments in critical\n\t * paths. Removing the logging code for production environments will keep the\n\t * same logic and follow the same code paths.\n\t */ var warning = emptyFunction;\n            if (true) {\n                var printWarning = function printWarning(format) {\n                    for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    var argIndex = 0;\n                    var message = \"Warning: \" + format.replace(/%s/g, function() {\n                        return args[argIndex++];\n                    });\n                    if (typeof console !== \"undefined\") {\n                        console.error(message);\n                    }\n                    try {\n                        // --- Welcome to debugging React ---\n                        // This error was thrown as a convenience so that you can use this stack\n                        // to find the callsite that caused this warning to fire.\n                        throw new Error(message);\n                    } catch (x) {}\n                };\n                warning = function warning(condition, format) {\n                    if (format === undefined) {\n                        throw new Error(\"`warning(condition, format, ...args)` requires a warning \" + \"message argument\");\n                    }\n                    if (format.indexOf(\"Failed Composite propType: \") === 0) {\n                        return; // Ignore CompositeComponent proptype check.\n                    }\n                    if (!condition) {\n                        for(var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){\n                            args[_key2 - 2] = arguments[_key2];\n                        }\n                        printWarning.apply(undefined, [\n                            format\n                        ].concat(args));\n                    }\n                };\n            }\n            module1.exports = warning;\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_59235__(5));\n    /***/ },\n    /* 10 */ /***/ function(module1, exports) {\n        /*\n\tobject-assign\n\t(c) Sindre Sorhus\n\t@license MIT\n\t*/ \"use strict\";\n        /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n        function toObject(val) {\n            if (val === null || val === undefined) {\n                throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n            }\n            return Object(val);\n        }\n        function shouldUseNative() {\n            try {\n                if (!Object.assign) {\n                    return false;\n                }\n                // Detect buggy property enumeration order in older V8 versions.\n                // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n                var test1 = new String(\"abc\"); // eslint-disable-line no-new-wrappers\n                test1[5] = \"de\";\n                if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n                    return false;\n                }\n                // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                var test2 = {};\n                for(var i = 0; i < 10; i++){\n                    test2[\"_\" + String.fromCharCode(i)] = i;\n                }\n                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n                    return test2[n];\n                });\n                if (order2.join(\"\") !== \"0123456789\") {\n                    return false;\n                }\n                // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                var test3 = {};\n                \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n                    test3[letter] = letter;\n                });\n                if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n                    return false;\n                }\n                return true;\n            } catch (err) {\n                // We don't expect any of the above to throw, but better to be safe.\n                return false;\n            }\n        }\n        module1.exports = shouldUseNative() ? Object.assign : function(target, source) {\n            var from;\n            var to = toObject(target);\n            var symbols;\n            for(var s = 1; s < arguments.length; s++){\n                from = Object(arguments[s]);\n                for(var key in from){\n                    if (hasOwnProperty.call(from, key)) {\n                        to[key] = from[key];\n                    }\n                }\n                if (getOwnPropertySymbols) {\n                    symbols = getOwnPropertySymbols(from);\n                    for(var i = 0; i < symbols.length; i++){\n                        if (propIsEnumerable.call(from, symbols[i])) {\n                            to[symbols[i]] = from[symbols[i]];\n                        }\n                    }\n                }\n            }\n            return to;\n        };\n    /***/ },\n    /* 11 */ /***/ function(module1, exports) {\n        /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t */ \"use strict\";\n        var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n        module1.exports = ReactPropTypesSecret;\n    /***/ },\n    /* 12 */ /***/ function(module1, exports, __nested_webpack_require_65280__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            \"use strict\";\n            if (true) {\n                var invariant = __nested_webpack_require_65280__(8);\n                var warning = __nested_webpack_require_65280__(9);\n                var ReactPropTypesSecret = __nested_webpack_require_65280__(11);\n                var loggedTypeFailures = {};\n            }\n            /**\n\t * Assert that the values match with the type specs.\n\t * Error messages are memorized and will only be shown once.\n\t *\n\t * @param {object} typeSpecs Map of name to a ReactPropType\n\t * @param {object} values Runtime values that need to be type-checked\n\t * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n\t * @param {string} componentName Name of the component for error messages.\n\t * @param {?Function} getStack Returns the component stack.\n\t * @private\n\t */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n                if (true) {\n                    for(var typeSpecName in typeSpecs){\n                        if (typeSpecs.hasOwnProperty(typeSpecName)) {\n                            var error;\n                            // Prop type validation may throw. In case they do, we don't want to\n                            // fail the render phase where it didn't fail before. So we log it.\n                            // After these have been cleaned up, we'll let them throw.\n                            try {\n                                // This is intentionally an invariant that gets caught. It's the same\n                                // behavior as without this statement except with a better message.\n                                invariant(typeof typeSpecs[typeSpecName] === \"function\", \"%s: %s type `%s` is invalid; it must be a function, usually from \" + \"the `prop-types` package, but received `%s`.\", componentName || \"React class\", location, typeSpecName, typeof typeSpecs[typeSpecName]);\n                                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n                            } catch (ex) {\n                                error = ex;\n                            }\n                            warning(!error || error instanceof Error, \"%s: type specification of %s `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error);\n                            if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                                // Only monitor this failure once because there tends to be a lot of the\n                                // same error.\n                                loggedTypeFailures[error.message] = true;\n                                var stack = getStack ? getStack() : \"\";\n                                warning(false, \"Failed %s type: %s%s\", location, error.message, stack != null ? stack : \"\");\n                            }\n                        }\n                    }\n                }\n            }\n            module1.exports = checkPropTypes;\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_65280__(5));\n    /***/ },\n    /* 13 */ /***/ function(module1, exports, __nested_webpack_require_68794__) {\n        /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t */ \"use strict\";\n        var emptyFunction = __nested_webpack_require_68794__(7);\n        var invariant = __nested_webpack_require_68794__(8);\n        var ReactPropTypesSecret = __nested_webpack_require_68794__(11);\n        module1.exports = function() {\n            function shim(props, propName, componentName, location, propFullName, secret) {\n                if (secret === ReactPropTypesSecret) {\n                    // It is still safe when called from React.\n                    return;\n                }\n                invariant(false, \"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use PropTypes.checkPropTypes() to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n            }\n            ;\n            shim.isRequired = shim;\n            function getShim() {\n                return shim;\n            }\n            ;\n            // Important!\n            // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n            var ReactPropTypes = {\n                array: shim,\n                bool: shim,\n                func: shim,\n                number: shim,\n                object: shim,\n                string: shim,\n                symbol: shim,\n                any: shim,\n                arrayOf: getShim,\n                element: shim,\n                instanceOf: getShim,\n                node: shim,\n                objectOf: getShim,\n                oneOf: getShim,\n                oneOfType: getShim,\n                shape: getShim,\n                exact: getShim\n            };\n            ReactPropTypes.checkPropTypes = emptyFunction;\n            ReactPropTypes.PropTypes = ReactPropTypes;\n            return ReactPropTypes;\n        };\n    /***/ },\n    /* 14 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n    /***/ },\n    /* 15 */ /***/ function(module1, exports) {\n        \"use strict\";\n        var simpleIsEqual = function simpleIsEqual(a, b) {\n            return a === b;\n        };\n        function index(resultFn) {\n            var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : simpleIsEqual;\n            var lastThis = void 0;\n            var lastArgs = [];\n            var lastResult = void 0;\n            var calledOnce = false;\n            var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {\n                return isEqual(newArg, lastArgs[index]);\n            };\n            var result = function result() {\n                for(var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++){\n                    newArgs[_key] = arguments[_key];\n                }\n                if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {\n                    return lastResult;\n                }\n                calledOnce = true;\n                lastThis = this;\n                lastArgs = newArgs;\n                lastResult = resultFn.apply(this, newArgs);\n                return lastResult;\n            };\n            return result;\n        }\n        module1.exports = index;\n    /***/ }\n]); //# sourceMappingURL=main.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaGlnaGxpZ2h0LXdvcmRzL2Rpc3QvbWFpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUNMLE1BQUgsR0FBSSxTQUFTQyxPQUFPO0lBQzFCLE1BQU0sR0FBSSxtQkFBbUI7SUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO0lBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO0lBQ2pDLE1BQU0sR0FBSSxTQUFTQyw4QkFBbUJBLENBQUNDLFFBQVE7UUFDL0MsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7UUFDekMsTUFBTSxHQUFLLElBQUdGLGdCQUFnQixDQUFDRSxTQUFTLEVBQ3hDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDSixPQUFPO1FBQ3JELE1BQU0sR0FDTixNQUFNLEdBQUssa0RBQWtEO1FBQzdELE1BQU0sR0FBSyxJQUFJRCxVQUFTRyxnQkFBZ0IsQ0FBQ0UsU0FBUyxHQUFHO1lBQ3JELE1BQU0sR0FBTUosU0FBUyxDQUFDO1lBQ3RCLE1BQU0sR0FBTUssSUFBSUQ7WUFDaEIsTUFBTSxHQUFNRSxRQUFRO1FBQ1Q7UUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtRQUN6QyxNQUFNLEdBQUtMLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNSLFFBQU9DLE9BQU8sRUFBRUQsU0FBUUEsUUFBT0MsT0FBTyxFQUFFRyw4QkFBbUJBO1FBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1FBQ3ZDLE1BQU0sR0FBS0osUUFBT08sTUFBTSxHQUFHO1FBQzNCLE1BQU0sR0FDTixNQUFNLEdBQUssbUNBQW1DO1FBQzlDLE1BQU0sR0FBSyxPQUFPUCxRQUFPQyxPQUFPO0lBQ2hDLE1BQU0sR0FBSTtJQUNWLE1BQU0sR0FDTixNQUFNLEdBQ04sTUFBTSxHQUFJLGtEQUFrRDtJQUM1RCxNQUFNLEdBQUlHLDhCQUFtQkEsQ0FBQ0ss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Y0FBYzNDLENBQUMsRUFBRUMsQ0FBQztZQUM3QyxPQUFPRCxNQUFNQztRQUNmO1FBRUEsU0FBUzNNLE1BQU9zUCxRQUFRO1lBQ3RCLElBQUlDLFVBQVU1VCxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBSzZDLFlBQVk3QyxTQUFTLENBQUMsRUFBRSxHQUFHMFQ7WUFFbEYsSUFBSUcsV0FBVyxLQUFLO1lBQ3BCLElBQUlDLFdBQVcsRUFBRTtZQUNqQixJQUFJQyxhQUFhLEtBQUs7WUFDdEIsSUFBSUMsYUFBYTtZQUVqQixJQUFJQyxzQkFBc0IsU0FBU0Esb0JBQW9CQyxNQUFNLEVBQUU3UCxLQUFLO2dCQUNsRSxPQUFPdVAsUUFBUU0sUUFBUUosUUFBUSxDQUFDelAsTUFBTTtZQUN4QztZQUVBLElBQUk4UCxTQUFTLFNBQVNBO2dCQUNwQixJQUFLLElBQUk3QyxPQUFPdFIsVUFBVUMsTUFBTSxFQUFFbVUsVUFBVWhMLE1BQU1rSSxPQUFPQyxPQUFPLEdBQUdBLE9BQU9ELE1BQU1DLE9BQVE7b0JBQ3RGNkMsT0FBTyxDQUFDN0MsS0FBSyxHQUFHdlIsU0FBUyxDQUFDdVIsS0FBSztnQkFDakM7Z0JBRUEsSUFBSXlDLGNBQWNILGFBQWEsSUFBSSxJQUFJTyxRQUFRblUsTUFBTSxLQUFLNlQsU0FBUzdULE1BQU0sSUFBSW1VLFFBQVExRSxLQUFLLENBQUN1RSxzQkFBc0I7b0JBQy9HLE9BQU9GO2dCQUNUO2dCQUVBQyxhQUFhO2dCQUNiSCxXQUFXLElBQUk7Z0JBQ2ZDLFdBQVdNO2dCQUNYTCxhQUFhSixTQUFTcEssS0FBSyxDQUFDLElBQUksRUFBRTZLO2dCQUNsQyxPQUFPTDtZQUNUO1lBRUEsT0FBT0k7UUFDVDtRQUVBM1YsUUFBT0MsT0FBTyxHQUFHNEY7SUFHbEIsR0FBRyxHQUFHO0NBQ0ksR0FDVixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaGlnaGxpZ2h0LXdvcmRzL2Rpc3QvbWFpbi5qcz9iNWRmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cdFxuXHR2YXIgX0hpZ2hsaWdodGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XG5cdHZhciBfSGlnaGxpZ2h0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSGlnaGxpZ2h0ZXIpO1xuXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IF9IaWdobGlnaHRlcjJbJ2RlZmF1bHQnXTtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cdFxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBIaWdobGlnaHRlcjtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblx0XG5cdHZhciBfaGlnaGxpZ2h0V29yZHNDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XG5cdHZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdHZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cdFxuXHR2YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdFxuXHR2YXIgX21lbW9pemVPbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0XG5cdHZhciBfbWVtb2l6ZU9uZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZW1vaXplT25lKTtcblx0XG5cdEhpZ2hsaWdodGVyLnByb3BUeXBlcyA9IHtcblx0ICBhY3RpdmVDbGFzc05hbWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuXHQgIGFjdGl2ZUluZGV4OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm51bWJlcixcblx0ICBhY3RpdmVTdHlsZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QsXG5cdCAgYXV0b0VzY2FwZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ib29sLFxuXHQgIGNsYXNzTmFtZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcsXG5cdCAgZmluZENodW5rczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIGhpZ2hsaWdodENsYXNzTmFtZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZ10pLFxuXHQgIGhpZ2hsaWdodFN0eWxlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdCxcblx0ICBoaWdobGlnaHRUYWc6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm5vZGUsIF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYywgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmddKSxcblx0ICBzYW5pdGl6ZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLFxuXHQgIHNlYXJjaFdvcmRzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmFycmF5T2YoX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmluc3RhbmNlT2YoUmVnRXhwKV0pKS5pc1JlcXVpcmVkLFxuXHQgIHRleHRUb0hpZ2hsaWdodDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcuaXNSZXF1aXJlZCxcblx0ICB1bmhpZ2hsaWdodFRhZzogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10ubm9kZSwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZ10pLFxuXHQgIHVuaGlnaGxpZ2h0Q2xhc3NOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcblx0ICB1bmhpZ2hsaWdodFN0eWxlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdFxuXHR9O1xuXHRcblx0LyoqXHJcblx0ICogSGlnaGxpZ2h0cyBhbGwgb2NjdXJyZW5jZXMgb2Ygc2VhcmNoIHRlcm1zIChzZWFyY2hUZXh0KSB3aXRoaW4gYSBzdHJpbmcgKHRleHRUb0hpZ2hsaWdodCkuXHJcblx0ICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIDxzcGFuPnMgKHdyYXBwaW5nIGhpZ2hsaWdodGVkIHdvcmRzKS5cclxuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIEhpZ2hsaWdodGVyKF9yZWYpIHtcblx0ICB2YXIgX3JlZiRhY3RpdmVDbGFzc05hbWUgPSBfcmVmLmFjdGl2ZUNsYXNzTmFtZTtcblx0ICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gX3JlZiRhY3RpdmVDbGFzc05hbWUgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRhY3RpdmVDbGFzc05hbWU7XG5cdCAgdmFyIF9yZWYkYWN0aXZlSW5kZXggPSBfcmVmLmFjdGl2ZUluZGV4O1xuXHQgIHZhciBhY3RpdmVJbmRleCA9IF9yZWYkYWN0aXZlSW5kZXggPT09IHVuZGVmaW5lZCA/IC0xIDogX3JlZiRhY3RpdmVJbmRleDtcblx0ICB2YXIgYWN0aXZlU3R5bGUgPSBfcmVmLmFjdGl2ZVN0eWxlO1xuXHQgIHZhciBhdXRvRXNjYXBlID0gX3JlZi5hdXRvRXNjYXBlO1xuXHQgIHZhciBfcmVmJGNhc2VTZW5zaXRpdmUgPSBfcmVmLmNhc2VTZW5zaXRpdmU7XG5cdCAgdmFyIGNhc2VTZW5zaXRpdmUgPSBfcmVmJGNhc2VTZW5zaXRpdmUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRjYXNlU2Vuc2l0aXZlO1xuXHQgIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZTtcblx0ICB2YXIgZmluZENodW5rcyA9IF9yZWYuZmluZENodW5rcztcblx0ICB2YXIgX3JlZiRoaWdobGlnaHRDbGFzc05hbWUgPSBfcmVmLmhpZ2hsaWdodENsYXNzTmFtZTtcblx0ICB2YXIgaGlnaGxpZ2h0Q2xhc3NOYW1lID0gX3JlZiRoaWdobGlnaHRDbGFzc05hbWUgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRoaWdobGlnaHRDbGFzc05hbWU7XG5cdCAgdmFyIF9yZWYkaGlnaGxpZ2h0U3R5bGUgPSBfcmVmLmhpZ2hsaWdodFN0eWxlO1xuXHQgIHZhciBoaWdobGlnaHRTdHlsZSA9IF9yZWYkaGlnaGxpZ2h0U3R5bGUgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZiRoaWdobGlnaHRTdHlsZTtcblx0ICB2YXIgX3JlZiRoaWdobGlnaHRUYWcgPSBfcmVmLmhpZ2hsaWdodFRhZztcblx0ICB2YXIgaGlnaGxpZ2h0VGFnID0gX3JlZiRoaWdobGlnaHRUYWcgPT09IHVuZGVmaW5lZCA/ICdtYXJrJyA6IF9yZWYkaGlnaGxpZ2h0VGFnO1xuXHQgIHZhciBzYW5pdGl6ZSA9IF9yZWYuc2FuaXRpemU7XG5cdCAgdmFyIHNlYXJjaFdvcmRzID0gX3JlZi5zZWFyY2hXb3Jkcztcblx0ICB2YXIgdGV4dFRvSGlnaGxpZ2h0ID0gX3JlZi50ZXh0VG9IaWdobGlnaHQ7XG5cdCAgdmFyIF9yZWYkdW5oaWdobGlnaHRUYWcgPSBfcmVmLnVuaGlnaGxpZ2h0VGFnO1xuXHQgIHZhciB1bmhpZ2hsaWdodFRhZyA9IF9yZWYkdW5oaWdobGlnaHRUYWcgPT09IHVuZGVmaW5lZCA/ICdzcGFuJyA6IF9yZWYkdW5oaWdobGlnaHRUYWc7XG5cdCAgdmFyIF9yZWYkdW5oaWdobGlnaHRDbGFzc05hbWUgPSBfcmVmLnVuaGlnaGxpZ2h0Q2xhc3NOYW1lO1xuXHQgIHZhciB1bmhpZ2hsaWdodENsYXNzTmFtZSA9IF9yZWYkdW5oaWdobGlnaHRDbGFzc05hbWUgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiR1bmhpZ2hsaWdodENsYXNzTmFtZTtcblx0ICB2YXIgdW5oaWdobGlnaHRTdHlsZSA9IF9yZWYudW5oaWdobGlnaHRTdHlsZTtcblx0XG5cdCAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydhY3RpdmVDbGFzc05hbWUnLCAnYWN0aXZlSW5kZXgnLCAnYWN0aXZlU3R5bGUnLCAnYXV0b0VzY2FwZScsICdjYXNlU2Vuc2l0aXZlJywgJ2NsYXNzTmFtZScsICdmaW5kQ2h1bmtzJywgJ2hpZ2hsaWdodENsYXNzTmFtZScsICdoaWdobGlnaHRTdHlsZScsICdoaWdobGlnaHRUYWcnLCAnc2FuaXRpemUnLCAnc2VhcmNoV29yZHMnLCAndGV4dFRvSGlnaGxpZ2h0JywgJ3VuaGlnaGxpZ2h0VGFnJywgJ3VuaGlnaGxpZ2h0Q2xhc3NOYW1lJywgJ3VuaGlnaGxpZ2h0U3R5bGUnXSk7XG5cdFxuXHQgIHZhciBjaHVua3MgPSAoMCwgX2hpZ2hsaWdodFdvcmRzQ29yZS5maW5kQWxsKSh7XG5cdCAgICBhdXRvRXNjYXBlOiBhdXRvRXNjYXBlLFxuXHQgICAgY2FzZVNlbnNpdGl2ZTogY2FzZVNlbnNpdGl2ZSxcblx0ICAgIGZpbmRDaHVua3M6IGZpbmRDaHVua3MsXG5cdCAgICBzYW5pdGl6ZTogc2FuaXRpemUsXG5cdCAgICBzZWFyY2hXb3Jkczogc2VhcmNoV29yZHMsXG5cdCAgICB0ZXh0VG9IaWdobGlnaHQ6IHRleHRUb0hpZ2hsaWdodFxuXHQgIH0pO1xuXHQgIHZhciBIaWdobGlnaHRUYWcgPSBoaWdobGlnaHRUYWc7XG5cdCAgdmFyIGhpZ2hsaWdodEluZGV4ID0gLTE7XG5cdCAgdmFyIGhpZ2hsaWdodENsYXNzTmFtZXMgPSAnJztcblx0ICB2YXIgaGlnaGxpZ2h0U3R5bGVzID0gdW5kZWZpbmVkO1xuXHRcblx0ICB2YXIgbG93ZXJjYXNlUHJvcHMgPSBmdW5jdGlvbiBsb3dlcmNhc2VQcm9wcyhvYmplY3QpIHtcblx0ICAgIHZhciBtYXBwZWQgPSB7fTtcblx0ICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcblx0ICAgICAgbWFwcGVkW2tleS50b0xvd2VyQ2FzZSgpXSA9IG9iamVjdFtrZXldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG1hcHBlZDtcblx0ICB9O1xuXHQgIHZhciBtZW1vaXplZExvd2VyY2FzZVByb3BzID0gKDAsIF9tZW1vaXplT25lMlsnZGVmYXVsdCddKShsb3dlcmNhc2VQcm9wcyk7XG5cdFxuXHQgIHJldHVybiAoMCwgX3JlYWN0LmNyZWF0ZUVsZW1lbnQpKCdzcGFuJywgX2V4dGVuZHMoe1xuXHQgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcblx0ICB9LCByZXN0LCB7XG5cdCAgICBjaGlsZHJlbjogY2h1bmtzLm1hcChmdW5jdGlvbiAoY2h1bmssIGluZGV4KSB7XG5cdCAgICAgIHZhciB0ZXh0ID0gdGV4dFRvSGlnaGxpZ2h0LnN1YnN0cihjaHVuay5zdGFydCwgY2h1bmsuZW5kIC0gY2h1bmsuc3RhcnQpO1xuXHRcblx0ICAgICAgaWYgKGNodW5rLmhpZ2hsaWdodCkge1xuXHQgICAgICAgIGhpZ2hsaWdodEluZGV4Kys7XG5cdFxuXHQgICAgICAgIHZhciBoaWdobGlnaHRDbGFzcyA9IHVuZGVmaW5lZDtcblx0ICAgICAgICBpZiAodHlwZW9mIGhpZ2hsaWdodENsYXNzTmFtZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuXHQgICAgICAgICAgICBoaWdobGlnaHRDbGFzc05hbWUgPSBtZW1vaXplZExvd2VyY2FzZVByb3BzKGhpZ2hsaWdodENsYXNzTmFtZSk7XG5cdCAgICAgICAgICAgIGhpZ2hsaWdodENsYXNzID0gaGlnaGxpZ2h0Q2xhc3NOYW1lW3RleHQudG9Mb3dlckNhc2UoKV07XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBoaWdobGlnaHRDbGFzcyA9IGhpZ2hsaWdodENsYXNzTmFtZVt0ZXh0XTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaGlnaGxpZ2h0Q2xhc3MgPSBoaWdobGlnaHRDbGFzc05hbWU7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICB2YXIgaXNBY3RpdmUgPSBoaWdobGlnaHRJbmRleCA9PT0gK2FjdGl2ZUluZGV4O1xuXHRcblx0ICAgICAgICBoaWdobGlnaHRDbGFzc05hbWVzID0gaGlnaGxpZ2h0Q2xhc3MgKyAnICcgKyAoaXNBY3RpdmUgPyBhY3RpdmVDbGFzc05hbWUgOiAnJyk7XG5cdCAgICAgICAgaGlnaGxpZ2h0U3R5bGVzID0gaXNBY3RpdmUgPT09IHRydWUgJiYgYWN0aXZlU3R5bGUgIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24oe30sIGhpZ2hsaWdodFN0eWxlLCBhY3RpdmVTdHlsZSkgOiBoaWdobGlnaHRTdHlsZTtcblx0XG5cdCAgICAgICAgdmFyIHByb3BzID0ge1xuXHQgICAgICAgICAgY2hpbGRyZW46IHRleHQsXG5cdCAgICAgICAgICBjbGFzc05hbWU6IGhpZ2hsaWdodENsYXNzTmFtZXMsXG5cdCAgICAgICAgICBrZXk6IGluZGV4LFxuXHQgICAgICAgICAgc3R5bGU6IGhpZ2hsaWdodFN0eWxlc1xuXHQgICAgICAgIH07XG5cdFxuXHQgICAgICAgIC8vIERvbid0IGF0dGFjaCBhcmJpdHJhcnkgcHJvcHMgdG8gRE9NIGVsZW1lbnRzOyB0aGlzIHRyaWdnZXJzIFJlYWN0IERFViB3YXJuaW5ncyAoaHR0cHM6Ly9mYi5tZS9yZWFjdC11bmtub3duLXByb3ApXG5cdCAgICAgICAgLy8gT25seSBwYXNzIHRocm91Z2ggdGhlIGhpZ2hsaWdodEluZGV4IGF0dHJpYnV0ZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMuXG5cdCAgICAgICAgaWYgKHR5cGVvZiBIaWdobGlnaHRUYWcgIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICBwcm9wcy5oaWdobGlnaHRJbmRleCA9IGhpZ2hsaWdodEluZGV4O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgcmV0dXJuICgwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkoSGlnaGxpZ2h0VGFnLCBwcm9wcyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuICgwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkodW5oaWdobGlnaHRUYWcsIHtcblx0ICAgICAgICAgIGNoaWxkcmVuOiB0ZXh0LFxuXHQgICAgICAgICAgY2xhc3NOYW1lOiB1bmhpZ2hsaWdodENsYXNzTmFtZSxcblx0ICAgICAgICAgIGtleTogaW5kZXgsXG5cdCAgICAgICAgICBzdHlsZTogdW5oaWdobGlnaHRTdHlsZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9KVxuXHQgIH0pKTtcblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID1cblx0LyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuXHQvKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcblx0LyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5cdC8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdC8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcblx0LyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHQvKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHQvKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcblx0LyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuXHQvKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG5cdC8qKioqKiovIFx0XHR9O1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdC8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0LyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0LyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcblx0LyoqKioqKi8gXHR9XG5cdC8qKioqKiovXG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5cdC8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cdC8qKioqKiovIH0pXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKiovIChbXG5cdC8qIDAgKi9cblx0LyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFxuXHRcblx0LyoqKi8gfSksXG5cdC8qIDEgKi9cblx0LyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHQndXNlIHN0cmljdCc7XG5cdFx0XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICB2YWx1ZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdFxuXHRcdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcdFxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY29tYmluZUNodW5rcycsIHtcblx0XHQgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHQgICAgcmV0dXJuIF91dGlscy5jb21iaW5lQ2h1bmtzO1xuXHRcdCAgfVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZmlsbEluQ2h1bmtzJywge1xuXHRcdCAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdCAgICByZXR1cm4gX3V0aWxzLmZpbGxJbkNodW5rcztcblx0XHQgIH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2ZpbmRBbGwnLCB7XG5cdFx0ICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0ICAgIHJldHVybiBfdXRpbHMuZmluZEFsbDtcblx0XHQgIH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2ZpbmRDaHVua3MnLCB7XG5cdFx0ICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0ICAgIHJldHVybiBfdXRpbHMuZmluZENodW5rcztcblx0XHQgIH1cblx0XHR9KTtcblx0XG5cdC8qKiovIH0pLFxuXHQvKiAyICovXG5cdC8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0J3VzZSBzdHJpY3QnO1xuXHRcdFxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdCAgdmFsdWU6IHRydWVcblx0XHR9KTtcblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGNodW5rIG9iamVjdHMgcmVwcmVzZW50aW5nIGJvdGggaGlnbGlnaHRhYmxlIGFuZCBub24gaGlnaGxpZ2h0YWJsZSBwaWVjZXMgb2YgdGV4dCB0aGF0IG1hdGNoIGVhY2ggc2VhcmNoIHdvcmQuXG5cdFx0ICogQHJldHVybiBBcnJheSBvZiBcImNodW5rc1wiICh3aGVyZSBhIENodW5rIGlzIHsgc3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyLCBoaWdobGlnaHQ6Ym9vbGVhbiB9KVxuXHRcdCAqL1xuXHRcdHZhciBmaW5kQWxsID0gZXhwb3J0cy5maW5kQWxsID0gZnVuY3Rpb24gZmluZEFsbChfcmVmKSB7XG5cdFx0ICB2YXIgYXV0b0VzY2FwZSA9IF9yZWYuYXV0b0VzY2FwZSxcblx0XHQgICAgICBfcmVmJGNhc2VTZW5zaXRpdmUgPSBfcmVmLmNhc2VTZW5zaXRpdmUsXG5cdFx0ICAgICAgY2FzZVNlbnNpdGl2ZSA9IF9yZWYkY2FzZVNlbnNpdGl2ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGNhc2VTZW5zaXRpdmUsXG5cdFx0ICAgICAgX3JlZiRmaW5kQ2h1bmtzID0gX3JlZi5maW5kQ2h1bmtzLFxuXHRcdCAgICAgIGZpbmRDaHVua3MgPSBfcmVmJGZpbmRDaHVua3MgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRGaW5kQ2h1bmtzIDogX3JlZiRmaW5kQ2h1bmtzLFxuXHRcdCAgICAgIHNhbml0aXplID0gX3JlZi5zYW5pdGl6ZSxcblx0XHQgICAgICBzZWFyY2hXb3JkcyA9IF9yZWYuc2VhcmNoV29yZHMsXG5cdFx0ICAgICAgdGV4dFRvSGlnaGxpZ2h0ID0gX3JlZi50ZXh0VG9IaWdobGlnaHQ7XG5cdFx0ICByZXR1cm4gZmlsbEluQ2h1bmtzKHtcblx0XHQgICAgY2h1bmtzVG9IaWdobGlnaHQ6IGNvbWJpbmVDaHVua3Moe1xuXHRcdCAgICAgIGNodW5rczogZmluZENodW5rcyh7XG5cdFx0ICAgICAgICBhdXRvRXNjYXBlOiBhdXRvRXNjYXBlLFxuXHRcdCAgICAgICAgY2FzZVNlbnNpdGl2ZTogY2FzZVNlbnNpdGl2ZSxcblx0XHQgICAgICAgIHNhbml0aXplOiBzYW5pdGl6ZSxcblx0XHQgICAgICAgIHNlYXJjaFdvcmRzOiBzZWFyY2hXb3Jkcyxcblx0XHQgICAgICAgIHRleHRUb0hpZ2hsaWdodDogdGV4dFRvSGlnaGxpZ2h0XG5cdFx0ICAgICAgfSlcblx0XHQgICAgfSksXG5cdFx0ICAgIHRvdGFsTGVuZ3RoOiB0ZXh0VG9IaWdobGlnaHQgPyB0ZXh0VG9IaWdobGlnaHQubGVuZ3RoIDogMFxuXHRcdCAgfSk7XG5cdFx0fTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBUYWtlcyBhbiBhcnJheSBvZiB7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfSBvYmplY3RzIGFuZCBjb21iaW5lcyBjaHVua3MgdGhhdCBvdmVybGFwIGludG8gc2luZ2xlIGNodW5rcy5cblx0XHQgKiBAcmV0dXJuIHtzdGFydDpudW1iZXIsIGVuZDpudW1iZXJ9W11cblx0XHQgKi9cblx0XHR2YXIgY29tYmluZUNodW5rcyA9IGV4cG9ydHMuY29tYmluZUNodW5rcyA9IGZ1bmN0aW9uIGNvbWJpbmVDaHVua3MoX3JlZjIpIHtcblx0XHQgIHZhciBjaHVua3MgPSBfcmVmMi5jaHVua3M7XG5cdFx0XG5cdFx0ICBjaHVua3MgPSBjaHVua3Muc29ydChmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuXHRcdCAgICByZXR1cm4gZmlyc3Quc3RhcnQgLSBzZWNvbmQuc3RhcnQ7XG5cdFx0ICB9KS5yZWR1Y2UoZnVuY3Rpb24gKHByb2Nlc3NlZENodW5rcywgbmV4dENodW5rKSB7XG5cdFx0ICAgIC8vIEZpcnN0IGNodW5rIGp1c3QgZ29lcyBzdHJhaWdodCBpbiB0aGUgYXJyYXkuLi5cblx0XHQgICAgaWYgKHByb2Nlc3NlZENodW5rcy5sZW5ndGggPT09IDApIHtcblx0XHQgICAgICByZXR1cm4gW25leHRDaHVua107XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgLy8gLi4uIHN1YnNlcXVlbnQgY2h1bmtzIGdldCBjaGVja2VkIHRvIHNlZSBpZiB0aGV5IG92ZXJsYXAuLi5cblx0XHQgICAgICB2YXIgcHJldkNodW5rID0gcHJvY2Vzc2VkQ2h1bmtzLnBvcCgpO1xuXHRcdCAgICAgIGlmIChuZXh0Q2h1bmsuc3RhcnQgPD0gcHJldkNodW5rLmVuZCkge1xuXHRcdCAgICAgICAgLy8gSXQgbWF5IGJlIHRoZSBjYXNlIHRoYXQgcHJldkNodW5rIGNvbXBsZXRlbHkgc3Vycm91bmRzIG5leHRDaHVuaywgc28gdGFrZSB0aGVcblx0XHQgICAgICAgIC8vIGxhcmdlc3Qgb2YgdGhlIGVuZCBpbmRlY2VzLlxuXHRcdCAgICAgICAgdmFyIGVuZEluZGV4ID0gTWF0aC5tYXgocHJldkNodW5rLmVuZCwgbmV4dENodW5rLmVuZCk7XG5cdFx0ICAgICAgICBwcm9jZXNzZWRDaHVua3MucHVzaCh7IHN0YXJ0OiBwcmV2Q2h1bmsuc3RhcnQsIGVuZDogZW5kSW5kZXggfSk7XG5cdFx0ICAgICAgfSBlbHNlIHtcblx0XHQgICAgICAgIHByb2Nlc3NlZENodW5rcy5wdXNoKHByZXZDaHVuaywgbmV4dENodW5rKTtcblx0XHQgICAgICB9XG5cdFx0ICAgICAgcmV0dXJuIHByb2Nlc3NlZENodW5rcztcblx0XHQgICAgfVxuXHRcdCAgfSwgW10pO1xuXHRcdFxuXHRcdCAgcmV0dXJuIGNodW5rcztcblx0XHR9O1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4YW1pbmUgdGV4dCBmb3IgYW55IG1hdGNoZXMuXG5cdFx0ICogSWYgd2UgZmluZCBtYXRjaGVzLCBhZGQgdGhlbSB0byB0aGUgcmV0dXJuZWQgYXJyYXkgYXMgYSBcImNodW5rXCIgb2JqZWN0ICh7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfSkuXG5cdFx0ICogQHJldHVybiB7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfVtdXG5cdFx0ICovXG5cdFx0dmFyIGRlZmF1bHRGaW5kQ2h1bmtzID0gZnVuY3Rpb24gZGVmYXVsdEZpbmRDaHVua3MoX3JlZjMpIHtcblx0XHQgIHZhciBhdXRvRXNjYXBlID0gX3JlZjMuYXV0b0VzY2FwZSxcblx0XHQgICAgICBjYXNlU2Vuc2l0aXZlID0gX3JlZjMuY2FzZVNlbnNpdGl2ZSxcblx0XHQgICAgICBfcmVmMyRzYW5pdGl6ZSA9IF9yZWYzLnNhbml0aXplLFxuXHRcdCAgICAgIHNhbml0aXplID0gX3JlZjMkc2FuaXRpemUgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogX3JlZjMkc2FuaXRpemUsXG5cdFx0ICAgICAgc2VhcmNoV29yZHMgPSBfcmVmMy5zZWFyY2hXb3Jkcyxcblx0XHQgICAgICB0ZXh0VG9IaWdobGlnaHQgPSBfcmVmMy50ZXh0VG9IaWdobGlnaHQ7XG5cdFx0XG5cdFx0ICB0ZXh0VG9IaWdobGlnaHQgPSBzYW5pdGl6ZSh0ZXh0VG9IaWdobGlnaHQpO1xuXHRcdFxuXHRcdCAgcmV0dXJuIHNlYXJjaFdvcmRzLmZpbHRlcihmdW5jdGlvbiAoc2VhcmNoV29yZCkge1xuXHRcdCAgICByZXR1cm4gc2VhcmNoV29yZDtcblx0XHQgIH0pIC8vIFJlbW92ZSBlbXB0eSB3b3Jkc1xuXHRcdCAgLnJlZHVjZShmdW5jdGlvbiAoY2h1bmtzLCBzZWFyY2hXb3JkKSB7XG5cdFx0ICAgIHNlYXJjaFdvcmQgPSBzYW5pdGl6ZShzZWFyY2hXb3JkKTtcblx0XHRcblx0XHQgICAgaWYgKGF1dG9Fc2NhcGUpIHtcblx0XHQgICAgICBzZWFyY2hXb3JkID0gZXNjYXBlUmVnRXhwRm4oc2VhcmNoV29yZCk7XG5cdFx0ICAgIH1cblx0XHRcblx0XHQgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChzZWFyY2hXb3JkLCBjYXNlU2Vuc2l0aXZlID8gJ2cnIDogJ2dpJyk7XG5cdFx0XG5cdFx0ICAgIHZhciBtYXRjaCA9IHZvaWQgMDtcblx0XHQgICAgd2hpbGUgKG1hdGNoID0gcmVnZXguZXhlYyh0ZXh0VG9IaWdobGlnaHQpKSB7XG5cdFx0ICAgICAgdmFyIHN0YXJ0ID0gbWF0Y2guaW5kZXg7XG5cdFx0ICAgICAgdmFyIGVuZCA9IHJlZ2V4Lmxhc3RJbmRleDtcblx0XHQgICAgICAvLyBXZSBkbyBub3QgcmV0dXJuIHplcm8tbGVuZ3RoIG1hdGNoZXNcblx0XHQgICAgICBpZiAoZW5kID4gc3RhcnQpIHtcblx0XHQgICAgICAgIGNodW5rcy5wdXNoKHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9KTtcblx0XHQgICAgICB9XG5cdFx0XG5cdFx0ICAgICAgLy8gUHJldmVudCBicm93c2VycyBsaWtlIEZpcmVmb3ggZnJvbSBnZXR0aW5nIHN0dWNrIGluIGFuIGluZmluaXRlIGxvb3Bcblx0XHQgICAgICAvLyBTZWUgaHR0cDovL3d3dy5yZWdleGd1cnUuY29tLzIwMDgvMDQvd2F0Y2gtb3V0LWZvci16ZXJvLWxlbmd0aC1tYXRjaGVzL1xuXHRcdCAgICAgIGlmIChtYXRjaC5pbmRleCA9PSByZWdleC5sYXN0SW5kZXgpIHtcblx0XHQgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCsrO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRcdFxuXHRcdCAgICByZXR1cm4gY2h1bmtzO1xuXHRcdCAgfSwgW10pO1xuXHRcdH07XG5cdFx0Ly8gQWxsb3cgdGhlIGZpbmRDaHVua3MgdG8gYmUgb3ZlcnJpZGRlbiBpbiBmaW5kQWxsLFxuXHRcdC8vIGJ1dCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2UgZXhwb3J0IGFzIHRoZSBvbGQgbmFtZVxuXHRcdGV4cG9ydHMuZmluZENodW5rcyA9IGRlZmF1bHRGaW5kQ2h1bmtzO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEdpdmVuIGEgc2V0IG9mIGNodW5rcyB0byBoaWdobGlnaHQsIGNyZWF0ZSBhbiBhZGRpdGlvbmFsIHNldCBvZiBjaHVua3Ncblx0XHQgKiB0byByZXByZXNlbnQgdGhlIGJpdHMgb2YgdGV4dCBiZXR3ZWVuIHRoZSBoaWdobGlnaHRlZCB0ZXh0LlxuXHRcdCAqIEBwYXJhbSBjaHVua3NUb0hpZ2hsaWdodCB7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfVtdXG5cdFx0ICogQHBhcmFtIHRvdGFsTGVuZ3RoIG51bWJlclxuXHRcdCAqIEByZXR1cm4ge3N0YXJ0Om51bWJlciwgZW5kOm51bWJlciwgaGlnaGxpZ2h0OmJvb2xlYW59W11cblx0XHQgKi9cblx0XHRcblx0XHR2YXIgZmlsbEluQ2h1bmtzID0gZXhwb3J0cy5maWxsSW5DaHVua3MgPSBmdW5jdGlvbiBmaWxsSW5DaHVua3MoX3JlZjQpIHtcblx0XHQgIHZhciBjaHVua3NUb0hpZ2hsaWdodCA9IF9yZWY0LmNodW5rc1RvSGlnaGxpZ2h0LFxuXHRcdCAgICAgIHRvdGFsTGVuZ3RoID0gX3JlZjQudG90YWxMZW5ndGg7XG5cdFx0XG5cdFx0ICB2YXIgYWxsQ2h1bmtzID0gW107XG5cdFx0ICB2YXIgYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKHN0YXJ0LCBlbmQsIGhpZ2hsaWdodCkge1xuXHRcdCAgICBpZiAoZW5kIC0gc3RhcnQgPiAwKSB7XG5cdFx0ICAgICAgYWxsQ2h1bmtzLnB1c2goe1xuXHRcdCAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuXHRcdCAgICAgICAgZW5kOiBlbmQsXG5cdFx0ICAgICAgICBoaWdobGlnaHQ6IGhpZ2hsaWdodFxuXHRcdCAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0ICB9O1xuXHRcdFxuXHRcdCAgaWYgKGNodW5rc1RvSGlnaGxpZ2h0Lmxlbmd0aCA9PT0gMCkge1xuXHRcdCAgICBhcHBlbmQoMCwgdG90YWxMZW5ndGgsIGZhbHNlKTtcblx0XHQgIH0gZWxzZSB7XG5cdFx0ICAgIHZhciBsYXN0SW5kZXggPSAwO1xuXHRcdCAgICBjaHVua3NUb0hpZ2hsaWdodC5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuXHRcdCAgICAgIGFwcGVuZChsYXN0SW5kZXgsIGNodW5rLnN0YXJ0LCBmYWxzZSk7XG5cdFx0ICAgICAgYXBwZW5kKGNodW5rLnN0YXJ0LCBjaHVuay5lbmQsIHRydWUpO1xuXHRcdCAgICAgIGxhc3RJbmRleCA9IGNodW5rLmVuZDtcblx0XHQgICAgfSk7XG5cdFx0ICAgIGFwcGVuZChsYXN0SW5kZXgsIHRvdGFsTGVuZ3RoLCBmYWxzZSk7XG5cdFx0ICB9XG5cdFx0ICByZXR1cm4gYWxsQ2h1bmtzO1xuXHRcdH07XG5cdFx0XG5cdFx0ZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcblx0XHQgIHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdFx0XG5cdFx0ZnVuY3Rpb24gZXNjYXBlUmVnRXhwRm4oc3RyKSB7XG5cdFx0ICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCAnXFxcXCQmJyk7XG5cdFx0fVxuXHRcblx0LyoqKi8gfSlcblx0LyoqKioqKi8gXSk7XG5cdC8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cblx0ICpcblx0ICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5cdCAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblx0ICovXG5cdFxuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHQgICAgU3ltYm9sLmZvciAmJlxuXHQgICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuXHQgICAgMHhlYWM3O1xuXHRcblx0ICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0ICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuXHQgICAgICBvYmplY3QgIT09IG51bGwgJiZcblx0ICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cdCAgfTtcblx0XG5cdCAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG5cdCAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuXHQgIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcblx0ICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNikoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xuXHR9IGVsc2Uge1xuXHQgIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG5cdCAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuXHQgIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykoKTtcblx0fVxuXHRcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oNSkpKVxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblx0dmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXHRcblx0Ly8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG5cdC8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuXHQvLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG5cdC8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cdFxuXHR2YXIgY2FjaGVkU2V0VGltZW91dDtcblx0dmFyIGNhY2hlZENsZWFyVGltZW91dDtcblx0XG5cdGZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcblx0fVxuXHRmdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG5cdH1cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuXHQgICAgICAgIH1cblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG5cdCAgICB9XG5cdH0gKCkpXG5cdGZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG5cdCAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuXHQgICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuXHQgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG5cdCAgICB9XG5cdCAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXHQgICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG5cdCAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG5cdCAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuXHQgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG5cdCAgICB9IGNhdGNoKGUpe1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuXHQgICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG5cdCAgICAgICAgfSBjYXRjaChlKXtcblx0ICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3Jcblx0ICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdFxuXHR9XG5cdGZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcblx0ICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuXHQgICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuXHQgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcblx0ICAgIH1cblx0ICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcblx0ICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuXHQgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcblx0ICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3Ncblx0ICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG5cdCAgICB9IGNhdGNoIChlKXtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpe1xuXHQgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cblx0ICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuXHQgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdFxuXHRcblx0XG5cdH1cblx0dmFyIHF1ZXVlID0gW107XG5cdHZhciBkcmFpbmluZyA9IGZhbHNlO1xuXHR2YXIgY3VycmVudFF1ZXVlO1xuXHR2YXIgcXVldWVJbmRleCA9IC0xO1xuXHRcblx0ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuXHQgICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgZHJhaW5pbmcgPSBmYWxzZTtcblx0ICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG5cdCAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuXHQgICAgfVxuXHQgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuXHQgICAgICAgIGRyYWluUXVldWUoKTtcblx0ICAgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcblx0ICAgIGlmIChkcmFpbmluZykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuXHQgICAgZHJhaW5pbmcgPSB0cnVlO1xuXHRcblx0ICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cdCAgICB3aGlsZShsZW4pIHtcblx0ICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcblx0ICAgICAgICBxdWV1ZSA9IFtdO1xuXHQgICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuXHQgICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcblx0ICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cdCAgICB9XG5cdCAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuXHQgICAgZHJhaW5pbmcgPSBmYWxzZTtcblx0ICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0fVxuXHRcblx0cHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcblx0ICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblx0ICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG5cdCAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuXHQgICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG5cdCAgICB9XG5cdH07XG5cdFxuXHQvLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5cdGZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuXHQgICAgdGhpcy5mdW4gPSBmdW47XG5cdCAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG5cdH1cblx0SXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG5cdH07XG5cdHByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5cdHByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5cdHByb2Nlc3MuZW52ID0ge307XG5cdHByb2Nlc3MuYXJndiA9IFtdO1xuXHRwcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcblx0cHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXHRcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cdFxuXHRwcm9jZXNzLm9uID0gbm9vcDtcblx0cHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5cdHByb2Nlc3Mub25jZSA9IG5vb3A7XG5cdHByb2Nlc3Mub2ZmID0gbm9vcDtcblx0cHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5cdHByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcblx0cHJvY2Vzcy5lbWl0ID0gbm9vcDtcblx0cHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xuXHRwcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXHRcblx0cHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXHRcblx0cHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblx0fTtcblx0XG5cdHByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5cdHByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xuXHR9O1xuXHRwcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKi9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBlbXB0eUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0dmFyIGludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdHZhciB3YXJuaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0dmFyIGFzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHRcblx0dmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdHZhciBjaGVja1Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuXHQgIC8qIGdsb2JhbCBTeW1ib2wgKi9cblx0ICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG5cdCAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cdFxuXHQgIC8qKlxuXHQgICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cblx0ICAgKlxuXHQgICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuXHQgICAqXG5cdCAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcblx0ICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcblx0ICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG5cdCAgICogICAgICAgLi4uXG5cdCAgICogICAgIH1cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuXHQgICAqIEByZXR1cm4gez9mdW5jdGlvbn1cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcblx0ICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG5cdCAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuXHQgICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG5cdCAgICpcblx0ICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG5cdCAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXHQgICAqICAgICBwcm9wVHlwZXM6IHtcblx0ICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG5cdCAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcblx0ICAgKlxuXHQgICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cblx0ICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG5cdCAgICpcblx0ICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cblx0ICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG5cdCAgICogICAgIH0sXG5cdCAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG5cdCAgICogICB9KTtcblx0ICAgKlxuXHQgICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcblx0ICAgKlxuXHQgICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuXHQgICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuXHQgICAqXG5cdCAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuXHQgICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcblx0ICAgKlxuXHQgICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXHQgICAqICAgIHByb3BUeXBlczoge1xuXHQgICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuXHQgICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG5cdCAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuXHQgICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG5cdCAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcblx0ICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG5cdCAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG5cdCAgICogICAgICAgICAgKTtcblx0ICAgKiAgICAgICAgfVxuXHQgICAqICAgICAgfVxuXHQgICAqICAgIH0sXG5cdCAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG5cdCAgICogIH0pO1xuXHQgICAqXG5cdCAgICogQGludGVybmFsXG5cdCAgICovXG5cdFxuXHQgIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cdFxuXHQgIC8vIEltcG9ydGFudCFcblx0ICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG5cdCAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuXHQgICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuXHQgICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcblx0ICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuXHQgICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG5cdCAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcblx0ICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuXHQgICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cdFxuXHQgICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuXHQgICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuXHQgICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG5cdCAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuXHQgICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcblx0ICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuXHQgICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcblx0ICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcblx0ICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuXHQgICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG5cdCAgfTtcblx0XG5cdCAgLyoqXG5cdCAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuXHQgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuXHQgICAqL1xuXHQgIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cblx0ICBmdW5jdGlvbiBpcyh4LCB5KSB7XG5cdCAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG5cdCAgICBpZiAoeCA9PT0geSkge1xuXHQgICAgICAvLyBTdGVwcyAxLTUsIDctMTBcblx0ICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcblx0ICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cblx0ICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cdFxuXHQgIC8qKlxuXHQgICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcblx0ICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuXHQgICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cblx0ICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG5cdCAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuXHQgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0ICAgIHRoaXMuc3RhY2sgPSAnJztcblx0ICB9XG5cdCAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuXHQgIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXHRcblx0ICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuXHQgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG5cdCAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcblx0ICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuXHQgICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cdFxuXHQgICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuXHQgICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG5cdCAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2Vcblx0ICAgICAgICAgIGludmFyaWFudChcblx0ICAgICAgICAgICAgZmFsc2UsXG5cdCAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcblx0ICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG5cdCAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuXHQgICAgICAgICAgKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcblx0ICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcblx0ICAgICAgICAgIGlmIChcblx0ICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuXHQgICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcblx0ICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG5cdCAgICAgICAgICApIHtcblx0ICAgICAgICAgICAgd2FybmluZyhcblx0ICAgICAgICAgICAgICBmYWxzZSxcblx0ICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG5cdCAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcblx0ICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuXHQgICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuXHQgICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuXHQgICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcblx0ICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG5cdCAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuXHQgICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG5cdCAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuXHQgICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cdFxuXHQgICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG5cdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG5cdCAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG5cdCAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG5cdCAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG5cdCAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuXHQgICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cdFxuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuXHQgICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXHQgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuXHQgICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuXHQgICAgICB9XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuXHQgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgICByZXR1cm4gZXJyb3I7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuXHQgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXHQgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcblx0ICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcblx0ICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcblx0ICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuXHQgICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG5cdCAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG5cdCAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG5cdCAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcblx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuXHQgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuXHQgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXHQgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuXHQgICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcblx0ICAgICAgfVxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdCAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuXHQgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcblx0ICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuXHQgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcblx0ICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuXHQgICAgfVxuXHRcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG5cdCAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHdhcm5pbmcoXG5cdCAgICAgICAgICBmYWxzZSxcblx0ICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG5cdCAgICAgICAgICAncmVjZWl2ZWQgJXMgYXQgaW5kZXggJXMuJyxcblx0ICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcblx0ICAgICAgICAgIGlcblx0ICAgICAgICApO1xuXHQgICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG5cdCAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuXHQgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuXHQgICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG5cdCAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcblx0ICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcblx0ICAgICAgICBpZiAoIWNoZWNrZXIpIHtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG5cdCAgICAgICAgaWYgKGVycm9yKSB7XG5cdCAgICAgICAgICByZXR1cm4gZXJyb3I7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG5cdCAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cblx0ICAgICAgLy8gcHJvcHMuXG5cdCAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuXHQgICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuXHQgICAgICAgIGlmICghY2hlY2tlcikge1xuXHQgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuXHQgICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG5cdCAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG5cdCAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuXHQgICAgICAgICAgKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuXHQgICAgICAgIGlmIChlcnJvcikge1xuXHQgICAgICAgICAgcmV0dXJuIGVycm9yO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuXHQgICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG5cdCAgICAgIGNhc2UgJ251bWJlcic6XG5cdCAgICAgIGNhc2UgJ3N0cmluZyc6XG5cdCAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuXHQgICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuXHQgICAgICBjYXNlICdvYmplY3QnOlxuXHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcblx0ICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuXHQgICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG5cdCAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcblx0ICAgICAgICAgIHZhciBzdGVwO1xuXHQgICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG5cdCAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcblx0ICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG5cdCAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcblx0ICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuXHQgICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG5cdCAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuXHQgICAgLy8gTmF0aXZlIFN5bWJvbC5cblx0ICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcblx0ICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuXHQgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdFxuXHQgIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cblx0ICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcblx0ICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG5cdCAgICAgIHJldHVybiAnYXJyYXknO1xuXHQgICAgfVxuXHQgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHQgICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG5cdCAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuXHQgICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cblx0ICAgICAgcmV0dXJuICdvYmplY3QnO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG5cdCAgICAgIHJldHVybiAnc3ltYm9sJztcblx0ICAgIH1cblx0ICAgIHJldHVybiBwcm9wVHlwZTtcblx0ICB9XG5cdFxuXHQgIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cblx0ICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cblx0ICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcblx0ICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuXHQgICAgfVxuXHQgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcblx0ICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0ICAgICAgICByZXR1cm4gJ2RhdGUnO1xuXHQgICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHQgICAgICAgIHJldHVybiAncmVnZXhwJztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHByb3BUeXBlO1xuXHQgIH1cblx0XG5cdCAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuXHQgIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG5cdCAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG5cdCAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcblx0ICAgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgICBjYXNlICdhcnJheSc6XG5cdCAgICAgIGNhc2UgJ29iamVjdCc6XG5cdCAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcblx0ICAgICAgY2FzZSAnYm9vbGVhbic6XG5cdCAgICAgIGNhc2UgJ2RhdGUnOlxuXHQgICAgICBjYXNlICdyZWdleHAnOlxuXHQgICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICByZXR1cm4gdHlwZTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG5cdCAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuXHQgICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG5cdCAgICAgIHJldHVybiBBTk9OWU1PVVM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG5cdCAgfVxuXHRcblx0ICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuXHQgIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXHRcblx0ICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG5cdH07XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg1KSkpXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblx0LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKlxuXHQgKiBcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIGFyZztcblx0ICB9O1xuXHR9XG5cdFxuXHQvKipcblx0ICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcblx0ICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcblx0ICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cblx0ICovXG5cdHZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXHRcblx0ZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuXHRlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgcmV0dXJuIGFyZztcblx0fTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqXG5cdCAqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0LyoqXG5cdCAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cblx0ICpcblx0ICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcblx0ICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG5cdCAqIGV4cGVjdGluZy5cblx0ICpcblx0ICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcblx0ICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuXHQgKi9cblx0XG5cdHZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cdFxuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG5cdCAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuXHQgICAgfVxuXHQgIH07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuXHQgIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cdFxuXHQgIGlmICghY29uZGl0aW9uKSB7XG5cdCAgICB2YXIgZXJyb3I7XG5cdCAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuXHQgICAgICB2YXIgYXJnSW5kZXggPSAwO1xuXHQgICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuXHQgICAgICB9KSk7XG5cdCAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG5cdCAgICB9XG5cdFxuXHQgICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuXHQgICAgdGhyb3cgZXJyb3I7XG5cdCAgfVxuXHR9XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oNSkpKVxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cblx0ICpcblx0ICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5cdCAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblx0ICpcblx0ICovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdFxuXHQvKipcblx0ICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuXHQgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG5cdCAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG5cdCAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuXHQgKi9cblx0XG5cdHZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblx0XG5cdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG5cdCAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcblx0ICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgIH1cblx0XG5cdCAgICB2YXIgYXJnSW5kZXggPSAwO1xuXHQgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuXHQgICAgfSk7XG5cdCAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG5cdCAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuXHQgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHQgICAgfSBjYXRjaCAoeCkge31cblx0ICB9O1xuXHRcblx0ICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuXHQgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuXHQgICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKCFjb25kaXRpb24pIHtcblx0ICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHQgICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG5cdCAgICB9XG5cdCAgfTtcblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg1KSkpXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKlxuXHRvYmplY3QtYXNzaWduXG5cdChjKSBTaW5kcmUgU29yaHVzXG5cdEBsaWNlbnNlIE1JVFxuXHQqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHR2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblx0dmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHRcblx0ZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdFx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiBPYmplY3QodmFsKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblx0XG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHRcdH1cblx0XHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHRcdHZhciBmcm9tO1xuXHRcdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdFx0dmFyIHN5bWJvbHM7XG5cdFxuXHRcdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cdFxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiB0bztcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKi9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cblx0ICpcblx0ICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5cdCAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblx0ICovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgIHZhciBpbnZhcmlhbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHQgIHZhciB3YXJuaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0ICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0ICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG5cdCAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuXHQgKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuXHQgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG5cdCAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG5cdCAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuXHQgICAgICAgIHZhciBlcnJvcjtcblx0ICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuXHQgICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cblx0ICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuXHQgICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuXHQgICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICd0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJXNgLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKTtcblx0ICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG5cdCAgICAgICAgfSBjYXRjaCAoZXgpIHtcblx0ICAgICAgICAgIGVycm9yID0gZXg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG5cdCAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcblx0ICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuXHQgICAgICAgICAgLy8gc2FtZSBlcnJvci5cblx0ICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cdFxuXHQgICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cdFxuXHQgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg1KSkpXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIGVtcHR5RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHR2YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0dmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXHQgIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcblx0ICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG5cdCAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgaW52YXJpYW50KFxuXHQgICAgICBmYWxzZSxcblx0ICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuXHQgICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG5cdCAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuXHQgICAgKTtcblx0ICB9O1xuXHQgIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG5cdCAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcblx0ICAgIHJldHVybiBzaGltO1xuXHQgIH07XG5cdCAgLy8gSW1wb3J0YW50IVxuXHQgIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuXHQgIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcblx0ICAgIGFycmF5OiBzaGltLFxuXHQgICAgYm9vbDogc2hpbSxcblx0ICAgIGZ1bmM6IHNoaW0sXG5cdCAgICBudW1iZXI6IHNoaW0sXG5cdCAgICBvYmplY3Q6IHNoaW0sXG5cdCAgICBzdHJpbmc6IHNoaW0sXG5cdCAgICBzeW1ib2w6IHNoaW0sXG5cdFxuXHQgICAgYW55OiBzaGltLFxuXHQgICAgYXJyYXlPZjogZ2V0U2hpbSxcblx0ICAgIGVsZW1lbnQ6IHNoaW0sXG5cdCAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuXHQgICAgbm9kZTogc2hpbSxcblx0ICAgIG9iamVjdE9mOiBnZXRTaGltLFxuXHQgICAgb25lT2Y6IGdldFNoaW0sXG5cdCAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG5cdCAgICBzaGFwZTogZ2V0U2hpbSxcblx0ICAgIGV4YWN0OiBnZXRTaGltXG5cdCAgfTtcblx0XG5cdCAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuXHQgIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXHRcblx0ICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIHNpbXBsZUlzRXF1YWwgPSBmdW5jdGlvbiBzaW1wbGVJc0VxdWFsKGEsIGIpIHtcblx0ICByZXR1cm4gYSA9PT0gYjtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGluZGV4IChyZXN1bHRGbikge1xuXHQgIHZhciBpc0VxdWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBzaW1wbGVJc0VxdWFsO1xuXHRcblx0ICB2YXIgbGFzdFRoaXMgPSB2b2lkIDA7XG5cdCAgdmFyIGxhc3RBcmdzID0gW107XG5cdCAgdmFyIGxhc3RSZXN1bHQgPSB2b2lkIDA7XG5cdCAgdmFyIGNhbGxlZE9uY2UgPSBmYWxzZTtcblx0XG5cdCAgdmFyIGlzTmV3QXJnRXF1YWxUb0xhc3QgPSBmdW5jdGlvbiBpc05ld0FyZ0VxdWFsVG9MYXN0KG5ld0FyZywgaW5kZXgpIHtcblx0ICAgIHJldHVybiBpc0VxdWFsKG5ld0FyZywgbGFzdEFyZ3NbaW5kZXhdKTtcblx0ICB9O1xuXHRcblx0ICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24gcmVzdWx0KCkge1xuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5ld0FyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgbmV3QXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoY2FsbGVkT25jZSAmJiBsYXN0VGhpcyA9PT0gdGhpcyAmJiBuZXdBcmdzLmxlbmd0aCA9PT0gbGFzdEFyZ3MubGVuZ3RoICYmIG5ld0FyZ3MuZXZlcnkoaXNOZXdBcmdFcXVhbFRvTGFzdCkpIHtcblx0ICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgY2FsbGVkT25jZSA9IHRydWU7XG5cdCAgICBsYXN0VGhpcyA9IHRoaXM7XG5cdCAgICBsYXN0QXJncyA9IG5ld0FyZ3M7XG5cdCAgICBsYXN0UmVzdWx0ID0gcmVzdWx0Rm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG5cdCAgICByZXR1cm4gbGFzdFJlc3VsdDtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGluZGV4O1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4uanMubWFwIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImlkIiwibG9hZGVkIiwiY2FsbCIsIm0iLCJjIiwicCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0Iiwib2JqIiwiX19lc01vZHVsZSIsIl9IaWdobGlnaHRlciIsIl9IaWdobGlnaHRlcjIiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIkhpZ2hsaWdodGVyIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwia2V5cyIsImluZGV4T2YiLCJfaGlnaGxpZ2h0V29yZHNDb3JlIiwiX3Byb3BUeXBlcyIsIl9wcm9wVHlwZXMyIiwiX3JlYWN0IiwiX21lbW9pemVPbmUiLCJfbWVtb2l6ZU9uZTIiLCJwcm9wVHlwZXMiLCJhY3RpdmVDbGFzc05hbWUiLCJzdHJpbmciLCJhY3RpdmVJbmRleCIsIm51bWJlciIsImFjdGl2ZVN0eWxlIiwib2JqZWN0IiwiYXV0b0VzY2FwZSIsImJvb2wiLCJjbGFzc05hbWUiLCJmaW5kQ2h1bmtzIiwiZnVuYyIsImhpZ2hsaWdodENsYXNzTmFtZSIsIm9uZU9mVHlwZSIsImhpZ2hsaWdodFN0eWxlIiwiaGlnaGxpZ2h0VGFnIiwibm9kZSIsInNhbml0aXplIiwic2VhcmNoV29yZHMiLCJhcnJheU9mIiwiaW5zdGFuY2VPZiIsIlJlZ0V4cCIsImlzUmVxdWlyZWQiLCJ0ZXh0VG9IaWdobGlnaHQiLCJ1bmhpZ2hsaWdodFRhZyIsInVuaGlnaGxpZ2h0Q2xhc3NOYW1lIiwidW5oaWdobGlnaHRTdHlsZSIsIl9yZWYiLCJfcmVmJGFjdGl2ZUNsYXNzTmFtZSIsInVuZGVmaW5lZCIsIl9yZWYkYWN0aXZlSW5kZXgiLCJfcmVmJGNhc2VTZW5zaXRpdmUiLCJjYXNlU2Vuc2l0aXZlIiwiX3JlZiRoaWdobGlnaHRDbGFzc05hbWUiLCJfcmVmJGhpZ2hsaWdodFN0eWxlIiwiX3JlZiRoaWdobGlnaHRUYWciLCJfcmVmJHVuaGlnaGxpZ2h0VGFnIiwiX3JlZiR1bmhpZ2hsaWdodENsYXNzTmFtZSIsInJlc3QiLCJjaHVua3MiLCJmaW5kQWxsIiwiSGlnaGxpZ2h0VGFnIiwiaGlnaGxpZ2h0SW5kZXgiLCJoaWdobGlnaHRDbGFzc05hbWVzIiwiaGlnaGxpZ2h0U3R5bGVzIiwibG93ZXJjYXNlUHJvcHMiLCJtYXBwZWQiLCJ0b0xvd2VyQ2FzZSIsIm1lbW9pemVkTG93ZXJjYXNlUHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiY2hpbGRyZW4iLCJtYXAiLCJjaHVuayIsImluZGV4IiwidGV4dCIsInN1YnN0ciIsInN0YXJ0IiwiZW5kIiwiaGlnaGxpZ2h0IiwiaGlnaGxpZ2h0Q2xhc3MiLCJpc0FjdGl2ZSIsInByb3BzIiwic3R5bGUiLCJfdXRpbHMiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiY29tYmluZUNodW5rcyIsImZpbGxJbkNodW5rcyIsIl9yZWYkZmluZENodW5rcyIsImRlZmF1bHRGaW5kQ2h1bmtzIiwiY2h1bmtzVG9IaWdobGlnaHQiLCJ0b3RhbExlbmd0aCIsIl9yZWYyIiwic29ydCIsImZpcnN0Iiwic2Vjb25kIiwicmVkdWNlIiwicHJvY2Vzc2VkQ2h1bmtzIiwibmV4dENodW5rIiwicHJldkNodW5rIiwicG9wIiwiZW5kSW5kZXgiLCJNYXRoIiwibWF4IiwicHVzaCIsIl9yZWYzIiwiX3JlZjMkc2FuaXRpemUiLCJpZGVudGl0eSIsImZpbHRlciIsInNlYXJjaFdvcmQiLCJlc2NhcGVSZWdFeHBGbiIsInJlZ2V4IiwibWF0Y2giLCJleGVjIiwibGFzdEluZGV4IiwiX3JlZjQiLCJhbGxDaHVua3MiLCJhcHBlbmQiLCJmb3JFYWNoIiwic3RyIiwicmVwbGFjZSIsInByb2Nlc3MiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJpc1ZhbGlkRWxlbWVudCIsIiQkdHlwZW9mIiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiSXRlbSIsImFycmF5IiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsIm5hbWUiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsImVtcHR5RnVuY3Rpb24iLCJpbnZhcmlhbnQiLCJ3YXJuaW5nIiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJjaGVja1Byb3BUeXBlcyIsIklURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIml0ZXJhdG9yRm4iLCJBTk9OWU1PVVMiLCJSZWFjdFByb3BUeXBlcyIsImNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyIiwic3ltYm9sIiwiYW55IiwiY3JlYXRlQW55VHlwZUNoZWNrZXIiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJlbGVtZW50IiwiY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwic2hhcGUiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiZXhhY3QiLCJjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyIiwiaXMiLCJ4IiwieSIsIlByb3BUeXBlRXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciIsInZhbGlkYXRlIiwibWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUiLCJtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCIsImNoZWNrVHlwZSIsInByb3BOYW1lIiwiY29tcG9uZW50TmFtZSIsImxvY2F0aW9uIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiY29uc29sZSIsImNhY2hlS2V5IiwiY2hhaW5lZENoZWNrVHlwZSIsImJpbmQiLCJleHBlY3RlZFR5cGUiLCJwcm9wVmFsdWUiLCJwcm9wVHlwZSIsImdldFByb3BUeXBlIiwicHJlY2lzZVR5cGUiLCJnZXRQcmVjaXNlVHlwZSIsInRoYXRSZXR1cm5zTnVsbCIsInR5cGVDaGVja2VyIiwiaXNBcnJheSIsImVycm9yIiwiZXhwZWN0ZWRDbGFzcyIsImV4cGVjdGVkQ2xhc3NOYW1lIiwiYWN0dWFsQ2xhc3NOYW1lIiwiZ2V0Q2xhc3NOYW1lIiwiZXhwZWN0ZWRWYWx1ZXMiLCJ2YWx1ZXNTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiYXJyYXlPZlR5cGVDaGVja2VycyIsImNoZWNrZXIiLCJnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmciLCJpc05vZGUiLCJzaGFwZVR5cGVzIiwiYWxsS2V5cyIsImV2ZXJ5Iiwic3RlcCIsImVudHJpZXMiLCJuZXh0IiwiZG9uZSIsImVudHJ5IiwiaXNTeW1ib2wiLCJEYXRlIiwidHlwZSIsImNvbnN0cnVjdG9yIiwiUHJvcFR5cGVzIiwibWFrZUVtcHR5RnVuY3Rpb24iLCJhcmciLCJ0aGF0UmV0dXJucyIsInRoYXRSZXR1cm5zRmFsc2UiLCJ0aGF0UmV0dXJuc1RydWUiLCJ0aGF0UmV0dXJuc1RoaXMiLCJ0aGF0UmV0dXJuc0FyZ3VtZW50IiwidmFsaWRhdGVGb3JtYXQiLCJmb3JtYXQiLCJjb25kaXRpb24iLCJhIiwiYiIsImQiLCJmIiwiYXJnSW5kZXgiLCJmcmFtZXNUb1BvcCIsInByaW50V2FybmluZyIsIl9sZW4iLCJfa2V5IiwiX2xlbjIiLCJfa2V5MiIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwidmFsIiwiVHlwZUVycm9yIiwic2hvdWxkVXNlTmF0aXZlIiwidGVzdDEiLCJTdHJpbmciLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJuIiwiam9pbiIsInRlc3QzIiwic3BsaXQiLCJsZXR0ZXIiLCJlcnIiLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwicyIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsInR5cGVTcGVjcyIsInZhbHVlcyIsImdldFN0YWNrIiwidHlwZVNwZWNOYW1lIiwiZXgiLCJzaGltIiwiZ2V0U2hpbSIsInJlcXVpcmUiLCJzaW1wbGVJc0VxdWFsIiwicmVzdWx0Rm4iLCJpc0VxdWFsIiwibGFzdFRoaXMiLCJsYXN0QXJncyIsImxhc3RSZXN1bHQiLCJjYWxsZWRPbmNlIiwiaXNOZXdBcmdFcXVhbFRvTGFzdCIsIm5ld0FyZyIsInJlc3VsdCIsIm5ld0FyZ3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-highlight-words/dist/main.js\n");

/***/ })

};
;