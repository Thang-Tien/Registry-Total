"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-highlight-words";
exports.ids = ["vendor-chunks/react-highlight-words"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-highlight-words/dist/main.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-highlight-words/dist/main.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = /******/ function(modules) {\n    /******/ // The module cache\n    /******/ var installedModules = {};\n    /******/ /******/ // The require function\n    /******/ function __nested_webpack_require_192__(moduleId) {\n        /******/ /******/ // Check if module is in cache\n        /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;\n        /******/ /******/ // Create a new module (and put it into the cache)\n        /******/ var module1 = installedModules[moduleId] = {\n            /******/ exports: {},\n            /******/ id: moduleId,\n            /******/ loaded: false\n        };\n        /******/ /******/ // Execute the module function\n        /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_192__);\n        /******/ /******/ // Flag the module as loaded\n        /******/ module1.loaded = true;\n        /******/ /******/ // Return the exports of the module\n        /******/ return module1.exports;\n    /******/ }\n    /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n    /******/ __nested_webpack_require_192__.m = modules;\n    /******/ /******/ // expose the module cache\n    /******/ __nested_webpack_require_192__.c = installedModules;\n    /******/ /******/ // __webpack_public_path__\n    /******/ __nested_webpack_require_192__.p = \"\";\n    /******/ /******/ // Load entry module and return exports\n    /******/ return __nested_webpack_require_192__(0);\n/******/ }([\n    /* 0 */ /***/ function(module1, exports, __nested_webpack_require_1506__) {\n        module1.exports = __nested_webpack_require_1506__(1);\n    /***/ },\n    /* 1 */ /***/ function(module1, exports, __nested_webpack_require_1637__) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        function _interopRequireDefault(obj) {\n            return obj && obj.__esModule ? obj : {\n                \"default\": obj\n            };\n        }\n        var _Highlighter = __nested_webpack_require_1637__(2);\n        var _Highlighter2 = _interopRequireDefault(_Highlighter);\n        exports[\"default\"] = _Highlighter2[\"default\"];\n        module1.exports = exports[\"default\"];\n    /***/ },\n    /* 2 */ /***/ function(module1, exports, __nested_webpack_require_2203__) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        var _extends = Object.assign || function(target) {\n            for(var i = 1; i < arguments.length; i++){\n                var source = arguments[i];\n                for(var key in source){\n                    if (Object.prototype.hasOwnProperty.call(source, key)) {\n                        target[key] = source[key];\n                    }\n                }\n            }\n            return target;\n        };\n        exports[\"default\"] = Highlighter;\n        function _interopRequireDefault(obj) {\n            return obj && obj.__esModule ? obj : {\n                \"default\": obj\n            };\n        }\n        function _objectWithoutProperties(obj, keys) {\n            var target = {};\n            for(var i in obj){\n                if (keys.indexOf(i) >= 0) continue;\n                if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n                target[i] = obj[i];\n            }\n            return target;\n        }\n        var _highlightWordsCore = __nested_webpack_require_2203__(3);\n        var _propTypes = __nested_webpack_require_2203__(4);\n        var _propTypes2 = _interopRequireDefault(_propTypes);\n        var _react = __nested_webpack_require_2203__(14);\n        var _memoizeOne = __nested_webpack_require_2203__(15);\n        var _memoizeOne2 = _interopRequireDefault(_memoizeOne);\n        Highlighter.propTypes = {\n            activeClassName: _propTypes2[\"default\"].string,\n            activeIndex: _propTypes2[\"default\"].number,\n            activeStyle: _propTypes2[\"default\"].object,\n            autoEscape: _propTypes2[\"default\"].bool,\n            className: _propTypes2[\"default\"].string,\n            findChunks: _propTypes2[\"default\"].func,\n            highlightClassName: _propTypes2[\"default\"].oneOfType([\n                _propTypes2[\"default\"].object,\n                _propTypes2[\"default\"].string\n            ]),\n            highlightStyle: _propTypes2[\"default\"].object,\n            highlightTag: _propTypes2[\"default\"].oneOfType([\n                _propTypes2[\"default\"].node,\n                _propTypes2[\"default\"].func,\n                _propTypes2[\"default\"].string\n            ]),\n            sanitize: _propTypes2[\"default\"].func,\n            searchWords: _propTypes2[\"default\"].arrayOf(_propTypes2[\"default\"].oneOfType([\n                _propTypes2[\"default\"].string,\n                _propTypes2[\"default\"].instanceOf(RegExp)\n            ])).isRequired,\n            textToHighlight: _propTypes2[\"default\"].string.isRequired,\n            unhighlightTag: _propTypes2[\"default\"].oneOfType([\n                _propTypes2[\"default\"].node,\n                _propTypes2[\"default\"].func,\n                _propTypes2[\"default\"].string\n            ]),\n            unhighlightClassName: _propTypes2[\"default\"].string,\n            unhighlightStyle: _propTypes2[\"default\"].object\n        };\n        /**\r\n\t * Highlights all occurrences of search terms (searchText) within a string (textToHighlight).\r\n\t * This function returns an array of strings and <span>s (wrapping highlighted words).\r\n\t */ function Highlighter(_ref) {\n            var _ref$activeClassName = _ref.activeClassName;\n            var activeClassName = _ref$activeClassName === undefined ? \"\" : _ref$activeClassName;\n            var _ref$activeIndex = _ref.activeIndex;\n            var activeIndex = _ref$activeIndex === undefined ? -1 : _ref$activeIndex;\n            var activeStyle = _ref.activeStyle;\n            var autoEscape = _ref.autoEscape;\n            var _ref$caseSensitive = _ref.caseSensitive;\n            var caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive;\n            var className = _ref.className;\n            var findChunks = _ref.findChunks;\n            var _ref$highlightClassName = _ref.highlightClassName;\n            var highlightClassName = _ref$highlightClassName === undefined ? \"\" : _ref$highlightClassName;\n            var _ref$highlightStyle = _ref.highlightStyle;\n            var highlightStyle = _ref$highlightStyle === undefined ? {} : _ref$highlightStyle;\n            var _ref$highlightTag = _ref.highlightTag;\n            var highlightTag = _ref$highlightTag === undefined ? \"mark\" : _ref$highlightTag;\n            var sanitize = _ref.sanitize;\n            var searchWords = _ref.searchWords;\n            var textToHighlight = _ref.textToHighlight;\n            var _ref$unhighlightTag = _ref.unhighlightTag;\n            var unhighlightTag = _ref$unhighlightTag === undefined ? \"span\" : _ref$unhighlightTag;\n            var _ref$unhighlightClassName = _ref.unhighlightClassName;\n            var unhighlightClassName = _ref$unhighlightClassName === undefined ? \"\" : _ref$unhighlightClassName;\n            var unhighlightStyle = _ref.unhighlightStyle;\n            var rest = _objectWithoutProperties(_ref, [\n                \"activeClassName\",\n                \"activeIndex\",\n                \"activeStyle\",\n                \"autoEscape\",\n                \"caseSensitive\",\n                \"className\",\n                \"findChunks\",\n                \"highlightClassName\",\n                \"highlightStyle\",\n                \"highlightTag\",\n                \"sanitize\",\n                \"searchWords\",\n                \"textToHighlight\",\n                \"unhighlightTag\",\n                \"unhighlightClassName\",\n                \"unhighlightStyle\"\n            ]);\n            var chunks = (0, _highlightWordsCore.findAll)({\n                autoEscape: autoEscape,\n                caseSensitive: caseSensitive,\n                findChunks: findChunks,\n                sanitize: sanitize,\n                searchWords: searchWords,\n                textToHighlight: textToHighlight\n            });\n            var HighlightTag = highlightTag;\n            var highlightIndex = -1;\n            var highlightClassNames = \"\";\n            var highlightStyles = undefined;\n            var lowercaseProps = function lowercaseProps(object) {\n                var mapped = {};\n                for(var key in object){\n                    mapped[key.toLowerCase()] = object[key];\n                }\n                return mapped;\n            };\n            var memoizedLowercaseProps = (0, _memoizeOne2[\"default\"])(lowercaseProps);\n            return (0, _react.createElement)(\"span\", _extends({\n                className: className\n            }, rest, {\n                children: chunks.map(function(chunk, index) {\n                    var text = textToHighlight.substr(chunk.start, chunk.end - chunk.start);\n                    if (chunk.highlight) {\n                        highlightIndex++;\n                        var highlightClass = undefined;\n                        if (typeof highlightClassName === \"object\") {\n                            if (!caseSensitive) {\n                                highlightClassName = memoizedLowercaseProps(highlightClassName);\n                                highlightClass = highlightClassName[text.toLowerCase()];\n                            } else {\n                                highlightClass = highlightClassName[text];\n                            }\n                        } else {\n                            highlightClass = highlightClassName;\n                        }\n                        var isActive = highlightIndex === +activeIndex;\n                        highlightClassNames = highlightClass + \" \" + (isActive ? activeClassName : \"\");\n                        highlightStyles = isActive === true && activeStyle != null ? Object.assign({}, highlightStyle, activeStyle) : highlightStyle;\n                        var props = {\n                            children: text,\n                            className: highlightClassNames,\n                            key: index,\n                            style: highlightStyles\n                        };\n                        // Don't attach arbitrary props to DOM elements; this triggers React DEV warnings (https://fb.me/react-unknown-prop)\n                        // Only pass through the highlightIndex attribute for custom components.\n                        if (typeof HighlightTag !== \"string\") {\n                            props.highlightIndex = highlightIndex;\n                        }\n                        return (0, _react.createElement)(HighlightTag, props);\n                    } else {\n                        return (0, _react.createElement)(unhighlightTag, {\n                            children: text,\n                            className: unhighlightClassName,\n                            key: index,\n                            style: unhighlightStyle\n                        });\n                    }\n                })\n            }));\n        }\n        module1.exports = exports[\"default\"];\n    /***/ },\n    /* 3 */ /***/ function(module1, exports) {\n        module1.exports = /******/ function(modules) {\n            /******/ // The module cache\n            /******/ var installedModules = {};\n            /******/ /******/ // The require function\n            /******/ function __nested_webpack_require_11234__(moduleId) {\n                /******/ /******/ // Check if module is in cache\n                /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;\n                /******/ /******/ // Create a new module (and put it into the cache)\n                /******/ var module1 = installedModules[moduleId] = {\n                    /******/ exports: {},\n                    /******/ id: moduleId,\n                    /******/ loaded: false\n                };\n                /******/ /******/ // Execute the module function\n                /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_11234__);\n                /******/ /******/ // Flag the module as loaded\n                /******/ module1.loaded = true;\n                /******/ /******/ // Return the exports of the module\n                /******/ return module1.exports;\n            /******/ }\n            /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n            /******/ __nested_webpack_require_11234__.m = modules;\n            /******/ /******/ // expose the module cache\n            /******/ __nested_webpack_require_11234__.c = installedModules;\n            /******/ /******/ // __webpack_public_path__\n            /******/ __nested_webpack_require_11234__.p = \"\";\n            /******/ /******/ // Load entry module and return exports\n            /******/ return __nested_webpack_require_11234__(0);\n        /******/ }([\n            /* 0 */ /***/ function(module1, exports, __nested_webpack_require_12748__) {\n                module1.exports = __nested_webpack_require_12748__(1);\n            /***/ },\n            /* 1 */ /***/ function(module1, exports, __nested_webpack_require_12903__) {\n                \"use strict\";\n                Object.defineProperty(exports, \"__esModule\", {\n                    value: true\n                });\n                var _utils = __nested_webpack_require_12903__(2);\n                Object.defineProperty(exports, \"combineChunks\", {\n                    enumerable: true,\n                    get: function get() {\n                        return _utils.combineChunks;\n                    }\n                });\n                Object.defineProperty(exports, \"fillInChunks\", {\n                    enumerable: true,\n                    get: function get() {\n                        return _utils.fillInChunks;\n                    }\n                });\n                Object.defineProperty(exports, \"findAll\", {\n                    enumerable: true,\n                    get: function get() {\n                        return _utils.findAll;\n                    }\n                });\n                Object.defineProperty(exports, \"findChunks\", {\n                    enumerable: true,\n                    get: function get() {\n                        return _utils.findChunks;\n                    }\n                });\n            /***/ },\n            /* 2 */ /***/ function(module1, exports) {\n                \"use strict\";\n                Object.defineProperty(exports, \"__esModule\", {\n                    value: true\n                });\n                /**\n\t\t * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.\n\t\t * @return Array of \"chunks\" (where a Chunk is { start:number, end:number, highlight:boolean })\n\t\t */ var findAll = exports.findAll = function findAll(_ref) {\n                    var autoEscape = _ref.autoEscape, _ref$caseSensitive = _ref.caseSensitive, caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive, _ref$findChunks = _ref.findChunks, findChunks = _ref$findChunks === undefined ? defaultFindChunks : _ref$findChunks, sanitize = _ref.sanitize, searchWords = _ref.searchWords, textToHighlight = _ref.textToHighlight;\n                    return fillInChunks({\n                        chunksToHighlight: combineChunks({\n                            chunks: findChunks({\n                                autoEscape: autoEscape,\n                                caseSensitive: caseSensitive,\n                                sanitize: sanitize,\n                                searchWords: searchWords,\n                                textToHighlight: textToHighlight\n                            })\n                        }),\n                        totalLength: textToHighlight ? textToHighlight.length : 0\n                    });\n                };\n                /**\n\t\t * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.\n\t\t * @return {start:number, end:number}[]\n\t\t */ var combineChunks = exports.combineChunks = function combineChunks(_ref2) {\n                    var chunks = _ref2.chunks;\n                    chunks = chunks.sort(function(first, second) {\n                        return first.start - second.start;\n                    }).reduce(function(processedChunks, nextChunk) {\n                        // First chunk just goes straight in the array...\n                        if (processedChunks.length === 0) {\n                            return [\n                                nextChunk\n                            ];\n                        } else {\n                            // ... subsequent chunks get checked to see if they overlap...\n                            var prevChunk = processedChunks.pop();\n                            if (nextChunk.start <= prevChunk.end) {\n                                // It may be the case that prevChunk completely surrounds nextChunk, so take the\n                                // largest of the end indeces.\n                                var endIndex = Math.max(prevChunk.end, nextChunk.end);\n                                processedChunks.push({\n                                    start: prevChunk.start,\n                                    end: endIndex\n                                });\n                            } else {\n                                processedChunks.push(prevChunk, nextChunk);\n                            }\n                            return processedChunks;\n                        }\n                    }, []);\n                    return chunks;\n                };\n                /**\n\t\t * Examine text for any matches.\n\t\t * If we find matches, add them to the returned array as a \"chunk\" object ({start:number, end:number}).\n\t\t * @return {start:number, end:number}[]\n\t\t */ var defaultFindChunks = function defaultFindChunks(_ref3) {\n                    var autoEscape = _ref3.autoEscape, caseSensitive = _ref3.caseSensitive, _ref3$sanitize = _ref3.sanitize, sanitize = _ref3$sanitize === undefined ? identity : _ref3$sanitize, searchWords = _ref3.searchWords, textToHighlight = _ref3.textToHighlight;\n                    textToHighlight = sanitize(textToHighlight);\n                    return searchWords.filter(function(searchWord) {\n                        return searchWord;\n                    }) // Remove empty words\n                    .reduce(function(chunks, searchWord) {\n                        searchWord = sanitize(searchWord);\n                        if (autoEscape) {\n                            searchWord = escapeRegExpFn(searchWord);\n                        }\n                        var regex = new RegExp(searchWord, caseSensitive ? \"g\" : \"gi\");\n                        var match = void 0;\n                        while(match = regex.exec(textToHighlight)){\n                            var start = match.index;\n                            var end = regex.lastIndex;\n                            // We do not return zero-length matches\n                            if (end > start) {\n                                chunks.push({\n                                    start: start,\n                                    end: end\n                                });\n                            }\n                            // Prevent browsers like Firefox from getting stuck in an infinite loop\n                            // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/\n                            if (match.index == regex.lastIndex) {\n                                regex.lastIndex++;\n                            }\n                        }\n                        return chunks;\n                    }, []);\n                };\n                // Allow the findChunks to be overridden in findAll,\n                // but for backwards compatibility we export as the old name\n                exports.findChunks = defaultFindChunks;\n                /**\n\t\t * Given a set of chunks to highlight, create an additional set of chunks\n\t\t * to represent the bits of text between the highlighted text.\n\t\t * @param chunksToHighlight {start:number, end:number}[]\n\t\t * @param totalLength number\n\t\t * @return {start:number, end:number, highlight:boolean}[]\n\t\t */ var fillInChunks = exports.fillInChunks = function fillInChunks(_ref4) {\n                    var chunksToHighlight = _ref4.chunksToHighlight, totalLength = _ref4.totalLength;\n                    var allChunks = [];\n                    var append = function append(start, end, highlight) {\n                        if (end - start > 0) {\n                            allChunks.push({\n                                start: start,\n                                end: end,\n                                highlight: highlight\n                            });\n                        }\n                    };\n                    if (chunksToHighlight.length === 0) {\n                        append(0, totalLength, false);\n                    } else {\n                        var lastIndex = 0;\n                        chunksToHighlight.forEach(function(chunk) {\n                            append(lastIndex, chunk.start, false);\n                            append(chunk.start, chunk.end, true);\n                            lastIndex = chunk.end;\n                        });\n                        append(lastIndex, totalLength, false);\n                    }\n                    return allChunks;\n                };\n                function identity(value) {\n                    return value;\n                }\n                function escapeRegExpFn(str) {\n                    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n                }\n            /***/ }\n        ]);\n    //# sourceMappingURL=index.js.map\n    /***/ },\n    /* 4 */ /***/ function(module1, exports, __nested_webpack_require_21600__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            if (true) {\n                var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n                var isValidElement = function(object) {\n                    return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                };\n                // By explicitly using `prop-types` you are opting into new development behavior.\n                // http://fb.me/prop-types-in-prod\n                var throwOnDirectAccess = true;\n                module1.exports = __nested_webpack_require_21600__(6)(isValidElement, throwOnDirectAccess);\n            } else {}\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_21600__(5));\n    /***/ },\n    /* 5 */ /***/ function(module1, exports) {\n        // shim for using process in browser\n        var process = module1.exports = {};\n        // cached from whatever global is present so that test runners that stub it\n        // don't break things.  But we need to wrap it in a try catch in case it is\n        // wrapped in strict mode code which doesn't define any globals.  It's inside a\n        // function because try/catches deoptimize in certain engines.\n        var cachedSetTimeout;\n        var cachedClearTimeout;\n        function defaultSetTimout() {\n            throw new Error(\"setTimeout has not been defined\");\n        }\n        function defaultClearTimeout() {\n            throw new Error(\"clearTimeout has not been defined\");\n        }\n        (function() {\n            try {\n                if (typeof setTimeout === \"function\") {\n                    cachedSetTimeout = setTimeout;\n                } else {\n                    cachedSetTimeout = defaultSetTimout;\n                }\n            } catch (e) {\n                cachedSetTimeout = defaultSetTimout;\n            }\n            try {\n                if (typeof clearTimeout === \"function\") {\n                    cachedClearTimeout = clearTimeout;\n                } else {\n                    cachedClearTimeout = defaultClearTimeout;\n                }\n            } catch (e) {\n                cachedClearTimeout = defaultClearTimeout;\n            }\n        })();\n        function runTimeout(fun) {\n            if (cachedSetTimeout === setTimeout) {\n                //normal enviroments in sane situations\n                return setTimeout(fun, 0);\n            }\n            // if setTimeout wasn't available but was latter defined\n            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n                cachedSetTimeout = setTimeout;\n                return setTimeout(fun, 0);\n            }\n            try {\n                // when when somebody has screwed with setTimeout but no I.E. maddness\n                return cachedSetTimeout(fun, 0);\n            } catch (e) {\n                try {\n                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n                    return cachedSetTimeout.call(null, fun, 0);\n                } catch (e) {\n                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n                    return cachedSetTimeout.call(this, fun, 0);\n                }\n            }\n        }\n        function runClearTimeout(marker) {\n            if (cachedClearTimeout === clearTimeout) {\n                //normal enviroments in sane situations\n                return clearTimeout(marker);\n            }\n            // if clearTimeout wasn't available but was latter defined\n            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n                cachedClearTimeout = clearTimeout;\n                return clearTimeout(marker);\n            }\n            try {\n                // when when somebody has screwed with setTimeout but no I.E. maddness\n                return cachedClearTimeout(marker);\n            } catch (e) {\n                try {\n                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n                    return cachedClearTimeout.call(null, marker);\n                } catch (e) {\n                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n                    return cachedClearTimeout.call(this, marker);\n                }\n            }\n        }\n        var queue = [];\n        var draining = false;\n        var currentQueue;\n        var queueIndex = -1;\n        function cleanUpNextTick() {\n            if (!draining || !currentQueue) {\n                return;\n            }\n            draining = false;\n            if (currentQueue.length) {\n                queue = currentQueue.concat(queue);\n            } else {\n                queueIndex = -1;\n            }\n            if (queue.length) {\n                drainQueue();\n            }\n        }\n        function drainQueue() {\n            if (draining) {\n                return;\n            }\n            var timeout = runTimeout(cleanUpNextTick);\n            draining = true;\n            var len = queue.length;\n            while(len){\n                currentQueue = queue;\n                queue = [];\n                while(++queueIndex < len){\n                    if (currentQueue) {\n                        currentQueue[queueIndex].run();\n                    }\n                }\n                queueIndex = -1;\n                len = queue.length;\n            }\n            currentQueue = null;\n            draining = false;\n            runClearTimeout(timeout);\n        }\n        process.nextTick = function(fun) {\n            var args = new Array(arguments.length - 1);\n            if (arguments.length > 1) {\n                for(var i = 1; i < arguments.length; i++){\n                    args[i - 1] = arguments[i];\n                }\n            }\n            queue.push(new Item(fun, args));\n            if (queue.length === 1 && !draining) {\n                runTimeout(drainQueue);\n            }\n        };\n        // v8 likes predictible objects\n        function Item(fun, array) {\n            this.fun = fun;\n            this.array = array;\n        }\n        Item.prototype.run = function() {\n            this.fun.apply(null, this.array);\n        };\n        process.title = \"browser\";\n        process.browser = true;\n        process.env = {};\n        process.argv = [];\n        process.version = \"\"; // empty string to avoid regexp issues\n        process.versions = {};\n        function noop() {}\n        process.on = noop;\n        process.addListener = noop;\n        process.once = noop;\n        process.off = noop;\n        process.removeListener = noop;\n        process.removeAllListeners = noop;\n        process.emit = noop;\n        process.prependListener = noop;\n        process.prependOnceListener = noop;\n        process.listeners = function(name) {\n            return [];\n        };\n        process.binding = function(name) {\n            throw new Error(\"process.binding is not supported\");\n        };\n        process.cwd = function() {\n            return \"/\";\n        };\n        process.chdir = function(dir) {\n            throw new Error(\"process.chdir is not supported\");\n        };\n        process.umask = function() {\n            return 0;\n        };\n    /***/ },\n    /* 6 */ /***/ function(module1, exports, __nested_webpack_require_29564__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            \"use strict\";\n            var emptyFunction = __nested_webpack_require_29564__(7);\n            var invariant = __nested_webpack_require_29564__(8);\n            var warning = __nested_webpack_require_29564__(9);\n            var assign = __nested_webpack_require_29564__(10);\n            var ReactPropTypesSecret = __nested_webpack_require_29564__(11);\n            var checkPropTypes = __nested_webpack_require_29564__(12);\n            module1.exports = function(isValidElement, throwOnDirectAccess) {\n                /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n                var FAUX_ITERATOR_SYMBOL = \"@@iterator\"; // Before Symbol spec.\n                /**\n\t   * Returns the iterator method function contained on the iterable object.\n\t   *\n\t   * Be sure to invoke the function with the iterable as context:\n\t   *\n\t   *     var iteratorFn = getIteratorFn(myIterable);\n\t   *     if (iteratorFn) {\n\t   *       var iterator = iteratorFn.call(myIterable);\n\t   *       ...\n\t   *     }\n\t   *\n\t   * @param {?object} maybeIterable\n\t   * @return {?function}\n\t   */ function getIteratorFn(maybeIterable) {\n                    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n                    if (typeof iteratorFn === \"function\") {\n                        return iteratorFn;\n                    }\n                }\n                /**\n\t   * Collection of methods that allow declaration and validation of props that are\n\t   * supplied to React components. Example usage:\n\t   *\n\t   *   var Props = require('ReactPropTypes');\n\t   *   var MyArticle = React.createClass({\n\t   *     propTypes: {\n\t   *       // An optional string prop named \"description\".\n\t   *       description: Props.string,\n\t   *\n\t   *       // A required enum prop named \"category\".\n\t   *       category: Props.oneOf(['News','Photos']).isRequired,\n\t   *\n\t   *       // A prop named \"dialog\" that requires an instance of Dialog.\n\t   *       dialog: Props.instanceOf(Dialog).isRequired\n\t   *     },\n\t   *     render: function() { ... }\n\t   *   });\n\t   *\n\t   * A more formal specification of how these methods are used:\n\t   *\n\t   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n\t   *   decl := ReactPropTypes.{type}(.isRequired)?\n\t   *\n\t   * Each and every declaration produces a function with the same signature. This\n\t   * allows the creation of custom validation functions. For example:\n\t   *\n\t   *  var MyLink = React.createClass({\n\t   *    propTypes: {\n\t   *      // An optional string or URI prop named \"href\".\n\t   *      href: function(props, propName, componentName) {\n\t   *        var propValue = props[propName];\n\t   *        if (propValue != null && typeof propValue !== 'string' &&\n\t   *            !(propValue instanceof URI)) {\n\t   *          return new Error(\n\t   *            'Expected a string or an URI for ' + propName + ' in ' +\n\t   *            componentName\n\t   *          );\n\t   *        }\n\t   *      }\n\t   *    },\n\t   *    render: function() {...}\n\t   *  });\n\t   *\n\t   * @internal\n\t   */ var ANONYMOUS = \"<<anonymous>>\";\n                // Important!\n                // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n                var ReactPropTypes = {\n                    array: createPrimitiveTypeChecker(\"array\"),\n                    bool: createPrimitiveTypeChecker(\"boolean\"),\n                    func: createPrimitiveTypeChecker(\"function\"),\n                    number: createPrimitiveTypeChecker(\"number\"),\n                    object: createPrimitiveTypeChecker(\"object\"),\n                    string: createPrimitiveTypeChecker(\"string\"),\n                    symbol: createPrimitiveTypeChecker(\"symbol\"),\n                    any: createAnyTypeChecker(),\n                    arrayOf: createArrayOfTypeChecker,\n                    element: createElementTypeChecker(),\n                    instanceOf: createInstanceTypeChecker,\n                    node: createNodeChecker(),\n                    objectOf: createObjectOfTypeChecker,\n                    oneOf: createEnumTypeChecker,\n                    oneOfType: createUnionTypeChecker,\n                    shape: createShapeTypeChecker,\n                    exact: createStrictShapeTypeChecker\n                };\n                /**\n\t   * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t   */ /*eslint-disable no-self-compare*/ function is(x, y) {\n                    // SameValue algorithm\n                    if (x === y) {\n                        // Steps 1-5, 7-10\n                        // Steps 6.b-6.e: +0 != -0\n                        return x !== 0 || 1 / x === 1 / y;\n                    } else {\n                        // Step 6.a: NaN == NaN\n                        return x !== x && y !== y;\n                    }\n                }\n                /*eslint-enable no-self-compare*/ /**\n\t   * We use an Error-like object for backward compatibility as people may call\n\t   * PropTypes directly and inspect their output. However, we don't use real\n\t   * Errors anymore. We don't inspect their stack anyway, and creating them\n\t   * is prohibitively expensive if they are created too often, such as what\n\t   * happens in oneOfType() for any type before the one that matched.\n\t   */ function PropTypeError(message) {\n                    this.message = message;\n                    this.stack = \"\";\n                }\n                // Make `instanceof Error` still work for returned errors.\n                PropTypeError.prototype = Error.prototype;\n                function createChainableTypeChecker(validate) {\n                    if (true) {\n                        var manualPropTypeCallCache = {};\n                        var manualPropTypeWarningCount = 0;\n                    }\n                    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n                        componentName = componentName || ANONYMOUS;\n                        propFullName = propFullName || propName;\n                        if (secret !== ReactPropTypesSecret) {\n                            if (throwOnDirectAccess) {\n                                // New behavior only for users of `prop-types` package\n                                invariant(false, \"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use `PropTypes.checkPropTypes()` to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                            } else if ( true && typeof console !== \"undefined\") {\n                                // Old behavior for people using React.PropTypes\n                                var cacheKey = componentName + \":\" + propName;\n                                if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n                                manualPropTypeWarningCount < 3) {\n                                    warning(false, \"You are manually calling a React.PropTypes validation \" + \"function for the `%s` prop on `%s`. This is deprecated \" + \"and will throw in the standalone `prop-types` package. \" + \"You may be seeing this warning due to a third-party PropTypes \" + \"library. See https://fb.me/react-warning-dont-call-proptypes \" + \"for details.\", propFullName, componentName);\n                                    manualPropTypeCallCache[cacheKey] = true;\n                                    manualPropTypeWarningCount++;\n                                }\n                            }\n                        }\n                        if (props[propName] == null) {\n                            if (isRequired) {\n                                if (props[propName] === null) {\n                                    return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n                                }\n                                return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n                            }\n                            return null;\n                        } else {\n                            return validate(props, propName, componentName, location, propFullName);\n                        }\n                    }\n                    var chainedCheckType = checkType.bind(null, false);\n                    chainedCheckType.isRequired = checkType.bind(null, true);\n                    return chainedCheckType;\n                }\n                function createPrimitiveTypeChecker(expectedType) {\n                    function validate(props, propName, componentName, location, propFullName, secret) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== expectedType) {\n                            // `propValue` being instance of, say, date/regexp, pass the 'object'\n                            // check, but we can offer a more precise error message here rather than\n                            // 'of type `object`'.\n                            var preciseType = getPreciseType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createAnyTypeChecker() {\n                    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n                }\n                function createArrayOfTypeChecker(typeChecker) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (typeof typeChecker !== \"function\") {\n                            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n                        }\n                        var propValue = props[propName];\n                        if (!Array.isArray(propValue)) {\n                            var propType = getPropType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n                        }\n                        for(var i = 0; i < propValue.length; i++){\n                            var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret);\n                            if (error instanceof Error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createElementTypeChecker() {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        if (!isValidElement(propValue)) {\n                            var propType = getPropType(propValue);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createInstanceTypeChecker(expectedClass) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (!(props[propName] instanceof expectedClass)) {\n                            var expectedClassName = expectedClass.name || ANONYMOUS;\n                            var actualClassName = getClassName(props[propName]);\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createEnumTypeChecker(expectedValues) {\n                    if (!Array.isArray(expectedValues)) {\n                         true ? warning(false, \"Invalid argument supplied to oneOf, expected an instance of array.\") : 0;\n                        return emptyFunction.thatReturnsNull;\n                    }\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        for(var i = 0; i < expectedValues.length; i++){\n                            if (is(propValue, expectedValues[i])) {\n                                return null;\n                            }\n                        }\n                        var valuesString = JSON.stringify(expectedValues);\n                        return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + propValue + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createObjectOfTypeChecker(typeChecker) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (typeof typeChecker !== \"function\") {\n                            return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n                        }\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n                        }\n                        for(var key in propValue){\n                            if (propValue.hasOwnProperty(key)) {\n                                var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                if (error instanceof Error) {\n                                    return error;\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createUnionTypeChecker(arrayOfTypeCheckers) {\n                    if (!Array.isArray(arrayOfTypeCheckers)) {\n                         true ? warning(false, \"Invalid argument supplied to oneOfType, expected an instance of array.\") : 0;\n                        return emptyFunction.thatReturnsNull;\n                    }\n                    for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                        var checker = arrayOfTypeCheckers[i];\n                        if (typeof checker !== \"function\") {\n                            warning(false, \"Invalid argument supplied to oneOfType. Expected an array of check functions, but \" + \"received %s at index %s.\", getPostfixForTypeWarning(checker), i);\n                            return emptyFunction.thatReturnsNull;\n                        }\n                    }\n                    function validate(props, propName, componentName, location, propFullName) {\n                        for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                            var checker = arrayOfTypeCheckers[i];\n                            if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n                                return null;\n                            }\n                        }\n                        return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`.\"));\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createNodeChecker() {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        if (!isNode(props[propName])) {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createShapeTypeChecker(shapeTypes) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                        }\n                        for(var key in shapeTypes){\n                            var checker = shapeTypes[key];\n                            if (!checker) {\n                                continue;\n                            }\n                            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                            if (error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function createStrictShapeTypeChecker(shapeTypes) {\n                    function validate(props, propName, componentName, location, propFullName) {\n                        var propValue = props[propName];\n                        var propType = getPropType(propValue);\n                        if (propType !== \"object\") {\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                        }\n                        // We need to check all keys in case some are required but missing from\n                        // props.\n                        var allKeys = assign({}, props[propName], shapeTypes);\n                        for(var key in allKeys){\n                            var checker = shapeTypes[key];\n                            if (!checker) {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\" + \"\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \"));\n                            }\n                            var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                            if (error) {\n                                return error;\n                            }\n                        }\n                        return null;\n                    }\n                    return createChainableTypeChecker(validate);\n                }\n                function isNode(propValue) {\n                    switch(typeof propValue){\n                        case \"number\":\n                        case \"string\":\n                        case \"undefined\":\n                            return true;\n                        case \"boolean\":\n                            return !propValue;\n                        case \"object\":\n                            if (Array.isArray(propValue)) {\n                                return propValue.every(isNode);\n                            }\n                            if (propValue === null || isValidElement(propValue)) {\n                                return true;\n                            }\n                            var iteratorFn = getIteratorFn(propValue);\n                            if (iteratorFn) {\n                                var iterator = iteratorFn.call(propValue);\n                                var step;\n                                if (iteratorFn !== propValue.entries) {\n                                    while(!(step = iterator.next()).done){\n                                        if (!isNode(step.value)) {\n                                            return false;\n                                        }\n                                    }\n                                } else {\n                                    // Iterator will provide entry [k,v] tuples rather than values.\n                                    while(!(step = iterator.next()).done){\n                                        var entry = step.value;\n                                        if (entry) {\n                                            if (!isNode(entry[1])) {\n                                                return false;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                return false;\n                            }\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n                function isSymbol(propType, propValue) {\n                    // Native Symbol.\n                    if (propType === \"symbol\") {\n                        return true;\n                    }\n                    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n                    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n                        return true;\n                    }\n                    // Fallback for non-spec compliant Symbols which are polyfilled.\n                    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n                        return true;\n                    }\n                    return false;\n                }\n                // Equivalent of `typeof` but with special handling for array and regexp.\n                function getPropType(propValue) {\n                    var propType = typeof propValue;\n                    if (Array.isArray(propValue)) {\n                        return \"array\";\n                    }\n                    if (propValue instanceof RegExp) {\n                        // Old webkits (at least until Android 4.0) return 'function' rather than\n                        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n                        // passes PropTypes.object.\n                        return \"object\";\n                    }\n                    if (isSymbol(propType, propValue)) {\n                        return \"symbol\";\n                    }\n                    return propType;\n                }\n                // This handles more types than `getPropType`. Only used for error messages.\n                // See `createPrimitiveTypeChecker`.\n                function getPreciseType(propValue) {\n                    if (typeof propValue === \"undefined\" || propValue === null) {\n                        return \"\" + propValue;\n                    }\n                    var propType = getPropType(propValue);\n                    if (propType === \"object\") {\n                        if (propValue instanceof Date) {\n                            return \"date\";\n                        } else if (propValue instanceof RegExp) {\n                            return \"regexp\";\n                        }\n                    }\n                    return propType;\n                }\n                // Returns a string that is postfixed to a warning about an invalid type.\n                // For example, \"undefined\" or \"of type array\"\n                function getPostfixForTypeWarning(value) {\n                    var type = getPreciseType(value);\n                    switch(type){\n                        case \"array\":\n                        case \"object\":\n                            return \"an \" + type;\n                        case \"boolean\":\n                        case \"date\":\n                        case \"regexp\":\n                            return \"a \" + type;\n                        default:\n                            return type;\n                    }\n                }\n                // Returns class name of the object, if any.\n                function getClassName(propValue) {\n                    if (!propValue.constructor || !propValue.constructor.name) {\n                        return ANONYMOUS;\n                    }\n                    return propValue.constructor.name;\n                }\n                ReactPropTypes.checkPropTypes = checkPropTypes;\n                ReactPropTypes.PropTypes = ReactPropTypes;\n                return ReactPropTypes;\n            };\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_29564__(5));\n    /***/ },\n    /* 7 */ /***/ function(module1, exports) {\n        \"use strict\";\n        /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t *\n\t * \n\t */ function makeEmptyFunction(arg) {\n            return function() {\n                return arg;\n            };\n        }\n        /**\n\t * This function accepts and discards inputs; it has no side effects. This is\n\t * primarily useful idiomatically for overridable function endpoints which\n\t * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n\t */ var emptyFunction = function emptyFunction() {};\n        emptyFunction.thatReturns = makeEmptyFunction;\n        emptyFunction.thatReturnsFalse = makeEmptyFunction(false);\n        emptyFunction.thatReturnsTrue = makeEmptyFunction(true);\n        emptyFunction.thatReturnsNull = makeEmptyFunction(null);\n        emptyFunction.thatReturnsThis = function() {\n            return this;\n        };\n        emptyFunction.thatReturnsArgument = function(arg) {\n            return arg;\n        };\n        module1.exports = emptyFunction;\n    /***/ },\n    /* 8 */ /***/ function(module1, exports, __nested_webpack_require_57096__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            \"use strict\";\n            /**\n\t * Use invariant() to assert state which your program assumes to be true.\n\t *\n\t * Provide sprintf-style format (only %s is supported) and arguments\n\t * to provide information about what broke and what you were\n\t * expecting.\n\t *\n\t * The invariant message will be stripped in production, but the invariant\n\t * will remain to ensure logic does not differ in production.\n\t */ var validateFormat = function validateFormat(format) {};\n            if (true) {\n                validateFormat = function validateFormat(format) {\n                    if (format === undefined) {\n                        throw new Error(\"invariant requires an error message argument\");\n                    }\n                };\n            }\n            function invariant(condition, format, a, b, c, d, e, f) {\n                validateFormat(format);\n                if (!condition) {\n                    var error;\n                    if (format === undefined) {\n                        error = new Error(\"Minified exception occurred; use the non-minified dev environment \" + \"for the full error message and additional helpful warnings.\");\n                    } else {\n                        var args = [\n                            a,\n                            b,\n                            c,\n                            d,\n                            e,\n                            f\n                        ];\n                        var argIndex = 0;\n                        error = new Error(format.replace(/%s/g, function() {\n                            return args[argIndex++];\n                        }));\n                        error.name = \"Invariant Violation\";\n                    }\n                    error.framesToPop = 1; // we don't care about invariant's own frame\n                    throw error;\n                }\n            }\n            module1.exports = invariant;\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_57096__(5));\n    /***/ },\n    /* 9 */ /***/ function(module1, exports, __nested_webpack_require_59249__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            \"use strict\";\n            var emptyFunction = __nested_webpack_require_59249__(7);\n            /**\n\t * Similar to invariant but only logs a warning if the condition is not met.\n\t * This can be used to log issues in development environments in critical\n\t * paths. Removing the logging code for production environments will keep the\n\t * same logic and follow the same code paths.\n\t */ var warning = emptyFunction;\n            if (true) {\n                var printWarning = function printWarning(format) {\n                    for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    var argIndex = 0;\n                    var message = \"Warning: \" + format.replace(/%s/g, function() {\n                        return args[argIndex++];\n                    });\n                    if (typeof console !== \"undefined\") {\n                        console.error(message);\n                    }\n                    try {\n                        // --- Welcome to debugging React ---\n                        // This error was thrown as a convenience so that you can use this stack\n                        // to find the callsite that caused this warning to fire.\n                        throw new Error(message);\n                    } catch (x) {}\n                };\n                warning = function warning(condition, format) {\n                    if (format === undefined) {\n                        throw new Error(\"`warning(condition, format, ...args)` requires a warning \" + \"message argument\");\n                    }\n                    if (format.indexOf(\"Failed Composite propType: \") === 0) {\n                        return; // Ignore CompositeComponent proptype check.\n                    }\n                    if (!condition) {\n                        for(var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){\n                            args[_key2 - 2] = arguments[_key2];\n                        }\n                        printWarning.apply(undefined, [\n                            format\n                        ].concat(args));\n                    }\n                };\n            }\n            module1.exports = warning;\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_59249__(5));\n    /***/ },\n    /* 10 */ /***/ function(module1, exports) {\n        /*\n\tobject-assign\n\t(c) Sindre Sorhus\n\t@license MIT\n\t*/ \"use strict\";\n        /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n        function toObject(val) {\n            if (val === null || val === undefined) {\n                throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n            }\n            return Object(val);\n        }\n        function shouldUseNative() {\n            try {\n                if (!Object.assign) {\n                    return false;\n                }\n                // Detect buggy property enumeration order in older V8 versions.\n                // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n                var test1 = new String(\"abc\"); // eslint-disable-line no-new-wrappers\n                test1[5] = \"de\";\n                if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n                    return false;\n                }\n                // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                var test2 = {};\n                for(var i = 0; i < 10; i++){\n                    test2[\"_\" + String.fromCharCode(i)] = i;\n                }\n                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n                    return test2[n];\n                });\n                if (order2.join(\"\") !== \"0123456789\") {\n                    return false;\n                }\n                // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                var test3 = {};\n                \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n                    test3[letter] = letter;\n                });\n                if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n                    return false;\n                }\n                return true;\n            } catch (err) {\n                // We don't expect any of the above to throw, but better to be safe.\n                return false;\n            }\n        }\n        module1.exports = shouldUseNative() ? Object.assign : function(target, source) {\n            var from;\n            var to = toObject(target);\n            var symbols;\n            for(var s = 1; s < arguments.length; s++){\n                from = Object(arguments[s]);\n                for(var key in from){\n                    if (hasOwnProperty.call(from, key)) {\n                        to[key] = from[key];\n                    }\n                }\n                if (getOwnPropertySymbols) {\n                    symbols = getOwnPropertySymbols(from);\n                    for(var i = 0; i < symbols.length; i++){\n                        if (propIsEnumerable.call(from, symbols[i])) {\n                            to[symbols[i]] = from[symbols[i]];\n                        }\n                    }\n                }\n            }\n            return to;\n        };\n    /***/ },\n    /* 11 */ /***/ function(module1, exports) {\n        /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t */ \"use strict\";\n        var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n        module1.exports = ReactPropTypesSecret;\n    /***/ },\n    /* 12 */ /***/ function(module1, exports, __nested_webpack_require_65294__) {\n        /* WEBPACK VAR INJECTION */ (function(process) {\n            \"use strict\";\n            if (true) {\n                var invariant = __nested_webpack_require_65294__(8);\n                var warning = __nested_webpack_require_65294__(9);\n                var ReactPropTypesSecret = __nested_webpack_require_65294__(11);\n                var loggedTypeFailures = {};\n            }\n            /**\n\t * Assert that the values match with the type specs.\n\t * Error messages are memorized and will only be shown once.\n\t *\n\t * @param {object} typeSpecs Map of name to a ReactPropType\n\t * @param {object} values Runtime values that need to be type-checked\n\t * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n\t * @param {string} componentName Name of the component for error messages.\n\t * @param {?Function} getStack Returns the component stack.\n\t * @private\n\t */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n                if (true) {\n                    for(var typeSpecName in typeSpecs){\n                        if (typeSpecs.hasOwnProperty(typeSpecName)) {\n                            var error;\n                            // Prop type validation may throw. In case they do, we don't want to\n                            // fail the render phase where it didn't fail before. So we log it.\n                            // After these have been cleaned up, we'll let them throw.\n                            try {\n                                // This is intentionally an invariant that gets caught. It's the same\n                                // behavior as without this statement except with a better message.\n                                invariant(typeof typeSpecs[typeSpecName] === \"function\", \"%s: %s type `%s` is invalid; it must be a function, usually from \" + \"the `prop-types` package, but received `%s`.\", componentName || \"React class\", location, typeSpecName, typeof typeSpecs[typeSpecName]);\n                                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n                            } catch (ex) {\n                                error = ex;\n                            }\n                            warning(!error || error instanceof Error, \"%s: type specification of %s `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error);\n                            if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                                // Only monitor this failure once because there tends to be a lot of the\n                                // same error.\n                                loggedTypeFailures[error.message] = true;\n                                var stack = getStack ? getStack() : \"\";\n                                warning(false, \"Failed %s type: %s%s\", location, error.message, stack != null ? stack : \"\");\n                            }\n                        }\n                    }\n                }\n            }\n            module1.exports = checkPropTypes;\n        /* WEBPACK VAR INJECTION */ }).call(exports, __nested_webpack_require_65294__(5));\n    /***/ },\n    /* 13 */ /***/ function(module1, exports, __nested_webpack_require_68808__) {\n        /**\n\t * Copyright (c) 2013-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t */ \"use strict\";\n        var emptyFunction = __nested_webpack_require_68808__(7);\n        var invariant = __nested_webpack_require_68808__(8);\n        var ReactPropTypesSecret = __nested_webpack_require_68808__(11);\n        module1.exports = function() {\n            function shim(props, propName, componentName, location, propFullName, secret) {\n                if (secret === ReactPropTypesSecret) {\n                    // It is still safe when called from React.\n                    return;\n                }\n                invariant(false, \"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use PropTypes.checkPropTypes() to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n            }\n            ;\n            shim.isRequired = shim;\n            function getShim() {\n                return shim;\n            }\n            ;\n            // Important!\n            // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n            var ReactPropTypes = {\n                array: shim,\n                bool: shim,\n                func: shim,\n                number: shim,\n                object: shim,\n                string: shim,\n                symbol: shim,\n                any: shim,\n                arrayOf: getShim,\n                element: shim,\n                instanceOf: getShim,\n                node: shim,\n                objectOf: getShim,\n                oneOf: getShim,\n                oneOfType: getShim,\n                shape: getShim,\n                exact: getShim\n            };\n            ReactPropTypes.checkPropTypes = emptyFunction;\n            ReactPropTypes.PropTypes = ReactPropTypes;\n            return ReactPropTypes;\n        };\n    /***/ },\n    /* 14 */ /***/ function(module1, exports) {\n        module1.exports = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n    /***/ },\n    /* 15 */ /***/ function(module1, exports) {\n        \"use strict\";\n        var simpleIsEqual = function simpleIsEqual(a, b) {\n            return a === b;\n        };\n        function index(resultFn) {\n            var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : simpleIsEqual;\n            var lastThis = void 0;\n            var lastArgs = [];\n            var lastResult = void 0;\n            var calledOnce = false;\n            var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {\n                return isEqual(newArg, lastArgs[index]);\n            };\n            var result = function result() {\n                for(var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++){\n                    newArgs[_key] = arguments[_key];\n                }\n                if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {\n                    return lastResult;\n                }\n                calledOnce = true;\n                lastThis = this;\n                lastArgs = newArgs;\n                lastResult = resultFn.apply(this, newArgs);\n                return lastResult;\n            };\n            return result;\n        }\n        module1.exports = index;\n    /***/ }\n]); //# sourceMappingURL=main.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaGlnaGxpZ2h0LXdvcmRzL2Rpc3QvbWFpbi5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLE9BQU9DLE9BQU8sR0FDTCxNQUFILEdBQUksU0FBU0MsT0FBTztJQUMxQixNQUFNLEdBQUksbUJBQW1CO0lBQzdCLE1BQU0sR0FBSSxJQUFJQyxtQkFBbUIsQ0FBQztJQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVCQUF1QjtJQUNqQyxNQUFNLEdBQUksU0FBU0MsOEJBQW1CQSxDQUFDQyxRQUFRO1FBQy9DLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1FBQ3pDLE1BQU0sR0FBSyxJQUFHRixnQkFBZ0IsQ0FBQ0UsU0FBUyxFQUN4QyxNQUFNLEdBQU0sT0FBT0YsZ0JBQWdCLENBQUNFLFNBQVMsQ0FBQ0osT0FBTztRQUNyRCxNQUFNLEdBQ04sTUFBTSxHQUFLLGtEQUFrRDtRQUM3RCxNQUFNLEdBQUssSUFBSUQsVUFBU0csZ0JBQWdCLENBQUNFLFNBQVMsR0FBRztZQUNyRCxNQUFNLEdBQU1KLFNBQVMsQ0FBQztZQUN0QixNQUFNLEdBQU1LLElBQUlEO1lBQ2hCLE1BQU0sR0FBTUUsUUFBUTtRQUNUO1FBQ1gsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7UUFDekMsTUFBTSxHQUFLTCxPQUFPLENBQUNHLFNBQVMsQ0FBQ0csSUFBSSxDQUFDUixRQUFPQyxPQUFPLEVBQUVELFNBQVFBLFFBQU9DLE9BQU8sRUFBRUcsOEJBQW1CQTtRQUM3RixNQUFNLEdBQ04sTUFBTSxHQUFLLDRCQUE0QjtRQUN2QyxNQUFNLEdBQUtKLFFBQU9PLE1BQU0sR0FBRztRQUMzQixNQUFNLEdBQ04sTUFBTSxHQUFLLG1DQUFtQztRQUM5QyxNQUFNLEdBQUssT0FBT1AsUUFBT0MsT0FBTztJQUNoQyxNQUFNLEdBQUk7SUFDVixNQUFNLEdBQ04sTUFBTSxHQUNOLE1BQU0sR0FBSSxrREFBa0Q7SUFDNUQsTUFBTSxHQUFJRyw4QkFBbUJBLENBQUNL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LGNBQWMzQyxDQUFDLEVBQUVDLENBQUM7WUFDN0MsT0FBT0QsTUFBTUM7UUFDZjtRQUVBLFNBQVMzTSxNQUFPc1AsUUFBUTtZQUN0QixJQUFJQyxVQUFVNVQsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUs2QyxZQUFZN0MsU0FBUyxDQUFDLEVBQUUsR0FBRzBUO1lBRWxGLElBQUlHLFdBQVcsS0FBSztZQUNwQixJQUFJQyxXQUFXLEVBQUU7WUFDakIsSUFBSUMsYUFBYSxLQUFLO1lBQ3RCLElBQUlDLGFBQWE7WUFFakIsSUFBSUMsc0JBQXNCLFNBQVNBLG9CQUFvQkMsTUFBTSxFQUFFN1AsS0FBSztnQkFDbEUsT0FBT3VQLFFBQVFNLFFBQVFKLFFBQVEsQ0FBQ3pQLE1BQU07WUFDeEM7WUFFQSxJQUFJOFAsU0FBUyxTQUFTQTtnQkFDcEIsSUFBSyxJQUFJN0MsT0FBT3RSLFVBQVVDLE1BQU0sRUFBRW1VLFVBQVVoTCxNQUFNa0ksT0FBT0MsT0FBTyxHQUFHQSxPQUFPRCxNQUFNQyxPQUFRO29CQUN0RjZDLE9BQU8sQ0FBQzdDLEtBQUssR0FBR3ZSLFNBQVMsQ0FBQ3VSLEtBQUs7Z0JBQ2pDO2dCQUVBLElBQUl5QyxjQUFjSCxhQUFhLElBQUksSUFBSU8sUUFBUW5VLE1BQU0sS0FBSzZULFNBQVM3VCxNQUFNLElBQUltVSxRQUFRMUUsS0FBSyxDQUFDdUUsc0JBQXNCO29CQUMvRyxPQUFPRjtnQkFDVDtnQkFFQUMsYUFBYTtnQkFDYkgsV0FBVyxJQUFJO2dCQUNmQyxXQUFXTTtnQkFDWEwsYUFBYUosU0FBU3BLLEtBQUssQ0FBQyxJQUFJLEVBQUU2SztnQkFDbEMsT0FBT0w7WUFDVDtZQUVBLE9BQU9JO1FBQ1Q7UUFFQTNWLFFBQU9DLE9BQU8sR0FBRzRGO0lBR2xCLEdBQUcsR0FBRztDQUNJLEdBQ1YsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWhpZ2hsaWdodC13b3Jkcy9kaXN0L21haW4uanM/YjVkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXHRcblx0dmFyIF9IaWdobGlnaHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFxuXHR2YXIgX0hpZ2hsaWdodGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hpZ2hsaWdodGVyKTtcblxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBfSGlnaGxpZ2h0ZXIyWydkZWZhdWx0J107XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXHRcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gSGlnaGxpZ2h0ZXI7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cdFxuXHR2YXIgX2hpZ2hsaWdodFdvcmRzQ29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFxuXHR2YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHR2YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXHRcblx0dmFyIF9yZWFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHRcblx0dmFyIF9tZW1vaXplT25lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdFxuXHR2YXIgX21lbW9pemVPbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVtb2l6ZU9uZSk7XG5cdFxuXHRIaWdobGlnaHRlci5wcm9wVHlwZXMgPSB7XG5cdCAgYWN0aXZlQ2xhc3NOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcblx0ICBhY3RpdmVJbmRleDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5udW1iZXIsXG5cdCAgYWN0aXZlU3R5bGU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub2JqZWN0LFxuXHQgIGF1dG9Fc2NhcGU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYm9vbCxcblx0ICBjbGFzc05hbWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuXHQgIGZpbmRDaHVua3M6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBoaWdobGlnaHRDbGFzc05hbWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdCwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmddKSxcblx0ICBoaWdobGlnaHRTdHlsZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3QsXG5cdCAgaGlnaGxpZ2h0VGFnOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ub2RlLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsIF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nXSksXG5cdCAgc2FuaXRpemU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYyxcblx0ICBzZWFyY2hXb3JkczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5hcnJheU9mKF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZywgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5pbnN0YW5jZU9mKFJlZ0V4cCldKSkuaXNSZXF1aXJlZCxcblx0ICB0ZXh0VG9IaWdobGlnaHQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLmlzUmVxdWlyZWQsXG5cdCAgdW5oaWdobGlnaHRUYWc6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10ub25lT2ZUeXBlKFtfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm5vZGUsIF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZnVuYywgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmddKSxcblx0ICB1bmhpZ2hsaWdodENsYXNzTmFtZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcsXG5cdCAgdW5oaWdobGlnaHRTdHlsZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3Rcblx0fTtcblx0XG5cdC8qKlxyXG5cdCAqIEhpZ2hsaWdodHMgYWxsIG9jY3VycmVuY2VzIG9mIHNlYXJjaCB0ZXJtcyAoc2VhcmNoVGV4dCkgd2l0aGluIGEgc3RyaW5nICh0ZXh0VG9IaWdobGlnaHQpLlxyXG5cdCAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCA8c3Bhbj5zICh3cmFwcGluZyBoaWdobGlnaHRlZCB3b3JkcykuXHJcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBIaWdobGlnaHRlcihfcmVmKSB7XG5cdCAgdmFyIF9yZWYkYWN0aXZlQ2xhc3NOYW1lID0gX3JlZi5hY3RpdmVDbGFzc05hbWU7XG5cdCAgdmFyIGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYkYWN0aXZlQ2xhc3NOYW1lID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkYWN0aXZlQ2xhc3NOYW1lO1xuXHQgIHZhciBfcmVmJGFjdGl2ZUluZGV4ID0gX3JlZi5hY3RpdmVJbmRleDtcblx0ICB2YXIgYWN0aXZlSW5kZXggPSBfcmVmJGFjdGl2ZUluZGV4ID09PSB1bmRlZmluZWQgPyAtMSA6IF9yZWYkYWN0aXZlSW5kZXg7XG5cdCAgdmFyIGFjdGl2ZVN0eWxlID0gX3JlZi5hY3RpdmVTdHlsZTtcblx0ICB2YXIgYXV0b0VzY2FwZSA9IF9yZWYuYXV0b0VzY2FwZTtcblx0ICB2YXIgX3JlZiRjYXNlU2Vuc2l0aXZlID0gX3JlZi5jYXNlU2Vuc2l0aXZlO1xuXHQgIHZhciBjYXNlU2Vuc2l0aXZlID0gX3JlZiRjYXNlU2Vuc2l0aXZlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY2FzZVNlbnNpdGl2ZTtcblx0ICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWU7XG5cdCAgdmFyIGZpbmRDaHVua3MgPSBfcmVmLmZpbmRDaHVua3M7XG5cdCAgdmFyIF9yZWYkaGlnaGxpZ2h0Q2xhc3NOYW1lID0gX3JlZi5oaWdobGlnaHRDbGFzc05hbWU7XG5cdCAgdmFyIGhpZ2hsaWdodENsYXNzTmFtZSA9IF9yZWYkaGlnaGxpZ2h0Q2xhc3NOYW1lID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkaGlnaGxpZ2h0Q2xhc3NOYW1lO1xuXHQgIHZhciBfcmVmJGhpZ2hsaWdodFN0eWxlID0gX3JlZi5oaWdobGlnaHRTdHlsZTtcblx0ICB2YXIgaGlnaGxpZ2h0U3R5bGUgPSBfcmVmJGhpZ2hsaWdodFN0eWxlID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYkaGlnaGxpZ2h0U3R5bGU7XG5cdCAgdmFyIF9yZWYkaGlnaGxpZ2h0VGFnID0gX3JlZi5oaWdobGlnaHRUYWc7XG5cdCAgdmFyIGhpZ2hsaWdodFRhZyA9IF9yZWYkaGlnaGxpZ2h0VGFnID09PSB1bmRlZmluZWQgPyAnbWFyaycgOiBfcmVmJGhpZ2hsaWdodFRhZztcblx0ICB2YXIgc2FuaXRpemUgPSBfcmVmLnNhbml0aXplO1xuXHQgIHZhciBzZWFyY2hXb3JkcyA9IF9yZWYuc2VhcmNoV29yZHM7XG5cdCAgdmFyIHRleHRUb0hpZ2hsaWdodCA9IF9yZWYudGV4dFRvSGlnaGxpZ2h0O1xuXHQgIHZhciBfcmVmJHVuaGlnaGxpZ2h0VGFnID0gX3JlZi51bmhpZ2hsaWdodFRhZztcblx0ICB2YXIgdW5oaWdobGlnaHRUYWcgPSBfcmVmJHVuaGlnaGxpZ2h0VGFnID09PSB1bmRlZmluZWQgPyAnc3BhbicgOiBfcmVmJHVuaGlnaGxpZ2h0VGFnO1xuXHQgIHZhciBfcmVmJHVuaGlnaGxpZ2h0Q2xhc3NOYW1lID0gX3JlZi51bmhpZ2hsaWdodENsYXNzTmFtZTtcblx0ICB2YXIgdW5oaWdobGlnaHRDbGFzc05hbWUgPSBfcmVmJHVuaGlnaGxpZ2h0Q2xhc3NOYW1lID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkdW5oaWdobGlnaHRDbGFzc05hbWU7XG5cdCAgdmFyIHVuaGlnaGxpZ2h0U3R5bGUgPSBfcmVmLnVuaGlnaGxpZ2h0U3R5bGU7XG5cdFxuXHQgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnYWN0aXZlQ2xhc3NOYW1lJywgJ2FjdGl2ZUluZGV4JywgJ2FjdGl2ZVN0eWxlJywgJ2F1dG9Fc2NhcGUnLCAnY2FzZVNlbnNpdGl2ZScsICdjbGFzc05hbWUnLCAnZmluZENodW5rcycsICdoaWdobGlnaHRDbGFzc05hbWUnLCAnaGlnaGxpZ2h0U3R5bGUnLCAnaGlnaGxpZ2h0VGFnJywgJ3Nhbml0aXplJywgJ3NlYXJjaFdvcmRzJywgJ3RleHRUb0hpZ2hsaWdodCcsICd1bmhpZ2hsaWdodFRhZycsICd1bmhpZ2hsaWdodENsYXNzTmFtZScsICd1bmhpZ2hsaWdodFN0eWxlJ10pO1xuXHRcblx0ICB2YXIgY2h1bmtzID0gKDAsIF9oaWdobGlnaHRXb3Jkc0NvcmUuZmluZEFsbCkoe1xuXHQgICAgYXV0b0VzY2FwZTogYXV0b0VzY2FwZSxcblx0ICAgIGNhc2VTZW5zaXRpdmU6IGNhc2VTZW5zaXRpdmUsXG5cdCAgICBmaW5kQ2h1bmtzOiBmaW5kQ2h1bmtzLFxuXHQgICAgc2FuaXRpemU6IHNhbml0aXplLFxuXHQgICAgc2VhcmNoV29yZHM6IHNlYXJjaFdvcmRzLFxuXHQgICAgdGV4dFRvSGlnaGxpZ2h0OiB0ZXh0VG9IaWdobGlnaHRcblx0ICB9KTtcblx0ICB2YXIgSGlnaGxpZ2h0VGFnID0gaGlnaGxpZ2h0VGFnO1xuXHQgIHZhciBoaWdobGlnaHRJbmRleCA9IC0xO1xuXHQgIHZhciBoaWdobGlnaHRDbGFzc05hbWVzID0gJyc7XG5cdCAgdmFyIGhpZ2hsaWdodFN0eWxlcyA9IHVuZGVmaW5lZDtcblx0XG5cdCAgdmFyIGxvd2VyY2FzZVByb3BzID0gZnVuY3Rpb24gbG93ZXJjYXNlUHJvcHMob2JqZWN0KSB7XG5cdCAgICB2YXIgbWFwcGVkID0ge307XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG5cdCAgICAgIG1hcHBlZFtrZXkudG9Mb3dlckNhc2UoKV0gPSBvYmplY3Rba2V5XTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBtYXBwZWQ7XG5cdCAgfTtcblx0ICB2YXIgbWVtb2l6ZWRMb3dlcmNhc2VQcm9wcyA9ICgwLCBfbWVtb2l6ZU9uZTJbJ2RlZmF1bHQnXSkobG93ZXJjYXNlUHJvcHMpO1xuXHRcblx0ICByZXR1cm4gKDAsIF9yZWFjdC5jcmVhdGVFbGVtZW50KSgnc3BhbicsIF9leHRlbmRzKHtcblx0ICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG5cdCAgfSwgcmVzdCwge1xuXHQgICAgY2hpbGRyZW46IGNodW5rcy5tYXAoZnVuY3Rpb24gKGNodW5rLCBpbmRleCkge1xuXHQgICAgICB2YXIgdGV4dCA9IHRleHRUb0hpZ2hsaWdodC5zdWJzdHIoY2h1bmsuc3RhcnQsIGNodW5rLmVuZCAtIGNodW5rLnN0YXJ0KTtcblx0XG5cdCAgICAgIGlmIChjaHVuay5oaWdobGlnaHQpIHtcblx0ICAgICAgICBoaWdobGlnaHRJbmRleCsrO1xuXHRcblx0ICAgICAgICB2YXIgaGlnaGxpZ2h0Q2xhc3MgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBoaWdobGlnaHRDbGFzc05hbWUgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcblx0ICAgICAgICAgICAgaGlnaGxpZ2h0Q2xhc3NOYW1lID0gbWVtb2l6ZWRMb3dlcmNhc2VQcm9wcyhoaWdobGlnaHRDbGFzc05hbWUpO1xuXHQgICAgICAgICAgICBoaWdobGlnaHRDbGFzcyA9IGhpZ2hsaWdodENsYXNzTmFtZVt0ZXh0LnRvTG93ZXJDYXNlKCldO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaGlnaGxpZ2h0Q2xhc3MgPSBoaWdobGlnaHRDbGFzc05hbWVbdGV4dF07XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGhpZ2hsaWdodENsYXNzID0gaGlnaGxpZ2h0Q2xhc3NOYW1lO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdmFyIGlzQWN0aXZlID0gaGlnaGxpZ2h0SW5kZXggPT09ICthY3RpdmVJbmRleDtcblx0XG5cdCAgICAgICAgaGlnaGxpZ2h0Q2xhc3NOYW1lcyA9IGhpZ2hsaWdodENsYXNzICsgJyAnICsgKGlzQWN0aXZlID8gYWN0aXZlQ2xhc3NOYW1lIDogJycpO1xuXHQgICAgICAgIGhpZ2hsaWdodFN0eWxlcyA9IGlzQWN0aXZlID09PSB0cnVlICYmIGFjdGl2ZVN0eWxlICE9IG51bGwgPyBPYmplY3QuYXNzaWduKHt9LCBoaWdobGlnaHRTdHlsZSwgYWN0aXZlU3R5bGUpIDogaGlnaGxpZ2h0U3R5bGU7XG5cdFxuXHQgICAgICAgIHZhciBwcm9wcyA9IHtcblx0ICAgICAgICAgIGNoaWxkcmVuOiB0ZXh0LFxuXHQgICAgICAgICAgY2xhc3NOYW1lOiBoaWdobGlnaHRDbGFzc05hbWVzLFxuXHQgICAgICAgICAga2V5OiBpbmRleCxcblx0ICAgICAgICAgIHN0eWxlOiBoaWdobGlnaHRTdHlsZXNcblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICAvLyBEb24ndCBhdHRhY2ggYXJiaXRyYXJ5IHByb3BzIHRvIERPTSBlbGVtZW50czsgdGhpcyB0cmlnZ2VycyBSZWFjdCBERVYgd2FybmluZ3MgKGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wKVxuXHQgICAgICAgIC8vIE9ubHkgcGFzcyB0aHJvdWdoIHRoZSBoaWdobGlnaHRJbmRleCBhdHRyaWJ1dGUgZm9yIGN1c3RvbSBjb21wb25lbnRzLlxuXHQgICAgICAgIGlmICh0eXBlb2YgSGlnaGxpZ2h0VGFnICE9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgcHJvcHMuaGlnaGxpZ2h0SW5kZXggPSBoaWdobGlnaHRJbmRleDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHJldHVybiAoMCwgX3JlYWN0LmNyZWF0ZUVsZW1lbnQpKEhpZ2hsaWdodFRhZywgcHJvcHMpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiAoMCwgX3JlYWN0LmNyZWF0ZUVsZW1lbnQpKHVuaGlnaGxpZ2h0VGFnLCB7XG5cdCAgICAgICAgICBjaGlsZHJlbjogdGV4dCxcblx0ICAgICAgICAgIGNsYXNzTmFtZTogdW5oaWdobGlnaHRDbGFzc05hbWUsXG5cdCAgICAgICAgICBrZXk6IGluZGV4LFxuXHQgICAgICAgICAgc3R5bGU6IHVuaGlnaGxpZ2h0U3R5bGVcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgfSlcblx0ICB9KSk7XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9XG5cdC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcblx0LyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHQvKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG5cdC8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0LyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcblx0LyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG5cdC8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcblx0LyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuXHQvKioqKioqLyBcdFx0fTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdC8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdC8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG5cdC8qKioqKiovIFx0fVxuXHQvKioqKioqL1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuXHQvKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXHQvKioqKioqLyB9KVxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqLyAoW1xuXHQvKiAwICovXG5cdC8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcblx0XG5cdC8qKiovIH0pLFxuXHQvKiAxICovXG5cdC8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0J3VzZSBzdHJpY3QnO1xuXHRcdFxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdCAgdmFsdWU6IHRydWVcblx0XHR9KTtcblx0XHRcblx0XHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XHRcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NvbWJpbmVDaHVua3MnLCB7XG5cdFx0ICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0ICAgIHJldHVybiBfdXRpbHMuY29tYmluZUNodW5rcztcblx0XHQgIH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2ZpbGxJbkNodW5rcycsIHtcblx0XHQgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHQgICAgcmV0dXJuIF91dGlscy5maWxsSW5DaHVua3M7XG5cdFx0ICB9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmaW5kQWxsJywge1xuXHRcdCAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdCAgICByZXR1cm4gX3V0aWxzLmZpbmRBbGw7XG5cdFx0ICB9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmaW5kQ2h1bmtzJywge1xuXHRcdCAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdCAgICByZXR1cm4gX3V0aWxzLmZpbmRDaHVua3M7XG5cdFx0ICB9XG5cdFx0fSk7XG5cdFxuXHQvKioqLyB9KSxcblx0LyogMiAqL1xuXHQvKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdCd1c2Ugc3RyaWN0Jztcblx0XHRcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHQgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhbiBhcnJheSBvZiBjaHVuayBvYmplY3RzIHJlcHJlc2VudGluZyBib3RoIGhpZ2xpZ2h0YWJsZSBhbmQgbm9uIGhpZ2hsaWdodGFibGUgcGllY2VzIG9mIHRleHQgdGhhdCBtYXRjaCBlYWNoIHNlYXJjaCB3b3JkLlxuXHRcdCAqIEByZXR1cm4gQXJyYXkgb2YgXCJjaHVua3NcIiAod2hlcmUgYSBDaHVuayBpcyB7IHN0YXJ0Om51bWJlciwgZW5kOm51bWJlciwgaGlnaGxpZ2h0OmJvb2xlYW4gfSlcblx0XHQgKi9cblx0XHR2YXIgZmluZEFsbCA9IGV4cG9ydHMuZmluZEFsbCA9IGZ1bmN0aW9uIGZpbmRBbGwoX3JlZikge1xuXHRcdCAgdmFyIGF1dG9Fc2NhcGUgPSBfcmVmLmF1dG9Fc2NhcGUsXG5cdFx0ICAgICAgX3JlZiRjYXNlU2Vuc2l0aXZlID0gX3JlZi5jYXNlU2Vuc2l0aXZlLFxuXHRcdCAgICAgIGNhc2VTZW5zaXRpdmUgPSBfcmVmJGNhc2VTZW5zaXRpdmUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRjYXNlU2Vuc2l0aXZlLFxuXHRcdCAgICAgIF9yZWYkZmluZENodW5rcyA9IF9yZWYuZmluZENodW5rcyxcblx0XHQgICAgICBmaW5kQ2h1bmtzID0gX3JlZiRmaW5kQ2h1bmtzID09PSB1bmRlZmluZWQgPyBkZWZhdWx0RmluZENodW5rcyA6IF9yZWYkZmluZENodW5rcyxcblx0XHQgICAgICBzYW5pdGl6ZSA9IF9yZWYuc2FuaXRpemUsXG5cdFx0ICAgICAgc2VhcmNoV29yZHMgPSBfcmVmLnNlYXJjaFdvcmRzLFxuXHRcdCAgICAgIHRleHRUb0hpZ2hsaWdodCA9IF9yZWYudGV4dFRvSGlnaGxpZ2h0O1xuXHRcdCAgcmV0dXJuIGZpbGxJbkNodW5rcyh7XG5cdFx0ICAgIGNodW5rc1RvSGlnaGxpZ2h0OiBjb21iaW5lQ2h1bmtzKHtcblx0XHQgICAgICBjaHVua3M6IGZpbmRDaHVua3Moe1xuXHRcdCAgICAgICAgYXV0b0VzY2FwZTogYXV0b0VzY2FwZSxcblx0XHQgICAgICAgIGNhc2VTZW5zaXRpdmU6IGNhc2VTZW5zaXRpdmUsXG5cdFx0ICAgICAgICBzYW5pdGl6ZTogc2FuaXRpemUsXG5cdFx0ICAgICAgICBzZWFyY2hXb3Jkczogc2VhcmNoV29yZHMsXG5cdFx0ICAgICAgICB0ZXh0VG9IaWdobGlnaHQ6IHRleHRUb0hpZ2hsaWdodFxuXHRcdCAgICAgIH0pXG5cdFx0ICAgIH0pLFxuXHRcdCAgICB0b3RhbExlbmd0aDogdGV4dFRvSGlnaGxpZ2h0ID8gdGV4dFRvSGlnaGxpZ2h0Lmxlbmd0aCA6IDBcblx0XHQgIH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGFrZXMgYW4gYXJyYXkgb2Yge3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn0gb2JqZWN0cyBhbmQgY29tYmluZXMgY2h1bmtzIHRoYXQgb3ZlcmxhcCBpbnRvIHNpbmdsZSBjaHVua3MuXG5cdFx0ICogQHJldHVybiB7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfVtdXG5cdFx0ICovXG5cdFx0dmFyIGNvbWJpbmVDaHVua3MgPSBleHBvcnRzLmNvbWJpbmVDaHVua3MgPSBmdW5jdGlvbiBjb21iaW5lQ2h1bmtzKF9yZWYyKSB7XG5cdFx0ICB2YXIgY2h1bmtzID0gX3JlZjIuY2h1bmtzO1xuXHRcdFxuXHRcdCAgY2h1bmtzID0gY2h1bmtzLnNvcnQoZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcblx0XHQgICAgcmV0dXJuIGZpcnN0LnN0YXJ0IC0gc2Vjb25kLnN0YXJ0O1xuXHRcdCAgfSkucmVkdWNlKGZ1bmN0aW9uIChwcm9jZXNzZWRDaHVua3MsIG5leHRDaHVuaykge1xuXHRcdCAgICAvLyBGaXJzdCBjaHVuayBqdXN0IGdvZXMgc3RyYWlnaHQgaW4gdGhlIGFycmF5Li4uXG5cdFx0ICAgIGlmIChwcm9jZXNzZWRDaHVua3MubGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgICAgcmV0dXJuIFtuZXh0Q2h1bmtdO1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICAgIC8vIC4uLiBzdWJzZXF1ZW50IGNodW5rcyBnZXQgY2hlY2tlZCB0byBzZWUgaWYgdGhleSBvdmVybGFwLi4uXG5cdFx0ICAgICAgdmFyIHByZXZDaHVuayA9IHByb2Nlc3NlZENodW5rcy5wb3AoKTtcblx0XHQgICAgICBpZiAobmV4dENodW5rLnN0YXJ0IDw9IHByZXZDaHVuay5lbmQpIHtcblx0XHQgICAgICAgIC8vIEl0IG1heSBiZSB0aGUgY2FzZSB0aGF0IHByZXZDaHVuayBjb21wbGV0ZWx5IHN1cnJvdW5kcyBuZXh0Q2h1bmssIHNvIHRha2UgdGhlXG5cdFx0ICAgICAgICAvLyBsYXJnZXN0IG9mIHRoZSBlbmQgaW5kZWNlcy5cblx0XHQgICAgICAgIHZhciBlbmRJbmRleCA9IE1hdGgubWF4KHByZXZDaHVuay5lbmQsIG5leHRDaHVuay5lbmQpO1xuXHRcdCAgICAgICAgcHJvY2Vzc2VkQ2h1bmtzLnB1c2goeyBzdGFydDogcHJldkNodW5rLnN0YXJ0LCBlbmQ6IGVuZEluZGV4IH0pO1xuXHRcdCAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICBwcm9jZXNzZWRDaHVua3MucHVzaChwcmV2Q2h1bmssIG5leHRDaHVuayk7XG5cdFx0ICAgICAgfVxuXHRcdCAgICAgIHJldHVybiBwcm9jZXNzZWRDaHVua3M7XG5cdFx0ICAgIH1cblx0XHQgIH0sIFtdKTtcblx0XHRcblx0XHQgIHJldHVybiBjaHVua3M7XG5cdFx0fTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBFeGFtaW5lIHRleHQgZm9yIGFueSBtYXRjaGVzLlxuXHRcdCAqIElmIHdlIGZpbmQgbWF0Y2hlcywgYWRkIHRoZW0gdG8gdGhlIHJldHVybmVkIGFycmF5IGFzIGEgXCJjaHVua1wiIG9iamVjdCAoe3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn0pLlxuXHRcdCAqIEByZXR1cm4ge3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn1bXVxuXHRcdCAqL1xuXHRcdHZhciBkZWZhdWx0RmluZENodW5rcyA9IGZ1bmN0aW9uIGRlZmF1bHRGaW5kQ2h1bmtzKF9yZWYzKSB7XG5cdFx0ICB2YXIgYXV0b0VzY2FwZSA9IF9yZWYzLmF1dG9Fc2NhcGUsXG5cdFx0ICAgICAgY2FzZVNlbnNpdGl2ZSA9IF9yZWYzLmNhc2VTZW5zaXRpdmUsXG5cdFx0ICAgICAgX3JlZjMkc2FuaXRpemUgPSBfcmVmMy5zYW5pdGl6ZSxcblx0XHQgICAgICBzYW5pdGl6ZSA9IF9yZWYzJHNhbml0aXplID09PSB1bmRlZmluZWQgPyBpZGVudGl0eSA6IF9yZWYzJHNhbml0aXplLFxuXHRcdCAgICAgIHNlYXJjaFdvcmRzID0gX3JlZjMuc2VhcmNoV29yZHMsXG5cdFx0ICAgICAgdGV4dFRvSGlnaGxpZ2h0ID0gX3JlZjMudGV4dFRvSGlnaGxpZ2h0O1xuXHRcdFxuXHRcdCAgdGV4dFRvSGlnaGxpZ2h0ID0gc2FuaXRpemUodGV4dFRvSGlnaGxpZ2h0KTtcblx0XHRcblx0XHQgIHJldHVybiBzZWFyY2hXb3Jkcy5maWx0ZXIoZnVuY3Rpb24gKHNlYXJjaFdvcmQpIHtcblx0XHQgICAgcmV0dXJuIHNlYXJjaFdvcmQ7XG5cdFx0ICB9KSAvLyBSZW1vdmUgZW1wdHkgd29yZHNcblx0XHQgIC5yZWR1Y2UoZnVuY3Rpb24gKGNodW5rcywgc2VhcmNoV29yZCkge1xuXHRcdCAgICBzZWFyY2hXb3JkID0gc2FuaXRpemUoc2VhcmNoV29yZCk7XG5cdFx0XG5cdFx0ICAgIGlmIChhdXRvRXNjYXBlKSB7XG5cdFx0ICAgICAgc2VhcmNoV29yZCA9IGVzY2FwZVJlZ0V4cEZuKHNlYXJjaFdvcmQpO1xuXHRcdCAgICB9XG5cdFx0XG5cdFx0ICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoc2VhcmNoV29yZCwgY2FzZVNlbnNpdGl2ZSA/ICdnJyA6ICdnaScpO1xuXHRcdFxuXHRcdCAgICB2YXIgbWF0Y2ggPSB2b2lkIDA7XG5cdFx0ICAgIHdoaWxlIChtYXRjaCA9IHJlZ2V4LmV4ZWModGV4dFRvSGlnaGxpZ2h0KSkge1xuXHRcdCAgICAgIHZhciBzdGFydCA9IG1hdGNoLmluZGV4O1xuXHRcdCAgICAgIHZhciBlbmQgPSByZWdleC5sYXN0SW5kZXg7XG5cdFx0ICAgICAgLy8gV2UgZG8gbm90IHJldHVybiB6ZXJvLWxlbmd0aCBtYXRjaGVzXG5cdFx0ICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG5cdFx0ICAgICAgICBjaHVua3MucHVzaCh7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSk7XG5cdFx0ICAgICAgfVxuXHRcdFxuXHRcdCAgICAgIC8vIFByZXZlbnQgYnJvd3NlcnMgbGlrZSBGaXJlZm94IGZyb20gZ2V0dGluZyBzdHVjayBpbiBhbiBpbmZpbml0ZSBsb29wXG5cdFx0ICAgICAgLy8gU2VlIGh0dHA6Ly93d3cucmVnZXhndXJ1LmNvbS8yMDA4LzA0L3dhdGNoLW91dC1mb3ItemVyby1sZW5ndGgtbWF0Y2hlcy9cblx0XHQgICAgICBpZiAobWF0Y2guaW5kZXggPT0gcmVnZXgubGFzdEluZGV4KSB7XG5cdFx0ICAgICAgICByZWdleC5sYXN0SW5kZXgrKztcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0XHRcblx0XHQgICAgcmV0dXJuIGNodW5rcztcblx0XHQgIH0sIFtdKTtcblx0XHR9O1xuXHRcdC8vIEFsbG93IHRoZSBmaW5kQ2h1bmtzIHRvIGJlIG92ZXJyaWRkZW4gaW4gZmluZEFsbCxcblx0XHQvLyBidXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdlIGV4cG9ydCBhcyB0aGUgb2xkIG5hbWVcblx0XHRleHBvcnRzLmZpbmRDaHVua3MgPSBkZWZhdWx0RmluZENodW5rcztcblx0XHRcblx0XHQvKipcblx0XHQgKiBHaXZlbiBhIHNldCBvZiBjaHVua3MgdG8gaGlnaGxpZ2h0LCBjcmVhdGUgYW4gYWRkaXRpb25hbCBzZXQgb2YgY2h1bmtzXG5cdFx0ICogdG8gcmVwcmVzZW50IHRoZSBiaXRzIG9mIHRleHQgYmV0d2VlbiB0aGUgaGlnaGxpZ2h0ZWQgdGV4dC5cblx0XHQgKiBAcGFyYW0gY2h1bmtzVG9IaWdobGlnaHQge3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn1bXVxuXHRcdCAqIEBwYXJhbSB0b3RhbExlbmd0aCBudW1iZXJcblx0XHQgKiBAcmV0dXJuIHtzdGFydDpudW1iZXIsIGVuZDpudW1iZXIsIGhpZ2hsaWdodDpib29sZWFufVtdXG5cdFx0ICovXG5cdFx0XG5cdFx0dmFyIGZpbGxJbkNodW5rcyA9IGV4cG9ydHMuZmlsbEluQ2h1bmtzID0gZnVuY3Rpb24gZmlsbEluQ2h1bmtzKF9yZWY0KSB7XG5cdFx0ICB2YXIgY2h1bmtzVG9IaWdobGlnaHQgPSBfcmVmNC5jaHVua3NUb0hpZ2hsaWdodCxcblx0XHQgICAgICB0b3RhbExlbmd0aCA9IF9yZWY0LnRvdGFsTGVuZ3RoO1xuXHRcdFxuXHRcdCAgdmFyIGFsbENodW5rcyA9IFtdO1xuXHRcdCAgdmFyIGFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChzdGFydCwgZW5kLCBoaWdobGlnaHQpIHtcblx0XHQgICAgaWYgKGVuZCAtIHN0YXJ0ID4gMCkge1xuXHRcdCAgICAgIGFsbENodW5rcy5wdXNoKHtcblx0XHQgICAgICAgIHN0YXJ0OiBzdGFydCxcblx0XHQgICAgICAgIGVuZDogZW5kLFxuXHRcdCAgICAgICAgaGlnaGxpZ2h0OiBoaWdobGlnaHRcblx0XHQgICAgICB9KTtcblx0XHQgICAgfVxuXHRcdCAgfTtcblx0XHRcblx0XHQgIGlmIChjaHVua3NUb0hpZ2hsaWdodC5sZW5ndGggPT09IDApIHtcblx0XHQgICAgYXBwZW5kKDAsIHRvdGFsTGVuZ3RoLCBmYWxzZSk7XG5cdFx0ICB9IGVsc2Uge1xuXHRcdCAgICB2YXIgbGFzdEluZGV4ID0gMDtcblx0XHQgICAgY2h1bmtzVG9IaWdobGlnaHQuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcblx0XHQgICAgICBhcHBlbmQobGFzdEluZGV4LCBjaHVuay5zdGFydCwgZmFsc2UpO1xuXHRcdCAgICAgIGFwcGVuZChjaHVuay5zdGFydCwgY2h1bmsuZW5kLCB0cnVlKTtcblx0XHQgICAgICBsYXN0SW5kZXggPSBjaHVuay5lbmQ7XG5cdFx0ICAgIH0pO1xuXHRcdCAgICBhcHBlbmQobGFzdEluZGV4LCB0b3RhbExlbmd0aCwgZmFsc2UpO1xuXHRcdCAgfVxuXHRcdCAgcmV0dXJuIGFsbENodW5rcztcblx0XHR9O1xuXHRcdFxuXHRcdGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG5cdFx0ICByZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHRcdFxuXHRcdGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cEZuKHN0cikge1xuXHRcdCAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgJ1xcXFwkJicpO1xuXHRcdH1cblx0XG5cdC8qKiovIH0pXG5cdC8qKioqKiovIF0pO1xuXHQvLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqL1xuXHRcblx0aWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcblx0ICAgIFN5bWJvbC5mb3IgJiZcblx0ICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcblx0ICAgIDB4ZWFjNztcblx0XG5cdCAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdCAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcblx0ICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG5cdCAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXHQgIH07XG5cdFxuXHQgIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuXHQgIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2Rcblx0ICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcblx0fSBlbHNlIHtcblx0ICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuXHQgIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2Rcblx0ICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpKCk7XG5cdH1cblx0XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKSlcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Ly8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cdHZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblx0XG5cdC8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuXHQvLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcblx0Ly8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuXHQvLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXHRcblx0dmFyIGNhY2hlZFNldFRpbWVvdXQ7XG5cdHZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cdFxuXHRmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG5cdH1cblx0ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xuXHR9XG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcblx0ICAgICAgICB9XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuXHQgICAgICAgIH1cblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuXHQgICAgfVxuXHR9ICgpKVxuXHRmdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuXHQgICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcblx0ICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcblx0ICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuXHQgICAgfVxuXHQgICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcblx0ICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuXHQgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuXHQgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3Ncblx0ICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuXHQgICAgfSBjYXRjaChlKXtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcblx0ICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuXHQgICAgICAgIH0gY2F0Y2goZSl7XG5cdCAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdFxuXHRcblx0fVxuXHRmdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG5cdCAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcblx0ICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcblx0ICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG5cdCAgICB9XG5cdCAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG5cdCAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcblx0ICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG5cdCAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuXHQgICAgfVxuXHQgICAgdHJ5IHtcblx0ICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG5cdCAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuXHQgICAgfSBjYXRjaCAoZSl7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuXHQgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcblx0ICAgICAgICB9IGNhdGNoIChlKXtcblx0ICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG5cdCAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcblx0ICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0XG5cdFxuXHR9XG5cdHZhciBxdWV1ZSA9IFtdO1xuXHR2YXIgZHJhaW5pbmcgPSBmYWxzZTtcblx0dmFyIGN1cnJlbnRRdWV1ZTtcblx0dmFyIHF1ZXVlSW5kZXggPSAtMTtcblx0XG5cdGZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcblx0ICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGRyYWluaW5nID0gZmFsc2U7XG5cdCAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuXHQgICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcblx0ICAgIH1cblx0ICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcblx0ICAgICAgICBkcmFpblF1ZXVlKCk7XG5cdCAgICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG5cdCAgICBpZiAoZHJhaW5pbmcpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcblx0ICAgIGRyYWluaW5nID0gdHJ1ZTtcblx0XG5cdCAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuXHQgICAgd2hpbGUobGVuKSB7XG5cdCAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG5cdCAgICAgICAgcXVldWUgPSBbXTtcblx0ICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG5cdCAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcblx0ICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG5cdCAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuXHQgICAgfVxuXHQgICAgY3VycmVudFF1ZXVlID0gbnVsbDtcblx0ICAgIGRyYWluaW5nID0gZmFsc2U7XG5cdCAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG5cdH1cblx0XG5cdHByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG5cdCAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cdCAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuXHQgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcblx0ICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuXHQgICAgfVxuXHR9O1xuXHRcblx0Ly8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuXHRmdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcblx0ICAgIHRoaXMuZnVuID0gZnVuO1xuXHQgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuXHR9XG5cdEl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xuXHR9O1xuXHRwcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xuXHRwcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xuXHRwcm9jZXNzLmVudiA9IHt9O1xuXHRwcm9jZXNzLmFyZ3YgPSBbXTtcblx0cHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5cdHByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblx0XG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXHRcblx0cHJvY2Vzcy5vbiA9IG5vb3A7XG5cdHByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xuXHRwcm9jZXNzLm9uY2UgPSBub29wO1xuXHRwcm9jZXNzLm9mZiA9IG5vb3A7XG5cdHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xuXHRwcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5cdHByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cdHByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcblx0cHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblx0XG5cdHByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblx0XG5cdHByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cdH07XG5cdFxuXHRwcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xuXHRwcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblx0fTtcblx0cHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cblx0ICpcblx0ICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5cdCAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblx0ICovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdHZhciBpbnZhcmlhbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHR2YXIgd2FybmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdHZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblx0XG5cdHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHR2YXIgY2hlY2tQcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcblx0ICAvKiBnbG9iYWwgU3ltYm9sICovXG5cdCAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuXHQgIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXHRcblx0ICAvKipcblx0ICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG5cdCAgICpcblx0ICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcblx0ICAgKlxuXHQgICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG5cdCAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG5cdCAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuXHQgICAqICAgICAgIC4uLlxuXHQgICAqICAgICB9XG5cdCAgICpcblx0ICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcblx0ICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG5cdCAgICovXG5cdCAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG5cdCAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuXHQgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgLyoqXG5cdCAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcblx0ICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuXHQgICAqXG5cdCAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuXHQgICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblx0ICAgKiAgICAgcHJvcFR5cGVzOiB7XG5cdCAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuXHQgICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG5cdCAgICpcblx0ICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG5cdCAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuXHQgICAqXG5cdCAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG5cdCAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuXHQgICAqICAgICB9LFxuXHQgICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuXHQgICAqICAgfSk7XG5cdCAgICpcblx0ICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG5cdCAgICpcblx0ICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcblx0ICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cblx0ICAgKlxuXHQgICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcblx0ICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG5cdCAgICpcblx0ICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblx0ICAgKiAgICBwcm9wVHlwZXM6IHtcblx0ICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cblx0ICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuXHQgICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXHQgICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcblx0ICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuXHQgICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG5cdCAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuXHQgICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuXHQgICAqICAgICAgICAgICk7XG5cdCAgICogICAgICAgIH1cblx0ICAgKiAgICAgIH1cblx0ICAgKiAgICB9LFxuXHQgICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuXHQgICAqICB9KTtcblx0ICAgKlxuXHQgICAqIEBpbnRlcm5hbFxuXHQgICAqL1xuXHRcblx0ICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXHRcblx0ICAvLyBJbXBvcnRhbnQhXG5cdCAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuXHQgIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcblx0ICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcblx0ICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG5cdCAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcblx0ICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuXHQgICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG5cdCAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcblx0ICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXHRcblx0ICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcblx0ICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcblx0ICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuXHQgICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcblx0ICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG5cdCAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcblx0ICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG5cdCAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG5cdCAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcblx0ICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuXHQgIH07XG5cdFxuXHQgIC8qKlxuXHQgICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cblx0ICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcblx0ICAgKi9cblx0ICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cdCAgZnVuY3Rpb24gaXMoeCwgeSkge1xuXHQgICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuXHQgICAgaWYgKHggPT09IHkpIHtcblx0ICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG5cdCAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG5cdCAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG5cdCAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXHRcblx0ICAvKipcblx0ICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG5cdCAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcblx0ICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG5cdCAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuXHQgICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcblx0ICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdCAgICB0aGlzLnN0YWNrID0gJyc7XG5cdCAgfVxuXHQgIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cblx0ICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcblx0ICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG5cdCAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuXHQgICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG5cdCAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcblx0ICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXHRcblx0ICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcblx0ICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuXHQgICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG5cdCAgICAgICAgICBpbnZhcmlhbnQoXG5cdCAgICAgICAgICAgIGZhbHNlLFxuXHQgICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG5cdCAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuXHQgICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcblx0ICAgICAgICAgICk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG5cdCAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG5cdCAgICAgICAgICBpZiAoXG5cdCAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcblx0ICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG5cdCAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuXHQgICAgICAgICAgKSB7XG5cdCAgICAgICAgICAgIHdhcm5pbmcoXG5cdCAgICAgICAgICAgICAgZmFsc2UsXG5cdCAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuXHQgICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG5cdCAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcblx0ICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcblx0ICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJyxcblx0ICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXG5cdCAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuXHQgICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcblx0ICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuXHQgICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcblx0ICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXHRcblx0ICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuXHQgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXHQgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuXHQgICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuXHQgICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuXHQgICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuXHQgICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cblx0ICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXHRcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcblx0ICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblx0ICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcblx0ICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcblx0ICAgICAgfVxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcblx0ICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgcmV0dXJuIGVycm9yO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcblx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblx0ICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG5cdCAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG5cdCAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcblx0ICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuXHQgICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuXHQgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuXHQgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG5cdCAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcblx0ICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHRcblx0ICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcblx0ICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuXHQgICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblx0ICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcblx0ICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG5cdCAgICAgIH1cblx0ICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuXHQgICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHQgICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcblx0ICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBlcnJvcjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG5cdCAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcblx0ICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG5cdCAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcblx0ICAgIH1cblx0XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuXHQgICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB3YXJuaW5nKFxuXHQgICAgICAgICAgZmFsc2UsXG5cdCAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuXHQgICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXG5cdCAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXG5cdCAgICAgICAgICBpXG5cdCAgICAgICAgKTtcblx0ICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuXHQgICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcblx0ICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHRcblx0ICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcblx0ICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuXHQgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXHQgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuXHQgICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuXHQgICAgICB9XG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG5cdCAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG5cdCAgICAgICAgaWYgKCFjaGVja2VyKSB7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuXHQgICAgICAgIGlmIChlcnJvcikge1xuXHQgICAgICAgICAgcmV0dXJuIGVycm9yO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuXHQgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXHQgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuXHQgICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG5cdCAgICAgIC8vIHByb3BzLlxuXHQgICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcblx0ICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcblx0ICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcblx0ICAgICAgICBpZiAoIWNoZWNrZXIpIHtcblx0ICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcblx0ICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuXHQgICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuXHQgICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcblx0ICAgICAgICAgICk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcblx0ICAgICAgICBpZiAoZXJyb3IpIHtcblx0ICAgICAgICAgIHJldHVybiBlcnJvcjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcblx0ICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuXHQgICAgICBjYXNlICdudW1iZXInOlxuXHQgICAgICBjYXNlICdzdHJpbmcnOlxuXHQgICAgICBjYXNlICd1bmRlZmluZWQnOlxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICBjYXNlICdib29sZWFuJzpcblx0ICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcblx0ICAgICAgY2FzZSAnb2JqZWN0Jzpcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG5cdCAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcblx0ICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuXHQgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG5cdCAgICAgICAgICB2YXIgc3RlcDtcblx0ICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuXHQgICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG5cdCAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuXHQgICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG5cdCAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcblx0ICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuXHQgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcblx0ICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG5cdCAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG5cdCAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cblx0ICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHRcblx0ICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG5cdCAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG5cdCAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuXHQgICAgICByZXR1cm4gJ2FycmF5Jztcblx0ICAgIH1cblx0ICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0ICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuXHQgICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cblx0ICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG5cdCAgICAgIHJldHVybiAnb2JqZWN0Jztcblx0ICAgIH1cblx0ICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuXHQgICAgICByZXR1cm4gJ3N5bWJvbCc7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcHJvcFR5cGU7XG5cdCAgfVxuXHRcblx0ICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG5cdCAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG5cdCAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG5cdCAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG5cdCAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcblx0ICAgIH1cblx0ICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG5cdCAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdCAgICAgICAgcmV0dXJuICdkYXRlJztcblx0ICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0ICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBwcm9wVHlwZTtcblx0ICB9XG5cdFxuXHQgIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cblx0ICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuXHQgIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuXHQgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG5cdCAgICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgICAgY2FzZSAnYXJyYXknOlxuXHQgICAgICBjYXNlICdvYmplY3QnOlxuXHQgICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG5cdCAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuXHQgICAgICBjYXNlICdkYXRlJzpcblx0ICAgICAgY2FzZSAncmVnZXhwJzpcblx0ICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgcmV0dXJuIHR5cGU7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuXHQgIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcblx0ICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuXHQgICAgICByZXR1cm4gQU5PTllNT1VTO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuXHQgIH1cblx0XG5cdCAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcblx0ICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblx0XG5cdCAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xuXHR9O1xuXHRcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oNSkpKVxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdC8qKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cblx0ICpcblx0ICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5cdCAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblx0ICpcblx0ICogXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBhcmc7XG5cdCAgfTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG5cdCAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG5cdCAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG5cdCAqL1xuXHR2YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblx0XG5cdGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcblx0ZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuXHRlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuXHRlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuXHRlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0ZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuXHQgIHJldHVybiBhcmc7XG5cdH07XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKlxuXHQgKi9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG5cdCAqXG5cdCAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG5cdCAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuXHQgKiBleHBlY3RpbmcuXG5cdCAqXG5cdCAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG5cdCAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cblx0ICovXG5cdFxuXHR2YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXHRcblx0aWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuXHQgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcblx0ICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXHRcblx0ICBpZiAoIWNvbmRpdGlvbikge1xuXHQgICAgdmFyIGVycm9yO1xuXHQgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcblx0ICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcblx0ICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcblx0ICAgICAgfSkpO1xuXHQgICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuXHQgICAgfVxuXHRcblx0ICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcblx0ICAgIHRocm93IGVycm9yO1xuXHQgIH1cblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKSlcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqXG5cdCAqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIGVtcHR5RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHRcblx0LyoqXG5cdCAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cblx0ICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuXHQgKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuXHQgKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cblx0ICovXG5cdFxuXHR2YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cdFxuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG5cdCAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIGFyZ0luZGV4ID0gMDtcblx0ICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcblx0ICAgIH0pO1xuXHQgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuXHQgICAgfVxuXHQgICAgdHJ5IHtcblx0ICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuXHQgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcblx0ICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcblx0ICAgIH0gY2F0Y2ggKHgpIHt9XG5cdCAgfTtcblx0XG5cdCAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcblx0ICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcblx0ICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuXHQgICAgfVxuXHRcblx0ICAgIGlmICghY29uZGl0aW9uKSB7XG5cdCAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcblx0ICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuXHQgICAgfVxuXHQgIH07XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oNSkpKVxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Lypcblx0b2JqZWN0LWFzc2lnblxuXHQoYykgU2luZHJlIFNvcmh1c1xuXHRAbGljZW5zZSBNSVRcblx0Ki9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0dmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0XG5cdGZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRcdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gT2JqZWN0KHZhbCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cdFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0XHR9KTtcblx0XHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdFx0dmFyIHRlc3QzID0ge307XG5cdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0XHR2YXIgZnJvbTtcblx0XHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHRcdHZhciBzeW1ib2xzO1xuXHRcblx0XHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXHRcblx0XHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gdG87XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cblx0ICpcblx0ICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5cdCAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cblx0ICovXG5cdFxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHByb2Nlc3MpIHsvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cdCAqXG5cdCAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuXHQgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG5cdCAqL1xuXHRcblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0aWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcblx0ICB2YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0ICB2YXIgd2FybmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdCAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdCAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXHR9XG5cdFxuXHQvKipcblx0ICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuXHQgKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcblx0ICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cblx0ICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcblx0ICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuXHQgICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuXHQgICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcblx0ICAgICAgICB2YXIgZXJyb3I7XG5cdCAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cblx0ICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG5cdCAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcblx0ICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cblx0ICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG5cdCAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG5cdCAgICAgICAgICBlcnJvciA9IGV4O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpO1xuXHQgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG5cdCAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcblx0ICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG5cdCAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXHRcblx0ICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXHRcblx0ICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuXHRcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oNSkpKVxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXHQgKlxuXHQgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcblx0ICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuXHQgKi9cblx0XG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBlbXB0eUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0dmFyIGludmFyaWFudCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblx0ICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG5cdCAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuXHQgICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGludmFyaWFudChcblx0ICAgICAgZmFsc2UsXG5cdCAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcblx0ICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuXHQgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcblx0ICAgICk7XG5cdCAgfTtcblx0ICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuXHQgIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG5cdCAgICByZXR1cm4gc2hpbTtcblx0ICB9O1xuXHQgIC8vIEltcG9ydGFudCFcblx0ICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cblx0ICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG5cdCAgICBhcnJheTogc2hpbSxcblx0ICAgIGJvb2w6IHNoaW0sXG5cdCAgICBmdW5jOiBzaGltLFxuXHQgICAgbnVtYmVyOiBzaGltLFxuXHQgICAgb2JqZWN0OiBzaGltLFxuXHQgICAgc3RyaW5nOiBzaGltLFxuXHQgICAgc3ltYm9sOiBzaGltLFxuXHRcblx0ICAgIGFueTogc2hpbSxcblx0ICAgIGFycmF5T2Y6IGdldFNoaW0sXG5cdCAgICBlbGVtZW50OiBzaGltLFxuXHQgICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcblx0ICAgIG5vZGU6IHNoaW0sXG5cdCAgICBvYmplY3RPZjogZ2V0U2hpbSxcblx0ICAgIG9uZU9mOiBnZXRTaGltLFxuXHQgICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuXHQgICAgc2hhcGU6IGdldFNoaW0sXG5cdCAgICBleGFjdDogZ2V0U2hpbVxuXHQgIH07XG5cdFxuXHQgIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcblx0ICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblx0XG5cdCAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBzaW1wbGVJc0VxdWFsID0gZnVuY3Rpb24gc2ltcGxlSXNFcXVhbChhLCBiKSB7XG5cdCAgcmV0dXJuIGEgPT09IGI7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBpbmRleCAocmVzdWx0Rm4pIHtcblx0ICB2YXIgaXNFcXVhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogc2ltcGxlSXNFcXVhbDtcblx0XG5cdCAgdmFyIGxhc3RUaGlzID0gdm9pZCAwO1xuXHQgIHZhciBsYXN0QXJncyA9IFtdO1xuXHQgIHZhciBsYXN0UmVzdWx0ID0gdm9pZCAwO1xuXHQgIHZhciBjYWxsZWRPbmNlID0gZmFsc2U7XG5cdFxuXHQgIHZhciBpc05ld0FyZ0VxdWFsVG9MYXN0ID0gZnVuY3Rpb24gaXNOZXdBcmdFcXVhbFRvTGFzdChuZXdBcmcsIGluZGV4KSB7XG5cdCAgICByZXR1cm4gaXNFcXVhbChuZXdBcmcsIGxhc3RBcmdzW2luZGV4XSk7XG5cdCAgfTtcblx0XG5cdCAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uIHJlc3VsdCgpIHtcblx0ICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBuZXdBcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICAgIG5ld0FyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKGNhbGxlZE9uY2UgJiYgbGFzdFRoaXMgPT09IHRoaXMgJiYgbmV3QXJncy5sZW5ndGggPT09IGxhc3RBcmdzLmxlbmd0aCAmJiBuZXdBcmdzLmV2ZXJ5KGlzTmV3QXJnRXF1YWxUb0xhc3QpKSB7XG5cdCAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIGNhbGxlZE9uY2UgPSB0cnVlO1xuXHQgICAgbGFzdFRoaXMgPSB0aGlzO1xuXHQgICAgbGFzdEFyZ3MgPSBuZXdBcmdzO1xuXHQgICAgbGFzdFJlc3VsdCA9IHJlc3VsdEZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuXHQgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBpbmRleDtcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcCJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpZCIsImxvYWRlZCIsImNhbGwiLCJtIiwiYyIsInAiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfSGlnaGxpZ2h0ZXIiLCJfSGlnaGxpZ2h0ZXIyIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJIaWdobGlnaHRlciIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImtleXMiLCJpbmRleE9mIiwiX2hpZ2hsaWdodFdvcmRzQ29yZSIsIl9wcm9wVHlwZXMiLCJfcHJvcFR5cGVzMiIsIl9yZWFjdCIsIl9tZW1vaXplT25lIiwiX21lbW9pemVPbmUyIiwicHJvcFR5cGVzIiwiYWN0aXZlQ2xhc3NOYW1lIiwic3RyaW5nIiwiYWN0aXZlSW5kZXgiLCJudW1iZXIiLCJhY3RpdmVTdHlsZSIsIm9iamVjdCIsImF1dG9Fc2NhcGUiLCJib29sIiwiY2xhc3NOYW1lIiwiZmluZENodW5rcyIsImZ1bmMiLCJoaWdobGlnaHRDbGFzc05hbWUiLCJvbmVPZlR5cGUiLCJoaWdobGlnaHRTdHlsZSIsImhpZ2hsaWdodFRhZyIsIm5vZGUiLCJzYW5pdGl6ZSIsInNlYXJjaFdvcmRzIiwiYXJyYXlPZiIsImluc3RhbmNlT2YiLCJSZWdFeHAiLCJpc1JlcXVpcmVkIiwidGV4dFRvSGlnaGxpZ2h0IiwidW5oaWdobGlnaHRUYWciLCJ1bmhpZ2hsaWdodENsYXNzTmFtZSIsInVuaGlnaGxpZ2h0U3R5bGUiLCJfcmVmIiwiX3JlZiRhY3RpdmVDbGFzc05hbWUiLCJ1bmRlZmluZWQiLCJfcmVmJGFjdGl2ZUluZGV4IiwiX3JlZiRjYXNlU2Vuc2l0aXZlIiwiY2FzZVNlbnNpdGl2ZSIsIl9yZWYkaGlnaGxpZ2h0Q2xhc3NOYW1lIiwiX3JlZiRoaWdobGlnaHRTdHlsZSIsIl9yZWYkaGlnaGxpZ2h0VGFnIiwiX3JlZiR1bmhpZ2hsaWdodFRhZyIsIl9yZWYkdW5oaWdobGlnaHRDbGFzc05hbWUiLCJyZXN0IiwiY2h1bmtzIiwiZmluZEFsbCIsIkhpZ2hsaWdodFRhZyIsImhpZ2hsaWdodEluZGV4IiwiaGlnaGxpZ2h0Q2xhc3NOYW1lcyIsImhpZ2hsaWdodFN0eWxlcyIsImxvd2VyY2FzZVByb3BzIiwibWFwcGVkIiwidG9Mb3dlckNhc2UiLCJtZW1vaXplZExvd2VyY2FzZVByb3BzIiwiY3JlYXRlRWxlbWVudCIsImNoaWxkcmVuIiwibWFwIiwiY2h1bmsiLCJpbmRleCIsInRleHQiLCJzdWJzdHIiLCJzdGFydCIsImVuZCIsImhpZ2hsaWdodCIsImhpZ2hsaWdodENsYXNzIiwiaXNBY3RpdmUiLCJwcm9wcyIsInN0eWxlIiwiX3V0aWxzIiwiZW51bWVyYWJsZSIsImdldCIsImNvbWJpbmVDaHVua3MiLCJmaWxsSW5DaHVua3MiLCJfcmVmJGZpbmRDaHVua3MiLCJkZWZhdWx0RmluZENodW5rcyIsImNodW5rc1RvSGlnaGxpZ2h0IiwidG90YWxMZW5ndGgiLCJfcmVmMiIsInNvcnQiLCJmaXJzdCIsInNlY29uZCIsInJlZHVjZSIsInByb2Nlc3NlZENodW5rcyIsIm5leHRDaHVuayIsInByZXZDaHVuayIsInBvcCIsImVuZEluZGV4IiwiTWF0aCIsIm1heCIsInB1c2giLCJfcmVmMyIsIl9yZWYzJHNhbml0aXplIiwiaWRlbnRpdHkiLCJmaWx0ZXIiLCJzZWFyY2hXb3JkIiwiZXNjYXBlUmVnRXhwRm4iLCJyZWdleCIsIm1hdGNoIiwiZXhlYyIsImxhc3RJbmRleCIsIl9yZWY0IiwiYWxsQ2h1bmtzIiwiYXBwZW5kIiwiZm9yRWFjaCIsInN0ciIsInJlcGxhY2UiLCJwcm9jZXNzIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiaXNWYWxpZEVsZW1lbnQiLCIkJHR5cGVvZiIsInRocm93T25EaXJlY3RBY2Nlc3MiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJsZW4iLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJBcnJheSIsIkl0ZW0iLCJhcnJheSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJuYW1lIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siLCJlbXB0eUZ1bmN0aW9uIiwiaW52YXJpYW50Iiwid2FybmluZyIsIlJlYWN0UHJvcFR5cGVzU2VjcmV0IiwiY2hlY2tQcm9wVHlwZXMiLCJJVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJpdGVyYXRvckZuIiwiQU5PTllNT1VTIiwiUmVhY3RQcm9wVHlwZXMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsInN5bWJvbCIsImFueSIsImNyZWF0ZUFueVR5cGVDaGVja2VyIiwiY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyIiwiZWxlbWVudCIsImNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlciIsImNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIiLCJjcmVhdGVOb2RlQ2hlY2tlciIsIm9iamVjdE9mIiwiY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlciIsIm9uZU9mIiwiY3JlYXRlRW51bVR5cGVDaGVja2VyIiwiY3JlYXRlVW5pb25UeXBlQ2hlY2tlciIsInNoYXBlIiwiY3JlYXRlU2hhcGVUeXBlQ2hlY2tlciIsImV4YWN0IiwiY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlciIsImlzIiwieCIsInkiLCJQcm9wVHlwZUVycm9yIiwibWVzc2FnZSIsInN0YWNrIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsIm1hbnVhbFByb3BUeXBlQ2FsbENhY2hlIiwibWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQiLCJjaGVja1R5cGUiLCJwcm9wTmFtZSIsImNvbXBvbmVudE5hbWUiLCJsb2NhdGlvbiIsInByb3BGdWxsTmFtZSIsInNlY3JldCIsImNvbnNvbGUiLCJjYWNoZUtleSIsImNoYWluZWRDaGVja1R5cGUiLCJiaW5kIiwiZXhwZWN0ZWRUeXBlIiwicHJvcFZhbHVlIiwicHJvcFR5cGUiLCJnZXRQcm9wVHlwZSIsInByZWNpc2VUeXBlIiwiZ2V0UHJlY2lzZVR5cGUiLCJ0aGF0UmV0dXJuc051bGwiLCJ0eXBlQ2hlY2tlciIsImlzQXJyYXkiLCJlcnJvciIsImV4cGVjdGVkQ2xhc3MiLCJleHBlY3RlZENsYXNzTmFtZSIsImFjdHVhbENsYXNzTmFtZSIsImdldENsYXNzTmFtZSIsImV4cGVjdGVkVmFsdWVzIiwidmFsdWVzU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImFycmF5T2ZUeXBlQ2hlY2tlcnMiLCJjaGVja2VyIiwiZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nIiwiaXNOb2RlIiwic2hhcGVUeXBlcyIsImFsbEtleXMiLCJldmVyeSIsInN0ZXAiLCJlbnRyaWVzIiwibmV4dCIsImRvbmUiLCJlbnRyeSIsImlzU3ltYm9sIiwiRGF0ZSIsInR5cGUiLCJjb25zdHJ1Y3RvciIsIlByb3BUeXBlcyIsIm1ha2VFbXB0eUZ1bmN0aW9uIiwiYXJnIiwidGhhdFJldHVybnMiLCJ0aGF0UmV0dXJuc0ZhbHNlIiwidGhhdFJldHVybnNUcnVlIiwidGhhdFJldHVybnNUaGlzIiwidGhhdFJldHVybnNBcmd1bWVudCIsInZhbGlkYXRlRm9ybWF0IiwiZm9ybWF0IiwiY29uZGl0aW9uIiwiYSIsImIiLCJkIiwiZiIsImFyZ0luZGV4IiwiZnJhbWVzVG9Qb3AiLCJwcmludFdhcm5pbmciLCJfbGVuIiwiX2tleSIsIl9sZW4yIiwiX2tleTIiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsIlR5cGVFcnJvciIsInNob3VsZFVzZU5hdGl2ZSIsInRlc3QxIiwiU3RyaW5nIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwibiIsImpvaW4iLCJ0ZXN0MyIsInNwbGl0IiwibGV0dGVyIiwiZXJyIiwiZnJvbSIsInRvIiwic3ltYm9scyIsInMiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJnZXRTdGFjayIsInR5cGVTcGVjTmFtZSIsImV4Iiwic2hpbSIsImdldFNoaW0iLCJyZXF1aXJlIiwic2ltcGxlSXNFcXVhbCIsInJlc3VsdEZuIiwiaXNFcXVhbCIsImxhc3RUaGlzIiwibGFzdEFyZ3MiLCJsYXN0UmVzdWx0IiwiY2FsbGVkT25jZSIsImlzTmV3QXJnRXF1YWxUb0xhc3QiLCJuZXdBcmciLCJyZXN1bHQiLCJuZXdBcmdzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-highlight-words/dist/main.js\n");

/***/ })

};
;